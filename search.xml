<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Community Cache with Complete Information 论文阅读笔记</title>
    <url>/2021/03/24/A-Community-Cache-with-Complete-Information/</url>
    <content><![CDATA[<p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/image-20210528160349306.png" alt="image-20210528160349306"></p>
<a id="more"></a>

<h1 id="A-Community-Cache-with-Complete-Information"><a href="#A-Community-Cache-with-Complete-Information" class="headerlink" title="A Community Cache with Complete Information"></a>A Community Cache with Complete Information</h1><h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><h3 id="1-P2：存算分离"><a href="#1-P2：存算分离" class="headerlink" title="(1)  P2：存算分离"></a>(1)  P2：存算分离</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p2.png" alt="image-20210406114806954"></p>
<p>P2：在现代的数据中心中，存储资源通常以资源池的形式呈现给计算集群，由计算集群共享存储资源，存储集群和计算集群使用互联网络相连。</p>
<hr>
<h3 id="2-P3：大数据分析应用的I-O瓶颈"><a href="#2-P3：大数据分析应用的I-O瓶颈" class="headerlink" title="(2) P3：大数据分析应用的I/O瓶颈"></a>(2) P3：大数据分析应用的I/O瓶颈</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p3.png" alt="image-20210406114845569"></p>
<p>P3：以大数据分析应用场景为例，部署在计算集群中的大数据分析框架通过互联网络从数据池中获取待分析的数据，这些数据通常是TB或者PB级，此时，频繁的I/O操作会占用大量的网络带宽，从而使I/O成为大数据分析过程的瓶颈。</p>
<hr>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><h3 id="1-P4：Alluxio"><a href="#1-P4：Alluxio" class="headerlink" title="(1) P4：Alluxio"></a>(1) P4：Alluxio</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p4.png" alt="image-20210406114912889"></p>
<p>P4：Alluxio的通过在计算集群中增加Cache层来减轻网络负载，从而提高I/O性能。但是Alluxio的Cache分配和网络利用较为糟糕，例如，当两个分析框架使用相同的数据对象时，Alluxio会在计算集群中缓存两个O1对象，存在冗余和数据一致性的问题。</p>
<hr>
<h2 id="3-方案设计"><a href="#3-方案设计" class="headerlink" title="3.方案设计"></a>3.方案设计</h2><h3 id="1-P5：Community-cache"><a href="#1-P5：Community-cache" class="headerlink" title="(1) P5：Community cache"></a>(1) P5：Community cache</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p5.png" alt="image-20210406114921426"></p>
<p>P5：通过采用Community Cache，可以消除Alluxio的缺点。即在运行不分析平台的多个集群中共享相同的数据缓存实例，这样做不仅可以解决数据冗余的问题，还能弹性拓展计算集群。</p>
<hr>
<h3 id="2-P6：完整的信息"><a href="#2-P6：完整的信息" class="headerlink" title="(2) P6：完整的信息"></a>(2) P6：完整的信息</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p6.png" alt="image-20210406114940204"></p>
<p>P6：计算集群缓存可以和集群的任务调度信息进行配合（任务的DAG数据流图），从而更好地利用缓存。</p>
<hr>
<h3 id="3-P7：I-O数据流、网络和存储资源的使用情况"><a href="#3-P7：I-O数据流、网络和存储资源的使用情况" class="headerlink" title="(3) P7：I/O数据流、网络和存储资源的使用情况"></a>(3) P7：I/O数据流、网络和存储资源的使用情况</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p7.png" alt="image-20210406115039487"></p>
<p>P7：一方面，可以通过在大数据分析框架获取任务调度信息和I/O数据流，另一方面，可以通过数据池获取实时的存储资源和网络的使用情况，</p>
<hr>
<h3 id="4-P8：执行时间-缓存信息-带宽监测-I-O数据流-更好地缓存预测"><a href="#4-P8：执行时间-缓存信息-带宽监测-I-O数据流-更好地缓存预测" class="headerlink" title="(4) P8：执行时间+缓存信息+带宽监测+I/O数据流 = 更好地缓存预测"></a>(4) P8：执行时间+缓存信息+带宽监测+I/O数据流 = 更好地缓存预测</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p8.png" alt="image-20210406115108489"></p>
<p>P8：利用执行时间+缓存信息+带宽监测+I/O数据流四方面的数据，可以实现更好地缓存预测。</p>
<hr>
<h2 id="4-方案说明"><a href="#4-方案说明" class="headerlink" title="4. 方案说明"></a>4. 方案说明</h2><h3 id="1-P9：CMR-最小化运行时间"><a href="#1-P9：CMR-最小化运行时间" class="headerlink" title="(1) P9：CMR-最小化运行时间"></a>(1) P9：CMR-最小化运行时间</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p9.png" alt="image-20210406115117190"></p>
<p>P9：下面以一个应用分析实例进行说明。用户编写的查询操作被分解为了数据流图，这一过程在应用实际执行之前就可以获得，此时，我们就得到了各个执行单元的I/O依赖关系.</p>
<hr>
<h3 id="2-P10：共享缓存"><a href="#2-P10：共享缓存" class="headerlink" title="(2) P10：共享缓存"></a>(2) P10：共享缓存</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p10.png" alt="image-20210406115124529"></p>
<p>P10：Dataflow DAG、Inputs &amp; ranges、Scheduling schema数据都可以从但数据分析框架中获取，Community Cache就可以利用这些信息更好地管理缓存，从而提升系统性能。</p>
<hr>
<h3 id="3-P11：时空图"><a href="#3-P11：时空图" class="headerlink" title="(3) P11：时空图"></a>(3) P11：时空图</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p11.png" alt="image-20210406115132295"></p>
<p>P11：通过各单元执行时间的预测信息，我们可以汇出时空图，如右图所示。通过这张图我们很容易看出关键路径：S3 -&gt; S5 -&gt; S6 -&gt; S7</p>
<hr>
<h3 id="4-P12：优化关键路径"><a href="#4-P12：优化关键路径" class="headerlink" title="(4) P12：优化关键路径"></a>(4) P12：优化关键路径</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p12.png" alt="image-20210406115140562"></p>
<p>P12：CMR首先对关键路径上的执行单元进行优化，例如提升数据预取、数据缓存等操作的优先级，可以缩短这一关键路径</p>
<hr>
<h3 id="5-P13：多次优化关键路径"><a href="#5-P13：多次优化关键路径" class="headerlink" title="(5) P13：多次优化关键路径"></a>(5) P13：多次优化关键路径</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p13.png" alt="image-20210406115147790"></p>
<p>P13：优化完毕后，会产生新的关键路径，于CP不同，CMR会通过多次优化，使系统达到最优性能。</p>
<p>CP利用stage运行时预测来缓存数据，以减少DAGs中stage的关键路径。CMR依赖于Kariz对部分文件缓存的支持，从DAG的每个阶段预取部分数据，以提高单个关键路径之外的性能。</p>
<hr>
<h3 id="6-P14：优化前后时空图对比"><a href="#6-P14：优化前后时空图对比" class="headerlink" title="(6) P14：优化前后时空图对比"></a>(6) P14：优化前后时空图对比</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p14.png" alt="image-20210406115154780"></p>
<p>P14：这张图描述了优化前和优化后的数据流图。</p>
<hr>
<h2 id="5-方案实现"><a href="#5-方案实现" class="headerlink" title="5. 方案实现"></a>5. 方案实现</h2><h3 id="1-P15：优化思路"><a href="#1-P15：优化思路" class="headerlink" title="(1) P15：优化思路"></a>(1) P15：优化思路</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p15.png" alt="image-20210406115203132"></p>
<p>P15：对DAG的预取和缓存进行优先级排序，使它们之间的数据共享最大化，以最小化后端存储负载并最大限度地减少运行时</p>
<hr>
<h3 id="2-P16：总体架构"><a href="#2-P16：总体架构" class="headerlink" title="(2) P16：总体架构"></a>(2) P16：总体架构</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p16.png" alt="image-20210406115211925"></p>
<p>P16：</p>
<ul>
<li>使用分析框架获取DAG</li>
<li>通过拓展D3N实现community cache</li>
<li>分析datalake带宽</li>
<li>分析任务执行情况</li>
<li>CMR算法：多次优化关键路径</li>
</ul>
<h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h2><h3 id="1-P17："><a href="#1-P17：" class="headerlink" title="(1) P17："></a>(1) P17：</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p17.png" alt="image-20210406150839747"></p>
<p>P17：在Pig大数据分析框架下，使用 TPC-H benchmark进行测试，数据的规模是64GB，集群规模是16个节点，1.4TB内存和128个cpu核心，由测试结果可知，采用CMR算法相较于无cache的情形性能提升了2倍，相较于其他cache算法性能提升了1.3倍</p>
<h3 id="2-P18："><a href="#2-P18：" class="headerlink" title="(2) P18："></a>(2) P18：</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p18.png" alt="image-20210406150951348"></p>
<p>P18：在Spark大数据分析框架下，使用 TPC-H benchmark进行测试，数据的规模是64GB，集群规模是16个节点，1.4TB内存和128个cpu核心，由测试结果可知，采用CMR算法相较于无cache的情形性能提升了3倍，相较于其他cache算法性能提升了2倍</p>
<h3 id="3-P19："><a href="#3-P19：" class="headerlink" title="(3) P19："></a>(3) P19：</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p19.png" alt="image-20210406150954931"></p>
<p>CMR-M：CacheforMinimizing Runtime of multiple DAGs，在选择要缓存和预取的数据时，还考虑了存储带宽和跨多个查询的数据共享。当同一个分析框架存在多个 DAGs 时， CMR-M相较于其他算法能表现出更优地性能，尤其是当数据共享的比例越高，性能优势越明显。</p>
<h3 id="4-P20："><a href="#4-P20：" class="headerlink" title="(4) P20："></a>(4) P20：</h3><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p20.png" alt="image-20210406151012360"></p>
<p>和以Alluxio代表的cluster cache相比，community cache达到更有的性能，接近1.5倍。</p>
<h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p><img src="/2021/03/24/A-Community-Cache-with-Complete-Information/p21.png" alt="image-20210406151032787"></p>
<p>通过以上论述，我们可以得出以下结论：</p>
<ul>
<li>community cache允许数据在运行不同分析框架的计算集群中共享</li>
<li>community cache可以获取更加全面的信息，从而更好地进行缓存</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>paper</tag>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>FAST21&#39;《Learning Cache Replacement with CACHEUS》论文阅读笔记</title>
    <url>/2021/03/29/Learning-Cache-Replacement-with-CACHEUS/</url>
    <content><![CDATA[<img src="/2021/03/29/Learning-Cache-Replacement-with-CACHEUS/evaluation.png" alt="image-20210329180941128" style="zoom: 50%;">

<a id="more"></a>



<h1 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. 主要内容</h1><blockquote>
<p>FAST 21‘ Learning Cache Replacement with CACHEUS</p>
</blockquote>
<p>机器学习的发展为解决计算机系统中的经典问题开辟了一条新的途径，在存储领域，缓存替换策略就是问题之一。</p>
<p>本文使用机器学习算法改进缓存替换策略，主要内容如下：</p>
<ol>
<li>定义了四种工作负载原语类型，任何工作负载均有这四种原语组合而成。</li>
</ol>
<ul>
<li>LFU-friendly：由访问序列定义，该序列由最近使用的最少的（LRU）缓存算法处理最优。</li>
<li>LRU-friendly：由访问序列定义，该序列由最不经常使用（LFU）缓存算法处理最优。</li>
<li>scan：由访问序列定义，每个项只被访问一次。</li>
<li>churn：定义为对存储项子集的重复访问，每个项被访问的概率相等。</li>
</ul>
<ol start="2">
<li>改进了LeCaR，提出CACHEUS。<ul>
<li>LFU→CR-LFU，LRU→SR-LRU</li>
<li>采用动态的学习速率</li>
</ul>
</li>
</ol>
<h1 id="2-研究动机"><a href="#2-研究动机" class="headerlink" title="2. 研究动机"></a>2. 研究动机</h1><h2 id="2-1-缓存替换策略存在的问题"><a href="#2-1-缓存替换策略存在的问题" class="headerlink" title="2.1 缓存替换策略存在的问题"></a>2.1 缓存替换策略存在的问题</h2><p>现有的缓存替换策略存在以下两个问题：</p>
<ol>
<li>不同的工作负载、乃至同一个工作负载在不同的时间段会表现出不同的访存特性，对于特定工作负载缓存替换策略不一定适合另一些。</li>
<li>缓存块的大小会影响缓存替换策略的效果。</li>
</ol>
<p>★ How TO Do?</p>
<p>利用机器学习算法决定使用哪一种缓存替换策略</p>
<h2 id="2-2-缓存替换策略的分类"><a href="#2-2-缓存替换策略的分类" class="headerlink" title="2.2 缓存替换策略的分类"></a>2.2 缓存替换策略的分类</h2><p><img src="/2021/03/29/Learning-Cache-Replacement-with-CACHEUS/replacement-algorithms.png" alt="image-20210329092529537"></p>
<h2 id="2-3-别人是如何做的：LeCaR"><a href="#2-3-别人是如何做的：LeCaR" class="headerlink" title="2.3 别人是如何做的：LeCaR"></a>2.3 别人是如何做的：LeCaR</h2><h3 id="2-3-1-特性"><a href="#2-3-1-特性" class="headerlink" title="2.3.1 特性"></a>2.3.1 特性</h3><ul>
<li>使用强化学习和遗憾最小化来控制对**<code>LRU</code>** 和 <strong><code>LFU</code></strong> 的动态使用</li>
<li>通过历史预测信息更新 <strong><code>LRU</code></strong> 和 <strong><code>LFU</code></strong> 的权重</li>
<li>在 small cache size 上的表现胜过最先进的技术</li>
</ul>
<h3 id="2-3-2-不足"><a href="#2-3-2-不足" class="headerlink" title="2.3.2 不足"></a>2.3.2 不足</h3><ul>
<li>学习速率是手动输入的，不同的应用适合不同的学习速率，而LeCaR通过实验选择了固定的学习速率：0.45</li>
</ul>
<p><img src="/2021/03/29/Learning-Cache-Replacement-with-CACHEUS/learing-rate.png" alt="image-20210329100531522"></p>
<ul>
<li>不能处理 scan 型负载</li>
</ul>
<p><img src="/2021/03/29/Learning-Cache-Replacement-with-CACHEUS/categories.png" alt="image-20210329100250606"></p>
<h1 id="3-CACHEUS的设计"><a href="#3-CACHEUS的设计" class="headerlink" title="3. CACHEUS的设计"></a>3. CACHEUS的设计</h1><p>一句话：对LeCaR进行了改进</p>
<h3 id="3-1-改进1：采用自适应的机器学习速率，η表示学习速率，机器学习模型如下："><a href="#3-1-改进1：采用自适应的机器学习速率，η表示学习速率，机器学习模型如下：" class="headerlink" title="3.1 改进1：采用自适应的机器学习速率，η表示学习速率，机器学习模型如下："></a>3.1 改进1：采用自适应的机器学习速率，η表示学习速率，机器学习模型如下：</h3><p>$$<br>W_t = W_{t-1}e^{ηγ}<br>$$</p>
<p>对于每一轮迭代，采取如下操作：</p>
<ul>
<li>若学习速率改变<ul>
<li>性能改变<ul>
<li>变优，强化变化趋势</li>
<li>变差，反转变化趋势</li>
</ul>
</li>
</ul>
</li>
<li>若学习速率未改变<ul>
<li>性能改变<ul>
<li>变优，不更新</li>
<li>变差，随机条约</li>
</ul>
</li>
</ul>
</li>
<li>如果学习速率不变，并且连续10个窗口大小性能持续下降或变为零，将学习速率重置为初始值</li>
</ul>
<h3 id="3-2-改进2：将LeCaR中的-LRU-替换为-SR-LRU，将LeCaR中的-LFU-替换为-CR-LFU"><a href="#3-2-改进2：将LeCaR中的-LRU-替换为-SR-LRU，将LeCaR中的-LFU-替换为-CR-LFU" class="headerlink" title="3.2 改进2：将LeCaR中的 LRU 替换为 SR-LRU，将LeCaR中的 LFU 替换为 CR-LFU"></a>3.2 改进2：将LeCaR中的 LRU 替换为 <code>SR-LRU</code>，将LeCaR中的 <code>LFU</code> 替换为 <code>CR-LFU</code></h3><ul>
<li><p>通过历史预测信息更新 <strong><code>LRU</code></strong> 和 <strong><code>LFU</code></strong> 的权重，控制对**<code>SR-LRU</code>** 和 <strong><code>CR-LFU</code></strong> 的动态使用</p>
</li>
<li><p><code>SR-LRU</code></p>
<ul>
<li><p><code>LRU Problem</code>：scan型负载会替换掉cache中被访问多次的page</p>
</li>
<li><p>它将缓存分为两部分：一部分仅包含具有多个访问权限的项（R），另一部分用于单访问项以及具有多个访问权限的旧项（SR）。SR分区允许SR-LRU具有抗扫描性；一个用于容纳新项目的分区，以便它们不会影响R中的重要项目。SR-LRU仅从SR分区逐出-当缓存已满时，它在缓存未命中时逐出SR的LRU项目。R中较旧的项被降级为SR，以便只保留在R中重用的重要项。此外，SR-LRU维护的历史列表的大小与包含最近逐出的项的缓存的大小相同。</p>
</li>
<li><p>当缓存遗漏时，x不在历史列表中，x会被插入到SR的MRU位置，如果缓存满了，SR的LRU项会被驱逐到HLU。如果缓存满了，SR的LRU项会被驱逐到H，如果H满了，算法会删除H的LRU项以腾出空间。缓存遗漏时，x在H中，x被移到R的MRU位置；缓存命中时，x在SR中，x被移到R的MRU位置；缓存命中时，x在R中，x被移到R的MRU位置。</p>
</li>
</ul>
</li>
<li><p><code>CR-LFU</code></p>
<ul>
<li><code>LFU Problem</code>：如果要访问的项目数大于缓存的大小，则LRU风格的算法将导致缓存内容的搅动，从而重复地将项目插入缓存并从缓存中逐出</li>
<li>抗搅扰LFU（CR-LFU）修改了纯LFU中的替换机制，当多个缓存项的访问频率最低时，选择MRU（Most Recently Used）项来打破束缚。通过选择MRU项，CR-LFU有效地将频率最低的项目子集 “锁定 “到缓存中，使 缓存算法产生命中。</li>
</ul>
</li>
</ul>
<h1 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. 实验结果</h1><p><img src="/2021/03/29/Learning-Cache-Replacement-with-CACHEUS/evaluation.png" alt="image-20210329180941128"></p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>paper</tag>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>kubenates 运行任务时出现can&#39;t join IPC of container...non-shareable IPC的错误</title>
    <url>/2019/11/17/docker-IPC-error/</url>
    <content><![CDATA[<img src="/2019/11/17/docker-IPC-error/data_docker.jpg" alt="docker" style="zoom: 40%;">

<a id="more"></a>

<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>最近在k8s的过程中遇到了<code>can&#39;t join IPC of container...non-shareable IPC</code>的错误，用博客记录一下错误的排查和解决过程。</p>
<p>原因是19.03版本 <code>Docker</code> 的默认 <code>IpcMode</code> 被修改为了 <code>private</code> ，需要修改配置文件将其设置为 <code>shareable</code>.</p>
<h2 id="应用版本"><a href="#应用版本" class="headerlink" title="应用版本"></a>应用版本</h2><ul>
<li>系统版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-mst:/# uname -a</span><br><span class="line">Linux k8s-mst 4.15.0-70-generic #79-Ubuntu SMP Tue Nov 12 10:36:11 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>kubenate版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-mst:/# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;5+&quot;, GitVersion:&quot;v1.5.9-beta.0-dirty&quot;, GitCommit:&quot;f35802d3a00b37a32476451266af05ce9760fec0&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2019-11-13T06:51:04Z&quot;, GoVersion:&quot;go1.7.4&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>docker版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-nod1:/# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.4</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.12.10</span><br><span class="line"> Git commit:        9013bf583a</span><br><span class="line"> Built:             Fri Oct 18 15:54:09 2019</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.4</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.12.10</span><br><span class="line">  Git commit:       9013bf583a</span><br><span class="line">  Built:            Fri Oct 18 15:52:40 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.2.10</span><br><span class="line">  GitCommit:        b34a5c8af56e510852c35414db4c1f4fa6172339</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc8+dev</span><br><span class="line">  GitCommit:        3e425f80a8c931f88e6d94a8c831b9d5aa481657</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h1><ul>
<li>使用 <code>kubectl get pod</code> 查看pod的运行状态发现异常</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@k8s-mst:~/web_sample# kubectl apply -f nginx-deployment.yaml</span><br><span class="line">deployment &quot;nginx-deployment&quot; created</span><br><span class="line">root@k8s-mst:~/web_sample# kubectl get pod</span><br><span class="line">NAME                                READY     STATUS              RESTARTS   AGE</span><br><span class="line">nginx-deployment-4087004473-4m0br   0/1       RunContainerError   0          7s</span><br><span class="line">nginx-deployment-4087004473-80rqd   0/1       RunContainerError   0          7s</span><br><span class="line">nginx-deployment-4087004473-qfdmw   0/1       RunContainerError   0          7s</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>使用 <code>kubectl describe pod</code> 查看详细的错误信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeen     LastSeen        Count   From                    SubObjectPath           Type            Reason          Message</span><br><span class="line">  ---------     --------        -----   ----                    -------------           --------        ------          -------</span><br><span class="line">  34s           34s             1       &#123;default-scheduler &#125;                            Normal          Scheduled       Successfully assigned nginx-deployment-4087004473-qfdmw to k8s-nod2</span><br><span class="line">  31s           31s             1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Normal          Created         Created container with docker id 7fc4f63e0bd6; Security:[seccomp=unconfined]</span><br><span class="line">  30s           30s             1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Warning         Failed          Failed to start container with docker id 7fc4f63e0bd6 with error: Error response from daemon: &#123;&quot;message&quot;:&quot;can&#x27;t join IPC of container 2dfd13510b3f816ed0437ea70a8a57daeaa7a38eec0035972044b25dd102f1cd: non-shareable IPC (hint: use IpcMode:shareable for the donor container)&quot;&#125;</span><br><span class="line">  28s           28s             1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Normal          Created         Created container with docker id 3c61a9aaa6a4; Security:[seccomp=unconfined]</span><br><span class="line">  28s           28s             1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Warning         Failed          Failed to start container with docker id 3c61a9aaa6a4 with error: Error response from daemon: &#123;&quot;message&quot;:&quot;can&#x27;t join IPC of container 2dfd13510b3f816ed0437ea70a8a57daeaa7a38eec0035972044b25dd102f1cd: non-shareable IPC (hint: use IpcMode:shareable for the donor container)&quot;&#125;</span><br><span class="line">  18s           18s             1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Normal          Created         Created container with docker id 42970a39a9b4; Security:[seccomp=unconfined]</span><br><span class="line">  17s           17s             1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Warning         Failed          Failed to start container with docker id 42970a39a9b4 with error: Error response from daemon: &#123;&quot;message&quot;:&quot;can&#x27;t join IPC of container 2dfd13510b3f816ed0437ea70a8a57daeaa7a38eec0035972044b25dd102f1cd: non-shareable IPC (hint: use IpcMode:shareable for the donor container)&quot;&#125;</span><br><span class="line">  32s           3s              4       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Normal          Pulled          Container image &quot;nginx:1.7.9&quot; already present on machine</span><br><span class="line">  30s           2s              4       &#123;kubelet k8s-nod2&#125;                              Warning         FailedSync      Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;nginx&quot; with RunContainerError: &quot;runContainer: Error response from daemon: &#123;\&quot;message\&quot;:\&quot;can&#x27;t join IPC of container 2dfd13510b3f816ed0437ea70a8a57daeaa7a38eec0035972044b25dd102f1cd: non-shareable IPC (hint: use IpcMode:shareable for the donor container)\&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">  2s    2s      1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Normal  Created Created container with docker id 20ca9e358257; Security:[seccomp=unconfined]</span><br><span class="line">  2s    2s      1       &#123;kubelet k8s-nod2&#125;      spec.containers&#123;nginx&#125;  Warning Failed  Failed to start container with docker id 20ca9e358257 with error: Error response from daemon: &#123;&quot;message&quot;:&quot;can&#x27;t join IPC of container 2dfd13510b3f816ed0437ea70a8a57daeaa7a38eec0035972044b25dd102f1cd: non-shareable IPC (hint: use IpcMode:shareable for the donor container)&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>根据日志信息，错误是由 <code>IPC mode</code> 导致的，并且提到使用 <code>shareable</code> 模式来解决，接下来需要将<code>IpcMode</code>修改为<code>shareable</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;message&quot;</span>:<span class="string">&quot;can&#x27;t join IPC of container 2dfd13510b3f816ed0437ea70a8a57daeaa7a38eec0035972044b25dd102f1cd: non-shareable IPC (hint: use IpcMode:shareable for the donor container)&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>在 <code>Docker</code> 官方文档中用关键字搜索 <code>docker ipc</code> ，在<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc">docker run reference</a>中找到修改<code>IpcMode</code>的方式<br><img src="https://img-blog.csdnimg.cn/20191117121207886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTkyODE2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<ul>
<li>在 <code>docker docs </code>中用关键字搜索 <code>docker default ipc</code> 查找修改默认 <code>ipc</code> 模式的方式，<a href="https://docs.docker.com/engine/release-notes/19.03/">docker 19.03 release note</a>中提到默认的<code>ipc</code>模式被修改为了<code>private</code>，因此我们需要将</li>
</ul>
<p><img src="/2019/11/17/docker-IPC-error/private-ipc.png" alt="image-20210528163138562"></p>
<ul>
<li>通过链接来到<code>github</code>的<a href="https://github.com/moby/moby/pull/35621">pr</a>提交记录查找解决方法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Old (bad, but backward-compatible) behavior (i.e. <span class="string">&quot;shareable&quot;</span> containers by default) can be enabled by either using --default-ipc-mode shareable daemon <span class="built_in">command</span> line option, or by adding a <span class="string">&quot;default-ipc-mode&quot;</span>: shareable<span class="string">&quot; line in docker.json configuration file.</span></span><br></pre></td></tr></table></figure>


<ul>
<li>根据提示，修改/etc/docker/daemon.json（没有的话新建一个），添加如下内容</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;default-ipc-mode&quot;</span>: <span class="string">&quot;shareable&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>重启docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h1 id="重新运行"><a href="#重新运行" class="headerlink" title="重新运行"></a>重新运行</h1><ul>
<li>重新部署deployment，可以看到pod正常运行。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@k8s-mst:~/web_sample<span class="comment"># kubectl apply -f nginx-deployment.yaml</span></span><br><span class="line">deployment <span class="string">&quot;nginx-deployment&quot;</span> created</span><br><span class="line">root@k8s-mst:~/web_sample<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-4087004473-9wjbr   1/1       Running   0          29s</span><br><span class="line">nginx-deployment-4087004473-g9qpr   1/1       Running   0          29s</span><br><span class="line">nginx-deployment-4087004473-z6jkm   1/1       Running   0          29s</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Reference</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>docker</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo 的原理和使用(完善中)</title>
    <url>/2021/04/14/dubbo/</url>
    <content><![CDATA[<img src="/2021/04/14/dubbo/dubbo-archi.png" style="zoom: 50%;">

<a id="more"></a>



<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-什么是RPC"><a href="#1-1-什么是RPC" class="headerlink" title="1.1 什么是RPC"></a>1.1 什么是RPC</h2><p>远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>
<img src="/2021/04/14/dubbo/dubbo-archi.png" style="zoom: 67%;">

<h1 id="2-dubbo配置"><a href="#2-dubbo配置" class="headerlink" title="2. dubbo配置"></a>2. dubbo配置</h1><h2 id="2-1-安装ZooKeeper（Windows10环境）"><a href="#2-1-安装ZooKeeper（Windows10环境）" class="headerlink" title="2.1 安装ZooKeeper（Windows10环境）"></a>2.1 安装ZooKeeper（Windows10环境）</h2><ul>
<li><p>下载zookeeper安装包并解压：<a href="https://downloads.apache.org/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz">https://downloads.apache.org/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz</a></p>
</li>
<li><p>进入解压目录，复制 <code>conf</code> 下的 <code>zoo_sample.cfg</code> 为 <code>zoo.cfg</code> ，并修改 <code>dataDir=../data</code> ，同时在解压目录下创建data文件夹</p>
</li>
<li><p>在cmd中启动zookeeper</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows</span></span><br><span class="line">$ <span class="built_in">cd</span> bin</span><br><span class="line">$ zkServer.cmd</span><br><span class="line">...</span><br><span class="line">some info</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux</span></span><br><span class="line">$ <span class="built_in">cd</span> bin</span><br><span class="line">$ ./zkServer.sh start</span><br><span class="line">... </span><br><span class="line">some info</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>zookeeper会占用8080端口，通过在 <code>zoo.cfg</code> 中添加 <code>admin.serverPort=8888</code> 解除8080端口的占用</li>
</ul>
<h2 id="2-2-安装监控中心（可选）"><a href="#2-2-安装监控中心（可选）" class="headerlink" title="2.2 安装监控中心（可选）"></a>2.2 安装监控中心（可选）</h2><ul>
<li>克隆项目</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git clonegit <span class="built_in">clone</span> https://github.com/apache/dubbo-admin.git</span><br><span class="line">$ <span class="built_in">cd</span> dubbo-admin</span><br><span class="line">$ mvn clean package</span><br></pre></td></tr></table></figure>



<ul>
<li>前端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> dubbo-admin-ui</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>



<ul>
<li>后端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> dubbo-admin-server</span><br><span class="line">$ mvn clean package</span><br><span class="line">$ <span class="built_in">cd</span> target</span><br><span class="line">$ java -jar dubbo-admin-server-0.3.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>



<h2 id="2-3-Spring-Demo"><a href="#2-3-Spring-Demo" class="headerlink" title="2.3 Spring Demo"></a>2.3 Spring Demo</h2><h3 id="2-3-1-Provider"><a href="#2-3-1-Provider" class="headerlink" title="2.3.1 Provider"></a>2.3.1 Provider</h3><ul>
<li>pom.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>indi.pancras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>provider.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 指定当前服务/应用的名字（不要和其他服务同名） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;provider&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 指定注册中心的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 指定通信规则（通信协议、通信端口）  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;31111&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4. 暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;provider.interfaces.ComputationalStorageService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;css&quot;</span> <span class="attr">class</span>=<span class="string">&quot;provider.interfaces.impl.ComputationalStorageServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MainApplication.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> provider.interfaces.ComputationalStorageService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pancras</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19 17:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;provider.xml&quot;</span>);</span><br><span class="line">        ioc.start();</span><br><span class="line">        ComputationalStorageService bean = ioc.getBean(ComputationalStorageService.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ComputationalStorageService.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> provider.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pancras</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19 17:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputationalStorageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">wordCount</span><span class="params">(String filename)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ComputationalStorageServiceImpl.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> provider.interfaces.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> provider.interfaces.ComputationalStorageService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 将服务提供者注册到注册中心</span></span><br><span class="line"><span class="comment"> *    1.1 导入dubbo依赖</span></span><br><span class="line"><span class="comment"> *    1.2 配置服务提供者</span></span><br><span class="line"><span class="comment"> * 2. 让服务消费者去注册中心订阅服务提供者的服务地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pancras</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19 17:26</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputationalStorageServiceImpl</span> <span class="keyword">implements</span> <span class="title">ComputationalStorageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello: &quot;</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">wordCount</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-Consumer"><a href="#2-3-2-Consumer" class="headerlink" title="2.3.2 Consumer"></a>2.3.2 Consumer</h3><ul>
<li>pom.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>indi.pancras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>consumer.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 指定当前服务/应用的名字（不要和其他服务同名） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;consumer&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 指定注册中心的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;provider.interfaces.ComputationalStorageService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> <span class="attr">version</span>=<span class="string">&quot;*&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--         &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;1000&quot;&gt;&lt;/dubbo:method&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MainApplication.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> provider.interfaces.ComputationalStorageService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pancras</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19 17:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;consumer.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ComputationalStorageService bean = applicationContext.getBean(ComputationalStorageService.class);</span><br><span class="line">        String hello = bean.sayHello(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ComputationalStorageService.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> provider.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pancras</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19 17:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputationalStorageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">wordCount</span><span class="params">(String filename)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>dubbo</tag>
        <tag>java</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 快速入门</title>
    <url>/2021/07/07/docker/</url>
    <content><![CDATA[<p><img src="/2021/07/07/docker/static.oschina.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<a id="more"></a>

<h1 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动mysql5.7，并将D盘的mysql57/data/文件夹挂载到容器中作为mysql的数据保存位置</span></span><br><span class="line">$ docker run --name=mysql57 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /D/mysql57/data:/var/lib/mysql -d mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">$ docker run -d --name=redis6 -p 6379:6379 redis:6.2.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动zookeeper</span></span><br><span class="line">$ docker run -d --name=zookeeper -p 2181:2181 zookeeper:3.6.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># minio</span></span><br><span class="line">$ docker run -p 9000:9000 --name minio -e <span class="string">&quot;MINIO_ACCESS_KEY=minioadmin&quot;</span> -e <span class="string">&quot;MINIO_SECRET_KEY=minioadmin&quot;</span> -v E:/Movie:/data minio/minio server /data --console-address <span class="string">&quot;:9001&quot;</span> </span><br><span class="line">$ minio.exe server E:/minio --console-address <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="1-Docker的优点"><a href="#1-Docker的优点" class="headerlink" title="1. Docker的优点"></a>1. Docker的优点</h1><p><strong>更快的交付应用程序</strong></p>
<p>应用程序和环境一起发布，使得开发、测试和运维之间避免了许多因环境导致的问题。</p>
<p>减少了许多环境搭建工作，软件开发更加迅速。</p>
<p>快速部署：Build，ship and Run Any App，Anywhere</p>
<p><strong>部署和拓展更加容易</strong></p>
<p>docker容器几乎可以在所有环境中运行，包括台式机、物理服务器、虚拟机、数据中心。</p>
<p>docker容器具备可移植性，能很方便地从本地的测试环境部署到云中。</p>
<p>docker容器仅具有秒级地启动时间，可以在需要时快速启动更多容器，在不再需要时关闭它们。</p>
<p><strong>运行更多的负载</strong></p>
<p>相对于虚拟机，docker更加轻量，同一台物理设备上可以运行更多的负载。</p>
<p><strong>资源隔离</strong></p>
<p>容器技术解决了不同应用之间的潜在依赖冲突问题。</p>
<h1 id="2-Docker命令"><a href="#2-Docker命令" class="headerlink" title="2. Docker命令"></a>2. Docker命令</h1><ul>
<li>构建镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t provider:latest .</span><br></pre></td></tr></table></figure>

<ul>
<li>搜索镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>运行容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name=<span class="built_in">test</span> -it provider:latest -p 7998:7998</span><br></pre></td></tr></table></figure>

<ul>
<li>删除所有容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<ul>
<li>启动容器交互界面</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -t -i ID /bin/bash</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>docker  run</th>
<th>运行容器</th>
</tr>
</thead>
<tbody><tr>
<td>–name  NAME</td>
<td>为创建的容器命名</td>
</tr>
<tr>
<td>-i</td>
<td>保证容器的stdin是开启的</td>
</tr>
<tr>
<td>-t</td>
<td>为容器分配一个伪tty终端</td>
</tr>
<tr>
<td>-v</td>
<td>将宿主机的目录作为卷，挂在到容器里，-v  src:dest，本地目录必须是绝对路径，且挂载的是目录</td>
</tr>
<tr>
<td>–network</td>
<td>指定新容器将会在哪个网络中运行</td>
</tr>
<tr>
<td>-rm</td>
<td>容器运行完毕后即删除</td>
</tr>
<tr>
<td>-h</td>
<td>指定容器的主机名</td>
</tr>
<tr>
<td>ubuntu:xxx</td>
<td>创建容器的镜像</td>
</tr>
<tr>
<td>/bin/bash</td>
<td>创建容器后执行的命令</td>
</tr>
</tbody></table>
<h1 id="3-Dockerfile"><a href="#3-Dockerfile" class="headerlink" title="3. Dockerfile"></a>3. Dockerfile</h1><h2 id="3-1-RUN"><a href="#3-1-RUN" class="headerlink" title="3.1 RUN"></a>3.1 RUN</h2><p><strong>作用：</strong>在构建容器时运行的命令，常用于安装依赖，构造容器运行环境</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 等价于 RUN apt install python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;apt&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;python3-pip&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-CMD"><a href="#3-2-CMD" class="headerlink" title="3.2 CMD"></a>3.2 CMD</h2><p><strong>作用：</strong>类似于 RUN 指令，会被 <code>docker run</code> 附带的命令行参数覆盖</p>
<ul>
<li>CMD 在<code>docker run</code> 时运行。</li>
<li>RUN 是在 <code>docker build</code> 时运行。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> &lt;shell 命令&gt; <span class="comment"># CMD echo $PWD</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] <span class="comment"># CMD python3 test.py</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span></span><br></pre></td></tr></table></figure>



<h2 id="3-3-ENTRYPOINT"><a href="#3-3-ENTRYPOINT" class="headerlink" title="3.3 ENTRYPOINT"></a>3.3 ENTRYPOINT</h2><p><strong>作用：</strong>类似于 CMD 指令，但不会被 <code>docker run</code> 的命令行参数指定的指令所覆盖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>] <span class="comment"># 定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment"># 变参 </span></span></span><br></pre></td></tr></table></figure>

<p>1、不传参运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run nginx:<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>容器内会将CMD拼接在ENTRYPOINT后面，默认运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>2、传参运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run nginx:<span class="built_in">test</span> -c /home/user/new.conf</span><br></pre></td></tr></table></figure>

<p>容器内会使用传入的参数替换掉CMD，运行一下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -c /home/user/new.conf</span><br></pre></td></tr></table></figure>



<h2 id="3-4-COPY"><a href="#3-4-COPY" class="headerlink" title="3.4 COPY"></a>3.4 COPY</h2><p><strong>作用：</strong>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure>

<p>**&lt;目标路径&gt;**：容器内的绝对路径表示，该路径不用事先建好，路径不存在的话，会自动创建。</p>
<h2 id="3-5-ADD"><a href="#3-5-ADD" class="headerlink" title="3.5 ADD"></a>3.5 ADD</h2><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h2 id="3-6-ENV"><a href="#3-6-ENV" class="headerlink" title="3.6 ENV"></a>3.6 ENV</h2><p>设置环境变量，在后续的指令中，可以通过 <code>$&lt;key&gt;</code> 使用这个环境变量。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式1</span></span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="comment"># 格式2</span></span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>

<p>以下示例设置 <code>NODE_VERSION = 7.2.0</code> ， 在后续的指令中可以通过 <code>$NODE_VERSION</code> 引用：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="3-7-ARG"><a href="#3-7-ARG" class="headerlink" title="3.7 ARG"></a>3.7 ARG</h2><p><strong>作用：</strong>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>



<h2 id="3-8-WORKDIR"><a href="#3-8-WORKDIR" class="headerlink" title="3.8 WORKDIR"></a>3.8 WORKDIR</h2><p><strong>作用：</strong>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-9-VOLUME"><a href="#3-9-VOLUME" class="headerlink" title="3.9 VOLUME"></a>3.9 VOLUME</h2><p><strong>作用：</strong>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<h2 id="3-10-EXPOSE"><a href="#3-10-EXPOSE" class="headerlink" title="3.10 EXPOSE"></a>3.10 EXPOSE</h2><p><strong>作用：</strong>声明端口。</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure>

<h2 id="3-11-USER"><a href="#3-11-USER" class="headerlink" title="3.11 USER"></a>3.11 USER</h2><p><strong>作用：</strong>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
        <tag>docker</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-java</title>
    <url>/2021/11/16/effective-java/</url>
    <content><![CDATA[<img src="/2021/11/16/effective-java/R-C.be36f85217ee2705cbb1d688c0b07523" alt="查看源图像" style="zoom:33%;">

<a id="more"></a>

<h1 id="1-创建和销毁对象"><a href="#1-创建和销毁对象" class="headerlink" title="1. 创建和销毁对象"></a>1. 创建和销毁对象</h1><h2 id="1-1-使用静态工厂方法创建对象"><a href="#1-1-使用静态工厂方法创建对象" class="headerlink" title="1.1 使用静态工厂方法创建对象"></a>1.1 使用静态工厂方法创建对象</h2><p>（1）使用场景</p>
<p>适合大多场景，除非有合适的理由选择构造器方式。</p>
<p><strong>强烈推荐：</strong>当一个类需要多个带有相同签名的构造器时，就使用静态工厂方法代替构造器，并<strong>仔细选择名称</strong>以突出静态工厂方法之间的区别</p>
<p>（2）静态工厂方法的命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态工厂方法：</span><br><span class="line">from</span><br><span class="line">of</span><br><span class="line">valueOf</span><br><span class="line">instance或getInstance：根据参数值创建对象</span><br><span class="line">create或newInstance：确保每次调用都返回一个新的实例时使用</span><br><span class="line">getType</span><br><span class="line">newType</span><br><span class="line">type</span><br></pre></td></tr></table></figure>



<p>（3）优点</p>
<ul>
<li>当构造器过多时，用户不知道如何调用，这时候如果提供了带有名称的静态工厂方法，就提供了极大的便利</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = User.newUserByName(<span class="string">&quot;Mike&quot;</span>)</span><br><span class="line">User user = User.newUserByAge(<span class="number">19</span>)</span><br><span class="line">User user = User.newUser(<span class="string">&quot;Mike&quot;</span>, <span class="number">19</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回对象的时候可以返回同一个对象（缓存）</p>
</li>
<li><p>可以返回原始类型的子类型对象</p>
</li>
<li><p>返回的类对象可以使用动态加载机制创建（如SPI机制）</p>
</li>
</ul>
<p>（4）缺点</p>
<ul>
<li>构造器私有化后，就无法被子类继承</li>
<li>程序员很难发现它们</li>
</ul>
<h2 id="1-2-遇到多个构造器参数时考虑使用建造者（Builder）模式"><a href="#1-2-遇到多个构造器参数时考虑使用建造者（Builder）模式" class="headerlink" title="1.2 遇到多个构造器参数时考虑使用建造者（Builder）模式"></a>1.2 遇到多个构造器参数时考虑使用建造者（Builder）模式</h2><p>（1）使用场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4个或更多个参数</span><br></pre></td></tr></table></figure>

<p>（2）示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories      = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat           = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium        = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings    = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; calories = val;      <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; fat = val;           <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; sodium = val;        <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; carbohydrate = val;  <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize  = builder.servingSize;</span><br><span class="line">        servings     = builder.servings;</span><br><span class="line">        calories     = builder.calories;</span><br><span class="line">        fat          = builder.fat;</span><br><span class="line">        sodium       = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）优点</p>
<p>JavaBean模式的成员变量不能是final的，而建造者模式下可以是</p>
<p>解决了构造参数过多时参数错配导致的编程错误</p>
<h2 id="1-3-Singleton"><a href="#1-3-Singleton" class="headerlink" title="1.3 Singleton"></a>1.3 Singleton</h2><p>（1）使用场景</p>
<p>表示无状态的对象</p>
<p>表示系统中本质上唯一的组件</p>
<p>（2）不适用的场景</p>
<p>Singleton不适用依赖底层资源的类</p>
<p><strong>不要使用</strong>Singleton和静态工具类来实现一个或多个<strong>依赖底层资源</strong>的类</p>
<p>（3）实现方式</p>
<ul>
<li>使用enum实现</li>
<li>私有构造器+INSTANCE静态变量实现</li>
</ul>
<h2 id="1-4-优先考虑依赖注入来引用资源"><a href="#1-4-优先考虑依赖注入来引用资源" class="headerlink" title="1.4 优先考虑依赖注入来引用资源"></a>1.4 优先考虑依赖注入来引用资源</h2><p>（1）使用场景</p>
<p>创建一个新实例时，将其依赖的资源传到构造器中</p>
<p>（2）模式变体</p>
<p>将资源工厂（Factory）传递给构造器</p>
<p>（3）不适用的场景</p>
<p><strong>不要使用</strong>Singleton和静态工具类来实现一个或多个<strong>依赖底层资源</strong>的类，且该资源的行为会影响该类的行为</p>
<p><strong>不要使用</strong>这个类来<strong>创建</strong>这些资源</p>
<p>将资源或者资源工厂传给构造器（或静态工厂），通过它们来创建类</p>
<h2 id="1-5-消除过期的对象引用"><a href="#1-5-消除过期的对象引用" class="headerlink" title="1.5 消除过期的对象引用"></a>1.5 消除过期的对象引用</h2><p>（1）注意内存泄漏</p>
<p>只要是类自己管理内存，程序员就应该警惕内存泄漏问题</p>
<ul>
<li><p>自己实现的Stack，在出栈后要置null</p>
</li>
<li><p>缓存中失效的数据需要及时清除</p>
</li>
<li><p>监听器和其他回调</p>
</li>
</ul>
<h1 id="2-对象通用方法"><a href="#2-对象通用方法" class="headerlink" title="2. 对象通用方法"></a>2. 对象通用方法</h1><h2 id="2-1-equals"><a href="#2-1-equals" class="headerlink" title="2.1 equals"></a>2.1 equals</h2><p>不覆盖equals时，类的每个实例仅和其自身相等。</p>
<p>除非有合适的理由，否则不要覆盖equals方法。</p>
<h2 id="2-2-hashCode"><a href="#2-2-hashCode" class="headerlink" title="2.2 hashCode"></a>2.2 hashCode</h2><p>覆盖equals方法时总要覆盖hashCode</p>
<h2 id="2-3-toString"><a href="#2-3-toString" class="headerlink" title="2.3 toString"></a>2.3 toString</h2><p>始终要覆盖toString，且应该返回对象中值得关注的信息</p>
<ul>
<li>使系统易于调试</li>
</ul>
<h2 id="2-4-clone"><a href="#2-4-clone" class="headerlink" title="2.4 clone"></a>2.4 clone</h2><p>谨慎地覆盖clone</p>
<h2 id="2-5-Comparable"><a href="#2-5-Comparable" class="headerlink" title="2.5 Comparable"></a>2.5 Comparable</h2><p>考虑实现Comparable接口</p>
<p>实现了Comparable接口地类表明它地实例具有内在地排序关系</p>
<h2 id="2-5-finalize"><a href="#2-5-finalize" class="headerlink" title="2.5 finalize"></a>2.5 finalize</h2><p>不要使用finalize</p>
<h1 id="3-类和接口"><a href="#3-类和接口" class="headerlink" title="3. 类和接口"></a>3. 类和接口</h1><h2 id="3-1-使类和成员的可访问性最小化"><a href="#3-1-使类和成员的可访问性最小化" class="headerlink" title="3.1 使类和成员的可访问性最小化"></a>3.1 使类和成员的可访问性最小化</h2><p>（1）原则</p>
<p>尽可能使每个类或者成员不被外界访问</p>
<p>公有类的实例域决不能是公有的</p>
<h2 id="3-2-使可变性最小"><a href="#3-2-使可变性最小" class="headerlink" title="3.2 使可变性最小"></a>3.2 使可变性最小</h2><p>使可变性最小，优先考虑不可变对象（保留创建时的状态）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不提供任何设值方法</span><br><span class="line">保证类不会被扩展</span><br><span class="line">声明所有的域是final的</span><br><span class="line">声明所有的域是私有的</span><br></pre></td></tr></table></figure>

<p>除非有令人信服的理由要让类成为可变的类，否则它就应该是不可变的</p>
<p>如果类不能被做成不可变的，就应该降低它的可变性</p>
<p>除非有令人信服的理由要使域变成非final的，否则每个域都应该是final的</p>
<p>构造器（或静态工厂）应该创建完全初始化的对象，并建立起所有的约束关系</p>
<h1 id="3-3-复合优先于继承"><a href="#3-3-复合优先于继承" class="headerlink" title="3.3 复合优先于继承"></a>3.3 复合优先于继承</h1><p>要么设计继承并提供文档说明，要么禁止继承</p>
<h2 id="3-4-接口优于抽象类"><a href="#3-4-接口优于抽象类" class="headerlink" title="3.4 接口优于抽象类"></a>3.4 接口优于抽象类</h2><p>现有的类可以很容易被更新，以实现新的接口</p>
<p>接口允许构造非层次结构的类型框架</p>
<p>接口使安全地增强类的功能成为可能</p>
<h2 id="3-5-静态内部类优于非静态内部类"><a href="#3-5-静态内部类优于非静态内部类" class="headerlink" title="3.5 静态内部类优于非静态内部类"></a>3.5 静态内部类优于非静态内部类</h2><h1 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4. 泛型"></a>4. 泛型</h1><p>// TODO</p>
<h1 id="5-枚举和注解"><a href="#5-枚举和注解" class="headerlink" title="5. 枚举和注解"></a>5. 枚举和注解</h1><h2 id="5-1-使用enum替代int枚举模式"><a href="#5-1-使用enum替代int枚举模式" class="headerlink" title="5.1 使用enum替代int枚举模式"></a>5.1 使用enum替代int枚举模式</h2><p>（1）使用场景</p>
<p>需要一组固定常量，并且在编译时就知道其成员</p>
<p>（2）使用实例</p>
<ul>
<li>基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> RegistryType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper registry type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Zookeeper,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis registry type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Redis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RegistryType <span class="title">getType</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (RegistryType registryType : RegistryType.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (registryType.name().equalsIgnoreCase(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> registryType;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not support registry type: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将其他数值类型和枚举进行关联</li>
</ul>
<p>为了将数据与枚举常量关联起来，需要声明实例域，并编写一个带有数据并将数据保存在域中的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Planet &#123;</span><br><span class="line">    MERCURY(<span class="number">3.302e+23</span>, <span class="number">2.439e6</span>),</span><br><span class="line">    VENUS  (<span class="number">4.869e+24</span>, <span class="number">6.052e6</span>),</span><br><span class="line">    EARTH  (<span class="number">5.975e+24</span>, <span class="number">6.378e6</span>),</span><br><span class="line">    MARS   (<span class="number">6.419e+23</span>, <span class="number">3.393e6</span>),</span><br><span class="line">    JUPITER(<span class="number">1.899e+27</span>, <span class="number">7.149e7</span>),</span><br><span class="line">    SATURN (<span class="number">5.685e+26</span>, <span class="number">6.027e7</span>),</span><br><span class="line">    URANUS (<span class="number">8.683e+25</span>, <span class="number">2.556e7</span>),</span><br><span class="line">    NEPTUNE(<span class="number">1.024e+26</span>, <span class="number">2.477e7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;           <span class="comment">// In kilograms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;         <span class="comment">// In meters</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> surfaceGravity; <span class="comment">// In m / s^2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Universal gravitational constant in m^3 / kg s^2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> G = <span class="number">6.67300E-11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Planet(<span class="keyword">double</span> mass, <span class="keyword">double</span> radius) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mass = mass;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        surfaceGravity = G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mass</span><span class="params">()</span>           </span>&#123; <span class="keyword">return</span> mass; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">radius</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceGravity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> surfaceGravity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceWeight</span><span class="params">(<span class="keyword">double</span> mass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mass * surfaceGravity;  <span class="comment">// F = ma</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）注意</p>
<p>除非要将枚举方法导出，否则都应该声明为私有的，或包级私有的</p>
<h2 id="5-2-坚持使用-Override"><a href="#5-2-坚持使用-Override" class="headerlink" title="5.2 坚持使用@Override"></a>5.2 坚持使用@Override</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>检查参数的有效性</li>
<li>返回零长度的数组或集合，而不是null</li>
<li>将局部变量的作用域最小化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在第一次使用局部变量时声明它</span><br><span class="line">局部变量应包含初始化表达式</span><br><span class="line"><span class="keyword">for</span>循环优先于<span class="keyword">while</span>循环</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优先使用增强for循环（？增强for循环基于迭代器，性能要低）</p>
</li>
<li><p>如果其他类型更适合，则尽量避免使用字符串</p>
</li>
</ul>
<h1 id="6-Lambda和Stream"><a href="#6-Lambda和Stream" class="headerlink" title="6. Lambda和Stream"></a>6. Lambda和Stream</h1><p>// TODO</p>
<h1 id="7-方法"><a href="#7-方法" class="headerlink" title="7. 方法"></a>7. 方法</h1><h2 id="7-1-检查参数的有效性"><a href="#7-1-检查参数的有效性" class="headerlink" title="7.1 检查参数的有效性"></a>7.1 检查参数的有效性</h2><h2 id="7-2-谨慎设计方法签名"><a href="#7-2-谨慎设计方法签名" class="headerlink" title="7.2 谨慎设计方法签名"></a>7.2 谨慎设计方法签名</h2><ul>
<li><p>谨慎选择方法名称</p>
</li>
<li><p>不要过于追求提供便利的方法</p>
</li>
<li><p>避免过长的参数列表</p>
</li>
<li><p>对于参数类型，优先使用接口而不是类</p>
</li>
<li><p>对于boolean参数，要优先使用两个元素的枚举类型</p>
</li>
</ul>
<h2 id="7-3-返回零长度的数组或集合，而不是null"><a href="#7-3-返回零长度的数组或集合，而不是null" class="headerlink" title="7.3 返回零长度的数组或集合，而不是null"></a>7.3 返回零长度的数组或集合，而不是null</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeses</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cheesesInStock.isEmpty()?Collections.emptyList():<span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="8-通用编程"><a href="#8-通用编程" class="headerlink" title="8. 通用编程"></a>8. 通用编程</h1><h2 id="8-1-将局部变量的作用域最小化"><a href="#8-1-将局部变量的作用域最小化" class="headerlink" title="8.1 将局部变量的作用域最小化"></a>8.1 将局部变量的作用域最小化</h2><p>在第一次使用局部变量的地方声明它</p>
<h2 id="8-2-优先使用增强for循环"><a href="#8-2-优先使用增强for循环" class="headerlink" title="8.2 优先使用增强for循环"></a>8.2 优先使用增强for循环</h2><h2 id="8-3-合适的命名"><a href="#8-3-合适的命名" class="headerlink" title="8.3 合适的命名"></a>8.3 合适的命名</h2><ul>
<li><p>一旦发现有更好的名称，就换掉旧的</p>
</li>
<li><p>只要短名称足够清楚，就比长名称好</p>
</li>
</ul>
<h1 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h1><h2 id="9-1-只针对异常的情况才使用异常"><a href="#9-1-只针对异常的情况才使用异常" class="headerlink" title="9.1 只针对异常的情况才使用异常"></a>9.1 只针对异常的情况才使用异常</h2><p>不要在正常的控制流中使用异常，例如捕获数据越界错误</p>
<h2 id="9-2-对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"><a href="#9-2-对于可恢复的情况使用受检异常，对于编程错误使用运行时异常" class="headerlink" title="9.2 对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"></a>9.2 对于可恢复的情况使用受检异常，对于编程错误使用运行时异常</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果期望调用者能够适当地恢复，应使用受检异常</span><br><span class="line">用运行时异常来表明编程错误</span><br></pre></td></tr></table></figure>

<h2 id="9-3-避免滥用受检异常"><a href="#9-3-避免滥用受检异常" class="headerlink" title="9.3 避免滥用受检异常"></a>9.3 避免滥用受检异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用受检异常的两个前提：①正确使用API并不能阻止异常的产生 ②调用者可以采用有用的动作</span><br><span class="line">错误使用：将受检异常包装成运行时异常丢出去</span><br></pre></td></tr></table></figure>

<h2 id="9-4-优先使用标准的异常"><a href="#9-4-优先使用标准的异常" class="headerlink" title="9.4 优先使用标准的异常"></a>9.4 优先使用标准的异常</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IllegalArgumentException：非null的参数值不正确，例如需要正数却传递了负数</span><br><span class="line">IllegalStateException：不适合方法调用的对象状态</span><br><span class="line">UnsupportedOperationException：对象不支持用户请求的方法</span><br></pre></td></tr></table></figure>

<h2 id="9-5-抛出与抽象对应的异常"><a href="#9-5-抛出与抽象对应的异常" class="headerlink" title="9.5 抛出与抽象对应的异常"></a>9.5 抛出与抽象对应的异常</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常</span><br></pre></td></tr></table></figure>

<h1 id="10-并发"><a href="#10-并发" class="headerlink" title="10. 并发"></a>10. 并发</h1><h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><h1 id="11-序列化"><a href="#11-序列化" class="headerlink" title="11. 序列化"></a>11. 序列化</h1>]]></content>
      <tags>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>frp内网穿透工具使用指南(完善中)</title>
    <url>/2021/06/04/frp/</url>
    <content><![CDATA[<img src="/2021/06/04/frp/architecture.png" alt="architecture" style="zoom:80%;">

<a id="more"></a>



<h1 id="1-frp介绍"><a href="#1-frp介绍" class="headerlink" title="1. frp介绍"></a>1. frp介绍</h1><blockquote>
<p><em><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></em></p>
</blockquote>
<p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p>
<h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><ul>
<li><a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">$ wget https://github.com/fatedier/frp/releases/download/v0.37.0/frp_0.37.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">$ wget https://github.com/fatedier/frp/releases/download/v0.37.0/frp_0.37.0_windows_amd64.zip</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">$ tar -xzf frp_0.37.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>



<h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><h2 id="3-1-使用TCP暴露内网的服务"><a href="#3-1-使用TCP暴露内网的服务" class="headerlink" title="3.1 使用TCP暴露内网的服务"></a>3.1 使用TCP暴露内网的服务</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>一台拥有公网ip的服务器：运行frps，进行流量转发</li>
<li>一台能访问到服务器的内网机器：运行frpc，提供流量服务</li>
<li>访问端：访问公网服务器，并由frps将流量转发到frpc端，实现访问内网机器的功能</li>
</ul>
<h3 id="服务器端配置-假设ip地址为x-x-x-x"><a href="#服务器端配置-假设ip地址为x-x-x-x" class="headerlink" title="服务器端配置(假设ip地址为x.x.x.x)"></a>服务器端配置(假设<code>ip</code>地址为<code>x.x.x.x</code>)</h3><p>服务器开放7000端口监听来自客户端的连接</p>
<ul>
<li>frps.ini</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure>



<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./frps -c frps.ini</span><br></pre></td></tr></table></figure>



<h3 id="内网机器配置"><a href="#内网机器配置" class="headerlink" title="内网机器配置"></a>内网机器配置</h3><p>客户端连接到服务器的7000端口，然后将本地的4000端口的tcp服务映射到服务器的10010端口上，之后访问<code>服务器ip:10010</code>端口的流量都会被转发到<code>客户端:4000</code>端口上。</p>
<ul>
<li>frpc.ini（将本地4000端口的tcp服务映射到远程服务器的10010端口上）</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[hexo]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">4000</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">10010</span></span><br></pre></td></tr></table></figure>



<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ frpc.exe -c frps.ini</span><br></pre></td></tr></table></figure>



<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ul>
<li>使用浏览器打开  <code>x.x.x.x:10010</code> 即可访问内网 <code>4000</code> 端口的服务。</li>
</ul>
<h2 id="3-2-使用frp搭建点到点内网穿透，来访问windows远程桌面"><a href="#3-2-使用frp搭建点到点内网穿透，来访问windows远程桌面" class="headerlink" title="3.2 使用frp搭建点到点内网穿透，来访问windows远程桌面"></a>3.2 使用frp搭建点到点内网穿透，来访问windows远程桌面</h2><p>服务器起桥梁作用，帮助两台内网机器建立连接。</p>
<p>一旦建立链接，所有的流量只在两台内网机器之间传递（要求两台机器都运行frpc）</p>
<ul>
<li>具有公网ip的服务器</li>
<li>内网机器1：被访问</li>
<li>内网机器2：执行访问</li>
</ul>
<h3 id="服务器（桥梁）"><a href="#服务器（桥梁）" class="headerlink" title="服务器（桥梁）"></a>服务器（桥梁）</h3><ul>
<li>frps.ini</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7001</span></span><br></pre></td></tr></table></figure>



<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./frps -c frps.ini</span><br></pre></td></tr></table></figure>



<h3 id="内网机器1（被访问）"><a href="#内网机器1（被访问）" class="headerlink" title="内网机器1（被访问）"></a>内网机器1（被访问）</h3><ul>
<li>frpc.ini</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = xx.xx.xx.xx</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[p2p_rdp]</span></span><br><span class="line"><span class="attr">type</span> = xtcp</span><br><span class="line"><span class="comment">#SK跟访问者一致才能连通，可以自己随便设</span></span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="内网机器2（访问）"><a href="#内网机器2（访问）" class="headerlink" title="内网机器2（访问）"></a>内网机器2（访问）</h3><ul>
<li>frpc.ini</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[p2p_rdp_visitor]</span></span><br><span class="line"><span class="attr">type</span> = xtcp</span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="comment">#server_name同上面待其他设备访问的客户端中的配置[p2p_rdp]一致，待访问端和访问端中的p2p_rdp名字可以替换成自己想要的</span></span><br><span class="line"><span class="attr">server_name</span> = p2p_rdp</span><br><span class="line"><span class="comment">#SK跟访问者一致才能连通，可以自己随便设</span></span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">89</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>

<ul>
<li>访问</li>
</ul>
<p>访问127.0.0.1:89，然后127.0.0.1:89会将数据转发到远程服务器的3389端口建立rdp连接</p>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>network</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>git 的使用小技巧</title>
    <url>/2021/03/29/git-tips/</url>
    <content><![CDATA[<img src="/2021/03/29/git-tips/git.png" alt="git" style="zoom: 33%;">

<a id="more"></a>



<h1 id="1-分支管理"><a href="#1-分支管理" class="headerlink" title="1. 分支管理"></a>1. 分支管理</h1><ul>
<li><p><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
</li>
<li><p>干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
</li>
<li><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
</li>
<li><blockquote>
<p>功能（feature）分支</p>
<p>　　* 预发布（release）分支</p>
<p>　　* 修补bug（fixbug）分支</p>
</blockquote>
<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>
</li>
</ul>
<p><img src="/2021/03/29/git-tips/branch-manage.png" alt="image-20210329192800110"></p>
<h1 id="2-Git常用命令"><a href="#2-Git常用命令" class="headerlink" title="2. Git常用命令"></a>2. Git常用命令</h1><h2 id="2-1-分支切换"><a href="#2-1-分支切换" class="headerlink" title="2.1 分支切换"></a>2.1 分支切换</h2><h3 id="切换分支到某个提交记录"><a href="#切换分支到某个提交记录" class="headerlink" title="切换分支到某个提交记录"></a>切换分支到某个提交记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到指定的commit</span></span><br><span class="line">$ git branch -f main &lt;commit&gt;</span><br><span class="line"><span class="comment"># 切换到main的上一个commit</span></span><br><span class="line">$ git branch -f main main^4</span><br></pre></td></tr></table></figure>

<h3 id="回退分支"><a href="#回退分支" class="headerlink" title="回退分支"></a>回退分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将分支branch回退到上一个commit（对远程无效）</span></span><br><span class="line">$ git reset branch^1</span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销本次的commit（对远程有效）</span></span><br><span class="line">$ git revert branch</span><br></pre></td></tr></table></figure>

<h3 id="重置gitignore"><a href="#重置gitignore" class="headerlink" title="重置gitignore"></a>重置gitignore</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-分支拉取"><a href="#2-2-分支拉取" class="headerlink" title="2.2 分支拉取"></a>2.2 分支拉取</h2><h3 id="拉取远程仓库的分支"><a href="#拉取远程仓库的分支" class="headerlink" title="拉取远程仓库的分支"></a>拉取远程仓库的分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin [my-branch]</span><br><span class="line">$ git pull orgin [my-branch]</span><br></pre></td></tr></table></figure>



<h2 id="2-3-commit提交"><a href="#2-3-commit提交" class="headerlink" title="2.3 commit提交"></a>2.3 commit提交</h2><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一些提交复制到当前所在的位置（HEAD）下面</span></span><br><span class="line">$ git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure>



<h3 id="合并本地分支的commit"><a href="#合并本地分支的commit" class="headerlink" title="合并本地分支的commit"></a>合并本地分支的commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i head~5</span><br><span class="line"><span class="comment"># 然后将希望去掉的commit改为s</span></span><br></pre></td></tr></table></figure>



<h3 id="修改commit信息"><a href="#修改commit信息" class="headerlink" title="修改commit信息"></a>修改commit信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i head~5</span><br><span class="line"><span class="comment"># 然后将希望去掉的commit改为edit</span></span><br><span class="line">$ git commit --amend </span><br><span class="line"><span class="comment"># 修改提交信息</span></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>



<h3 id="推送本地分支到远程"><a href="#推送本地分支到远程" class="headerlink" title="推送本地分支到远程"></a>推送本地分支到远程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin  my-branch</span><br></pre></td></tr></table></figure>



<h3 id="仓库相关"><a href="#仓库相关" class="headerlink" title="仓库相关"></a>仓库相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# sparrow-rpc-framework&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:PancrasL/sparrow-rpc-framework.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>



<h1 id="3-规范"><a href="#3-规范" class="headerlink" title="3. 规范"></a>3. 规范</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docs: 文档相关</span><br><span class="line">feature: 新增feature</span><br><span class="line">bugfix: 修复bug</span><br><span class="line">optimize: 代码优化</span><br><span class="line">style: 仅仅是对格式进行修改，如逗号、缩进、空格等。不改变代码逻辑</span><br><span class="line">refactor: 代码重构，没有新增功能或修复bug</span><br><span class="line">test: 测试用例，包括单元测试、集成测试</span><br><span class="line">revert: 版本回滚</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Reference:</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言教程(完善中)</title>
    <url>/2021/07/19/golang/</url>
    <content><![CDATA[<img src="/2021/07/19/golang/bg.jpeg" alt="img" style="zoom: 25%;">

<a id="more"></a>

<h1 id="GoLang环境配置"><a href="#GoLang环境配置" class="headerlink" title="GoLang环境配置"></a>GoLang环境配置</h1><ul>
<li>go env -w：用户级别的环境变量<ul>
<li>windows: 用户\AppData\Roaming\go\env</li>
<li>linux: ~/.config/go/env</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore 模板</title>
    <url>/2021/04/01/gitignore/</url>
    <content><![CDATA[<p><img src="/2021/04/01/gitignore/bg.png" alt="1"></p>
<a id="more"></a>



<p><code> git</code> 项目的 <code>.gitignore</code> 文件模板</p>
<h1 id="Java项目"><a href="#Java项目" class="headerlink" title="Java项目"></a>Java项目</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Compiled class file</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># Log file</span></span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BlueJ files</span></span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mobile Tools for Java (J2ME)</span></span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Package Files #</span></span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"><span class="comment"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span></span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line"><span class="comment"># Eclipse IDE files</span></span><br><span class="line">**/.classpath</span><br><span class="line">**/.project</span><br><span class="line">**/.settings/</span><br><span class="line"></span><br><span class="line"><span class="comment"># intellij IDE files</span></span><br><span class="line">**/*.iml</span><br><span class="line">**/.idea/</span><br><span class="line">**/*.<span class="built_in">log</span></span><br><span class="line">**/*.ipr</span><br><span class="line">**/*.iws</span><br><span class="line"></span><br><span class="line"><span class="comment"># vscode files</span></span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line"><span class="comment"># target files</span></span><br><span class="line">**/target/*</span><br></pre></td></tr></table></figure>



<h1 id="Go项目"><a href="#Go项目" class="headerlink" title="Go项目"></a>Go项目</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Binaries for programs and plugins</span></span><br><span class="line">*.exe</span><br><span class="line">*.exe~</span><br><span class="line">*.dll</span><br><span class="line">*.so</span><br><span class="line">*.dylib</span><br><span class="line">*.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Test binary, build with `go test -c`</span></span><br><span class="line">*.<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output of the go coverage tool, specifically when used with LiteIDE</span></span><br><span class="line">*.out</span><br><span class="line">coverage.txt</span><br><span class="line"></span><br><span class="line">*.idea</span><br><span class="line">*.iml</span><br><span class="line">target/</span><br><span class="line">classes</span><br><span class="line"></span><br><span class="line"><span class="comment"># go mod, go test</span></span><br><span class="line">vendor/</span><br><span class="line">logs/</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line"><span class="comment"># unit test</span></span><br><span class="line">remoting/zookeeper/zookeeper-4unittest/</span><br><span class="line">config_center/zookeeper/zookeeper-4unittest/</span><br><span class="line">registry/zookeeper/zookeeper-4unittest/</span><br><span class="line">metadata/report/zookeeper/zookeeper-4unittest/</span><br><span class="line">registry/consul/agent*</span><br><span class="line">metadata/report/consul/agent*</span><br><span class="line">remoting/consul/agent*</span><br><span class="line">config_center/apollo/mockDubbog.properties.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim stuff</span></span><br><span class="line">*~</span><br><span class="line">.*.sw?</span><br><span class="line">/license-header-checker-linux/</span><br><span class="line">/license-header-checker-linux.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure>



<h1 id="C-项目"><a href="#C-项目" class="headerlink" title="C++项目"></a>C++项目</h1>]]></content>
      <tags>
        <tag>all</tag>
        <tag>git</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>单机环境的 Hadoop 平台部署</title>
    <url>/2021/01/11/hadoop-deploy/</url>
    <content><![CDATA[<img src="/2021/01/11/hadoop-deploy/hadoop.png" alt="Hadoop" style="zoom: 33%;">

<a id="more"></a>



<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>高级操作系统课程实验之一是部署单机Hadoop，记录一下搭建过程。</p>
<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul>
<li>ubuntu18.04</li>
<li>以root用户操作</li>
</ul>
<h2 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h2><ul>
<li>确保安装了ssh服务</li>
<li>关闭了ubuntu防火墙（云服务器需要配置安全组，放行端口）</li>
</ul>
<h2 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostnamectl <span class="built_in">set</span>-hostname master</span><br><span class="line">$ vi /etc/hosts</span><br><span class="line"><span class="comment">#添加本地dns映射</span></span><br><span class="line">...</span><br><span class="line">你的ip	master</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h1 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h1><ul>
<li>安装java</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt update</span><br><span class="line">$ apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>



<ul>
<li>添加环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/profile</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>



<ul>
<li>查看是否安装成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_275&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_275-8u275-b01-0ubuntu1~18.04-b01)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.275-b01, mixed mode)</span><br></pre></td></tr></table></figure>



<h1 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><h2 id="准备Hadoop安装包"><a href="#准备Hadoop安装包" class="headerlink" title="准备Hadoop安装包"></a>准备Hadoop安装包</h2><ul>
<li>下载hadoop2.x压缩包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ wget https://mirrors.aliyun.com/apache/hadoop/common/hadoop-2.10.1/hadoop-2.10.1.tar.gz</span><br></pre></td></tr></table></figure>



<ul>
<li>解压缩</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -xzf hadoop-2.10.1.tar.gz</span><br><span class="line">$ ls</span><br><span class="line">hadoop-2.10.1  hadoop-2.10.1.tar.gz</span><br></pre></td></tr></table></figure>



<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><ul>
<li>进入 <code>hadoop-2.10.1/etc/hadoop</code> 文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /root/hadoop-2.10.1/etc/hadoop</span><br><span class="line">$ ls</span><br><span class="line">capacity-scheduler.xml      httpfs-env.sh            mapred-env.sh</span><br><span class="line">configuration.xsl           httpfs-log4j.properties  mapred-queues.xml.template</span><br><span class="line">container-executor.cfg      httpfs-signature.secret  mapred-site.xml.template</span><br><span class="line">core-site.xml               httpfs-site.xml          slaves</span><br><span class="line">hadoop-env.cmd              kms-acls.xml             ssl-client.xml.example</span><br><span class="line">hadoop-env.sh               kms-env.sh               ssl-server.xml.example</span><br><span class="line">hadoop-metrics2.properties  kms-log4j.properties     yarn-env.cmd</span><br><span class="line">hadoop-metrics.properties   kms-site.xml             yarn-env.sh</span><br><span class="line">hadoop-policy.xml           log4j.properties         yarn-site.xml</span><br><span class="line">hdfs-site.xml               mapred-env.cmd</span><br></pre></td></tr></table></figure>



<ul>
<li>修改hadoop-env.sh</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi hadoop-env.sh</span><br><span class="line"><span class="comment"># 修改JAVA_HOME字段</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<ul>
<li>修改core-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>修改hdfs-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/nn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.checkpoint.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/snn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.checkpoint.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/snn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/dn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>修改mapred-site.xml(从模板创建：cp mapred-site.xml.template mapred-site.xml )</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>修改yarn-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定resourcemanager的地址 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定reducer获取数据的方式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.local-dirs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/yarn/nm<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>修改slaves</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi slaves</span><br><span class="line">master</span><br></pre></td></tr></table></figure>



<ul>
<li>创建相关文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /tmp/hadoop</span><br><span class="line">$ mkdir -p /data/hadoop/hdfs/nn</span><br><span class="line">$ mkdir -p /data/hadoop/hdfs/dn</span><br><span class="line">$ mkdir -p /data/hadoop/hdfs/snn</span><br><span class="line">$ mkdir -p /data/hadoop/hdfs/nm</span><br></pre></td></tr></table></figure>



<ul>
<li>配置Hadoop环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/profile</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/root/hadoop-2.10.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>



<h2 id="安装Hadoop-1"><a href="#安装Hadoop-1" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h2><ul>
<li>格式化namenode</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hdfs namenode -format</span><br><span class="line">...</span><br><span class="line">21/01/10 14:38:44 INFO common.Storage: Storage directory /data/hadoop/hdfs/nn has been successfully formatted.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<ul>
<li>启动Hadoop</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ start-dfs.sh</span><br><span class="line">Starting namenodes on [master]</span><br><span class="line">The authenticity of host <span class="string">&#x27;master (172.17.212.17)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:aOcOvEQXhyzfs4i5vOBoM2raFUt7tqCo22B5zCS4Tto.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">master: Warning: Permanently added &#x27;</span>master,172.17.212.17<span class="string">&#x27; (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">root@master&#x27;</span>s password:</span><br><span class="line">master: starting namenode, logging to /root/hadoop-2.10.1/logs/hadoop-root-namenode-master.out</span><br><span class="line">root@master<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">master: starting datanode, logging to /root/hadoop-2.10.1/logs/hadoop-root-datanode-master.out</span></span><br><span class="line"><span class="string">Starting secondary namenodes [0.0.0.0]</span></span><br><span class="line"><span class="string">The authenticity of host &#x27;</span>0.0.0.0 (0.0.0.0)<span class="string">&#x27; can&#x27;</span>t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:aOcOvEQXhyzfs4i5vOBoM2raFUt7tqCo22B5zCS4Tto.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)? yes</span><br><span class="line">0.0.0.0: Warning: Permanently added <span class="string">&#x27;0.0.0.0&#x27;</span> (ECDSA) to the list of known hosts.</span><br><span class="line">root@0.0.0.0<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">0.0.0.0: starting secondarynamenode, logging to /root/hadoop-2.10.1/logs/hadoop-root-secondarynamenode-master.out</span></span><br></pre></td></tr></table></figure>



<ul>
<li>启动Yarn</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ start-yarn.sh</span><br><span class="line">starting yarn daemons</span><br><span class="line">starting resourcemanager, logging to /root/hadoop-2.10.1/logs/yarn-root-resourcemanager-master.out</span><br><span class="line">root@master<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">master: starting nodemanager, logging to /root/hadoop-2.10.1/logs/yarn-root-nodemanager-master.out</span></span><br></pre></td></tr></table></figure>



<ul>
<li>查看是否启动成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jps</span><br><span class="line">20771 NodeManager</span><br><span class="line">21557 Jps</span><br><span class="line">19784 NameNode</span><br><span class="line">20233 SecondaryNameNode</span><br><span class="line">19979 DataNode</span><br><span class="line">20620 ResourceManager</span><br></pre></td></tr></table></figure>



<ul>
<li>访问服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDFS：http:&#x2F;&#x2F;ip:50070</span><br><span class="line">YARN：http:&#x2F;&#x2F;ip:8088</span><br></pre></td></tr></table></figure>



<h1 id="运行Hadoop程序"><a href="#运行Hadoop程序" class="headerlink" title="运行Hadoop程序"></a>运行Hadoop程序</h1><h2 id="上传文件到Hadoop集群"><a href="#上传文件到Hadoop集群" class="headerlink" title="上传文件到Hadoop集群"></a>上传文件到Hadoop集群</h2><ul>
<li>上传文件  hadoop-2.10.1.tar.gz 到Hadoop集群</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">hadoop-2.10.1  hadoop-2.10.1.tar.gz</span><br><span class="line">$ hadoop fs -put hadoop-2.10.1.tar.gz hdfs://master:9000/</span><br></pre></td></tr></table></figure>



<ul>
<li>登录 <a href="http://ip:50070/">http://ip:50070</a> 查看Datanodes</li>
</ul>
<p><img src="/2021/01/11/hadoop-deploy/datanodes.png" alt="image-20210110145747220"></p>
<ul>
<li>登录 <a href="http://ip:50070/explorer.html">http://ip:50070/explorer.html</a> 查看上传的文件</li>
</ul>
<p><img src="/2021/01/11/hadoop-deploy/hdfsfiles.png" alt="image-20210110150132629"></p>
<h2 id="计算圆周率"><a href="#计算圆周率" class="headerlink" title="计算圆周率"></a>计算圆周率</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/hadoop-2.10.1/share/hadoop/mapreduce/</span><br><span class="line">$ hadoop jar hadoop-mapreduce-examples-2.10.1.jar pi 5 5</span><br><span class="line">...</span><br><span class="line">Estimated value of Pi is 3.68000000000000000000</span><br></pre></td></tr></table></figure>



<h2 id="单词计数"><a href="#单词计数" class="headerlink" title="单词计数"></a>单词计数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建源文件并上传到HDFS</span></span><br><span class="line">$ cat &gt;&gt; words.txt &lt;&lt;EOF</span><br><span class="line">hello hello hello</span><br><span class="line">good good</span><br><span class="line">welcome to hadoop, nice to meet you.</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在HDFS中创建文件夹</span></span><br><span class="line">$ hadoop fs -mkdir /wordcount</span><br><span class="line">$ hadoop fs -mkdir /wordcount/input</span><br><span class="line">$ hadoop fs -put words.txt /wordcount/input</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行单词计数程序</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/hadoop-2.10.1/share/hadoop/mapreduce/</span><br><span class="line">$ hadoop jar hadoop-mapreduce-examples-2.10.1.jar wordcount /wordcount/input /wordcount/output</span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">$ hadoop fs -ls /wordcount/output</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   1 root supergroup          0 2021-01-10 15:17 /wordcount/output/_SUCCESS</span><br><span class="line">-rw-r--r--   1 root supergroup         61 2021-01-10 15:17 /wordcount/output/part-r-00000</span><br><span class="line">$ hadoop fs -cat /wordcount/output/part-r-00000</span><br><span class="line">good    2</span><br><span class="line">hadoop, 1</span><br><span class="line">hello   3</span><br><span class="line">meet    1</span><br><span class="line">nice    1</span><br><span class="line">to      2</span><br><span class="line">welcome 1</span><br><span class="line">you.    1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Hexo博客</title>
    <url>/2020/03/21/hexo-blog/</url>
    <content><![CDATA[<img src="/2020/03/21/hexo-blog/hexo.png" alt="image-20210519151838056" style="zoom: 50%;">

<a id="more"></a>



<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul>
<li><a href="https://nodejs.org/zh-cn/">node.js</a></li>
<li><a href="https://git-scm.com/">git</a></li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li><p>安装 <code>node.js</code></p>
</li>
<li><p>安装 <code>git</code></p>
</li>
<li><p>创建并进入到 <code>blog</code> 文件夹，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加本地图片</p>
<ul>
<li><p>修改 <code>_config.yml</code> 中 <strong>post_asset_folder</strong> 属性为true</p>
</li>
<li><pre><code class="bash"># 下载hexo-asset-image插件
$ npm install https://github.com/CodeFalling/hexo-asset-image --save
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 部署</span><br><span class="line"></span><br><span class="line">+ 生成博客静态界面</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>部署到gitee pages</p>
<ul>
<li>创建gitee仓库</li>
<li>进入仓库，选择 <strong>服务 –&gt; gitee pages</strong></li>
<li>配置ssh密钥</li>
<li>修改配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改blog目录下的_config.yml，添加如下内容</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:PancrasL/PancrasL.gitee.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Next主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#For Hexo 5.0 or later</span></span><br><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>修改Next主题字体大小</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next\source\css\_variables\base.styl</span></span><br><span class="line"><span class="comment">// 将1em修改为0.95em</span></span><br><span class="line">$font-size-base = (hexo-config(&#x27;font.enable&#x27;) and hexo-config(&#x27;font.global.size&#x27;) is a &#x27;unit&#x27;) ? unit(hexo-config(&#x27;font.global.size&#x27;), em) : 0.95em;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li>新建页面</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>发布草稿</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>重新生成服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>



<ul>
<li>在本地启动博客系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python批量压缩图片</title>
    <url>/2021/06/04/image-compression/</url>
    <content><![CDATA[<img src="/2021/06/04/image-compression/wallhaven-457wx9.jpg" alt="General 1920x1080 cats blue eyes animals boxes Ben Torode wooden surface mammals carton box indoors looking at viewer" style="zoom: 33%;">



<a id="more"></a>



<h1 id="1-依赖安装"><a href="#1-依赖安装" class="headerlink" title="1. 依赖安装"></a>1. 依赖安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip3 install pillow</span><br></pre></td></tr></table></figure>



<h1 id="2-图片压缩"><a href="#2-图片压缩" class="headerlink" title="2. 图片压缩"></a>2. 图片压缩</h1><h2 id="2-1-PIL库图片插值的四种模式"><a href="#2-1-PIL库图片插值的四种模式" class="headerlink" title="2.1 PIL库图片插值的四种模式"></a>2.1 PIL库图片插值的四种模式</h2><h3 id="Nearest-最近相邻插值算法-最近邻法）"><a href="#Nearest-最近相邻插值算法-最近邻法）" class="headerlink" title="Nearest (最近相邻插值算法/最近邻法）"></a>Nearest (最近相邻插值算法/最近邻法）</h3><ul>
<li>特点：缺少的像素通过直接使用与之最接近的原有像素的颜色生成，也就是照搬旁边的像素。</li>
<li>优点：速度快。</li>
<li>缺点：精度低，有明显的锯齿感。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.thumbnail((w,h), Image.NEAREST)</span><br></pre></td></tr></table></figure>



<h3 id="Bilinear（两次线性插值算法-双线性内插法）"><a href="#Bilinear（两次线性插值算法-双线性内插法）" class="headerlink" title="Bilinear（两次线性插值算法/双线性内插法）"></a>Bilinear（两次线性插值算法/双线性内插法）</h3><ul>
<li>特点：通过平均周围像素颜色来添加像素的方法。</li>
<li>优点：消除了锯齿现象，效果中等。</li>
<li>缺点：效果中等。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.thumbnail((w,h), Image.BILINEAR)</span><br></pre></td></tr></table></figure>



<h3 id="Bicubic（两次立方插值算法-立方卷积法）"><a href="#Bicubic（两次立方插值算法-立方卷积法）" class="headerlink" title="Bicubic（两次立方插值算法/立方卷积法）"></a>Bicubic（两次立方插值算法/立方卷积法）</h3><ul>
<li>特点：Bilinear的改进版，不仅考虑到四个直接邻点灰度值的影响，还考虑到各邻点间灰度值变化率的影响。</li>
<li>优点：计算精度很高，处理后图像像质损失较小。</li>
<li>缺点：速度慢。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.thumbnail((w,h), Image.BICUBIC)</span><br></pre></td></tr></table></figure>



<h3 id="Antialias（Lanczos算法）"><a href="#Antialias（Lanczos算法）" class="headerlink" title="Antialias（Lanczos算法）"></a>Antialias（Lanczos算法）</h3><ul>
<li>特点：几个简单过滤器中的最佳折中方案。</li>
<li>优点：<code>Antialias</code>比<code>Bicubic</code>的速度要快。</li>
<li>缺点：没有<code>Bicubic</code>清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.thumbnail((w,h), Image.LANCZOS)</span><br></pre></td></tr></table></figure>



<h2 id="2-2-Image-resize-和-Image-thumbnail"><a href="#2-2-Image-resize-和-Image-thumbnail" class="headerlink" title="2.2 Image.resize() 和 Image.thumbnail()"></a>2.2 <code>Image.resize()</code> 和 <code>Image.thumbnail()</code></h2><ul>
<li><code>resize()</code>：将图片尺寸修改为<code>size</code>。</li>
<li><code>thumbnail()</code>：如果图像原尺寸大于<code>size</code>，则在保留宽高比的前提下缩小为<code>size</code>；如果图像原尺寸大于<code>size</code>，则尺寸不变。</li>
</ul>
<h2 id="2-3-代码流程图"><a href="#2-3-代码流程图" class="headerlink" title="2.3 代码流程图"></a>2.3 代码流程图</h2><p><img src="/2021/06/04/image-compression/image-20210604203014721.png" alt="image-20210604203014721"></p>
<h2 id="2-3-压缩代码"><a href="#2-3-压缩代码" class="headerlink" title="2.3 压缩代码"></a>2.3 压缩代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">dir = <span class="string">&#x27;E:\\Album Test\\test\\&#x27;</span></span><br><span class="line">patterns = [<span class="string">&#x27;*.jpg&#x27;</span>, <span class="string">&quot;*.png&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compressImage</span>():</span></span><br><span class="line">    files = collectFiles(dir, patterns)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        img = doCompress(f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在同级目录下的compress目录，用于存放压缩后的图片</span></span><br><span class="line">        compress_dir = <span class="string">&quot;%s/compress/&quot;</span> % os.path.dirname(f)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(compress_dir):</span><br><span class="line">            os.makedirs(compress_dir)</span><br><span class="line">        new_fname = os.path.join(compress_dir, os.path.basename(f))</span><br><span class="line">        </span><br><span class="line">        saveImg(img, new_fname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectFiles</span>(<span class="params">dir, patterns</span>):</span></span><br><span class="line">    <span class="comment"># 获取图片文件全路径</span></span><br><span class="line">    files = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> patterns:</span><br><span class="line">        files += (glob.glob(<span class="string">&#x27;%s%s%s&#x27;</span> % (dir, <span class="string">&#x27;**\\&#x27;</span>, p), recursive=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换win路径为linux路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(files)):</span><br><span class="line">        files[i] = files[i].replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doCompress</span>(<span class="params">filename</span>):</span></span><br><span class="line">    sImg = Image.open(filename)</span><br><span class="line">    w, h = sImg.size</span><br><span class="line"></span><br><span class="line">    sImg.thumbnail((w,h), Image.BICUBIC)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sImg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveImg</span>(<span class="params">img, filename</span>):</span></span><br><span class="line">    img.save(filename)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    compressImage()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-4-压缩代码（通过读取图片旋转信息避免图片压缩后被旋转）"><a href="#2-4-压缩代码（通过读取图片旋转信息避免图片压缩后被旋转）" class="headerlink" title="2.4 压缩代码（通过读取图片旋转信息避免图片压缩后被旋转）"></a>2.4 压缩代码（通过读取图片旋转信息避免图片压缩后被旋转）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ExifTags</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">dir = <span class="string">&#x27;E:/Album Test/public/&#x27;</span></span><br><span class="line">patterns = [<span class="string">&#x27;*.jpg&#x27;</span>, <span class="string">&quot;*.png&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compressImage</span>():</span></span><br><span class="line">    files = collectFiles(dir, patterns)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        img = doCompress(f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 将压缩后的图片存放在同级目录下的compress文件夹下</span></span><br><span class="line">        <span class="comment"># compress_dir = &quot;%s/compress/&quot; % os.path.dirname(f)</span></span><br><span class="line">        <span class="comment"># if not os.path.exists(compress_dir):</span></span><br><span class="line">        <span class="comment">#     os.makedirs(compress_dir)</span></span><br><span class="line">        <span class="comment"># new_fname = os.path.join(compress_dir, os.path.basename(f))</span></span><br><span class="line">        saveImg(img, f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collectFiles</span>(<span class="params">dir, patterns</span>):</span></span><br><span class="line">    <span class="comment"># 获取图片文件全路径</span></span><br><span class="line">    files = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> patterns:</span><br><span class="line">        files += (glob.glob(<span class="string">&#x27;%s%s%s&#x27;</span> % (dir, <span class="string">&#x27;**\\&#x27;</span>, p), recursive=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换win路径为linux路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(files)):</span><br><span class="line">        files[i] = files[i].replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doCompress</span>(<span class="params">filename</span>):</span></span><br><span class="line">    img = Image.open(filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到图像旋转信息 exif: Exchangeable image file format</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> ExifTags.TAGS.keys():</span><br><span class="line">        <span class="keyword">if</span>(ExifTags.TAGS[k] == <span class="string">&#x27;Orientation&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> hasattr(img, <span class="string">&#x27;_getexif&#x27;</span>) <span class="keyword">and</span> hasattr(img._getexif(), <span class="string">&#x27;items&#x27;</span>):</span><br><span class="line">                exif = dict(img._getexif().items())</span><br><span class="line">                <span class="keyword">if</span> exif[k] == <span class="number">3</span>:</span><br><span class="line">                    img = img.rotate(<span class="number">180</span>, expand=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">elif</span> exif[k] == <span class="number">6</span>:</span><br><span class="line">                    img = img.rotate(<span class="number">270</span>, expand=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">elif</span> exif[k] == <span class="number">8</span>:</span><br><span class="line">                    img = img.rotate(<span class="number">90</span>, expand=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 旋转</span></span><br><span class="line">    w, h = img.size</span><br><span class="line">    <span class="comment">#sImg.thumbnail((w,h), Image.BICUBIC)</span></span><br><span class="line">    img.thumbnail((<span class="number">2000</span>, <span class="number">1500</span>), Image.BICUBIC)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveImg</span>(<span class="params">img, filename</span>):</span></span><br><span class="line">    img.save(filename)</span><br><span class="line">    print(filename, <span class="string">&quot;压缩成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    compressImage()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
        <tag>python</tag>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊IO通信模型</title>
    <url>/2021/11/24/io-model/</url>
    <content><![CDATA[<img src="/2021/11/24/io-model/www.mdtic.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img" style="zoom: 67%;">

<a id="more"></a>

<h1 id="1-阻塞、非阻塞、同步、异步究竟是什么？"><a href="#1-阻塞、非阻塞、同步、异步究竟是什么？" class="headerlink" title="1. 阻塞、非阻塞、同步、异步究竟是什么？"></a>1. 阻塞、非阻塞、同步、异步究竟是什么？</h1><p>实际开发过程中，我们经常听到这些概念，但是网上的文章很少能清晰说明它们的区别，如果没有系统梳理过，很容易把这些概念搞混。</p>
<p>其实，这四个术语可以分成两对：</p>
<ul>
<li>阻塞和非阻塞</li>
<li>同步和异步</li>
</ul>
<p>它们之间两两组合可以拼凑出4种组合：</p>
<ul>
<li>同步阻塞</li>
<li>同步非阻塞</li>
<li>异步阻塞</li>
<li>异步非阻塞</li>
</ul>
<p>要搞清楚这些组合术语的意思，我们首先需要搞清楚同步和异步、阻塞和非阻塞的基本概念。</p>
<blockquote>
<p> 前提知识：首在我们的现代操作系统中，分为用户空间和内核空间，用户空间的应用程序（称为A）发起IO请求，内核空间的驱动程序（称为B）响应IO请求，<strong>应用程序A</strong>称为<strong>调用者</strong>，<strong>驱动程序B</strong>称为<strong>被调用者</strong></p>
</blockquote>
<h2 id="1-1-同步和异步是看结果获取的方式"><a href="#1-1-同步和异步是看结果获取的方式" class="headerlink" title="1.1 同步和异步是看结果获取的方式"></a>1.1 同步和异步是看结果获取的方式</h2><p>同步：A发起调用请求后，多次问询B来获取数据。</p>
<p>异步：A发起调用请求后，等待B主动通知返回数据。</p>
<img src="/2021/11/24/io-model/同步和异步.png" alt="同步和异步" style="zoom:80%;">

<h2 id="1-2-阻塞和非阻塞是看发起调用后，当前线程是挂起还是运行"><a href="#1-2-阻塞和非阻塞是看发起调用后，当前线程是挂起还是运行" class="headerlink" title="1.2 阻塞和非阻塞是看发起调用后，当前线程是挂起还是运行"></a>1.2 阻塞和非阻塞是看发起调用后，当前线程是挂起还是运行</h2><p>阻塞：A发起调用后，当前线程被挂起，在收到调用结果后，才会继续执行。</p>
<p>非阻塞：A发起调用后，立即得到调用结果，但是该结果可能是一个error，需要重新进行问询。</p>
<img src="/2021/11/24/io-model/阻塞和非阻塞.png" alt="阻塞和非阻塞" style="zoom:80%;">

<h2 id="1-3-组合概念——以照相馆为例"><a href="#1-3-组合概念——以照相馆为例" class="headerlink" title="1.3 组合概念——以照相馆为例"></a>1.3 组合概念——以照相馆为例</h2><p>去照相馆拍照的例子，洗照片需要30min：</p>
<p><strong>同步阻塞</strong>：一直在照相馆等待，每过1min去问一下老板洗好了没有。</p>
<p><strong>同步非阻塞</strong>：刷手机（去做别的事情），每过1min去问一下老板洗好了没有。</p>
<p><strong>异步阻塞</strong>：一直在照相馆等待，直到老板通知你照片洗好了。</p>
<p><strong>异步非阻塞</strong>：刷手机（去做别的事情），直到老板通知你照片洗好了。</p>
<ul>
<li><strong>同步阻塞</strong></li>
</ul>
<p>应用程序调用IO函数后，线程被挂起，等待在该函数返回数据，同时，该函数不断问询内核来获取数据</p>
<ul>
<li><strong>同步非阻塞</strong></li>
</ul>
<p>应用程序调用IO函数后，该函数立即返回执行结果，但结果可能是一个error，此时应用程序可以执行其他任务，但是需要时不时看一下结果是否已经准备好了</p>
<ul>
<li><strong>异步阻塞</strong></li>
</ul>
<p>应用程序调用IO函数后，线程被挂起，一直等待该函数返回结果。</p>
<ul>
<li><strong>异步非阻塞</strong></li>
</ul>
<p>应用程序调用IO函数后，线程可以先去干其他事情，等到内核通知线程数据已经准备好了，然后再去进行处理。</p>
<h1 id="2-Linux系统中的五种IO模型"><a href="#2-Linux系统中的五种IO模型" class="headerlink" title="2. Linux系统中的五种IO模型"></a>2. Linux系统中的五种IO模型</h1><p>介绍完了基本概念，接下来我们要探究一下Linux系统发展出的5种IO模型，它们分别是：</p>
<ul>
<li>阻塞I/O模型（同步阻塞类型）</li>
<li>非阻塞I/O模型（同步非阻塞类型）</li>
<li>多路复用I/O模型（同步阻塞类型的改进版）</li>
<li>信号驱动I/O模型（同步非阻塞类型的改进版）</li>
<li>异步I/O模型（异步非阻塞类型）</li>
</ul>
<p>其中，前4种属于同步I/O，第5种属于异步I/O.</p>
<blockquote>
<p>前提知识：在现代操作系统中，当应用程序向内核发起IO请求后，IO交互可以分为两个阶段：<br>（1）等待数据：等待数据到达外部设备（如网卡、磁盘等），然后将数据读取到内核空间<br>（2）拷贝数据：将数据从内核空间拷贝到用户空间</p>
</blockquote>
<h2 id="2-1-阻塞I-O模型（同步阻塞）"><a href="#2-1-阻塞I-O模型（同步阻塞）" class="headerlink" title="2.1 阻塞I/O模型（同步阻塞）"></a>2.1 阻塞I/O模型（同步阻塞）</h2><p>用户线程调用<code>recvfrom</code>系统调用后会被内核阻塞，直到数据被拷贝到用户空间。</p>
<p>内核收到系统调用后，开始准备数据，将数据从外部设备拷贝到内核空间，若数据未到达，内核也会阻塞等待。</p>
<table>
<thead>
<tr>
<th align="left">特点</th>
<th>在I/O执行的两个阶段（等待数据和拷贝数据）都被阻塞</th>
</tr>
</thead>
<tbody><tr>
<td align="left">典型应用</td>
<td>阻塞Socket、Java BIO</td>
</tr>
<tr>
<td align="left">优点</td>
<td>（1）线程被挂起，不消耗CPU资源 （2）实现难度低 （3）适合并发量小的网络应用</td>
</tr>
<tr>
<td align="left">缺点</td>
<td>（1）需要为每个请求分配一个线程，开销大 （2）不适合并发量大的应用</td>
</tr>
</tbody></table>
<img src="/2021/11/24/io-model/阻塞IO模型.jpg" alt="阻塞IO模型" style="zoom: 33%;">



<h2 id="2-2-非阻塞I-O模型（同步非阻塞）"><a href="#2-2-非阻塞I-O模型（同步非阻塞）" class="headerlink" title="2.2 非阻塞I/O模型（同步非阻塞）"></a>2.2 非阻塞I/O模型（同步非阻塞）</h2><p>用户线程发出read请求后，如果内核中的数据还没有准备好，它并不会阻塞用户线程，而是返回一个error，从用户线程角度看，它发起read后不需要等待，可以立即得到执行结果，并对结果进行判断，如果是一个error，它就直到结果没有准备好，可以重新发送read操作，一旦内核中的数据准备好了，并再次收到了用户线程的系统调用，那么它会将数据拷贝到用户内存，然后返回。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>用户线程需要不断地主动询问内核数据准备好了没有</th>
</tr>
</thead>
<tbody><tr>
<td>典型应用</td>
<td>Socket设置为NON_BLOCK</td>
</tr>
<tr>
<td>优点</td>
<td>实现难度低，相对阻塞IO较难</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）线程多次问询，消耗CPU资源</td>
</tr>
</tbody></table>
<img src="/2021/11/24/io-model/非阻塞IO模型.jpg" alt="非阻塞IO模型" style="zoom: 25%;">



<h2 id="2-3-多路复用I-O模型（同步阻塞的改进版）"><a href="#2-3-多路复用I-O模型（同步阻塞的改进版）" class="headerlink" title="2.3 多路复用I/O模型（同步阻塞的改进版）"></a>2.3 多路复用I/O模型（同步阻塞的改进版）</h2><p>多个线程的I/O可以注册到一个复用器（Selector）上，Selector线程不断轮询多个Socket的状态，只有当真正的Socket有读写事件时，才会执行IO操作，仅需一个线程就可以管理多个Socket，不必为每个Socket维护一个线程，大大减少了资源占用，同时，Selector的轮询是在内核中进行的，减少了有用户线程轮询所产生的系统调用开销。</p>
<p>select被调用后，线程会被阻塞，内核监视所有select负责的socket，当有任何一个socket的数据准备好了，select就会返回套接字可读，我们就可以调用recvfrom处理数据。</p>
<p><img src="/2021/11/24/io-model/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%A8%A1%E5%9E%8B.jpg" alt="多路复用IO模型"></p>
<table>
<thead>
<tr>
<th>特点</th>
<th>对于每一个Socket，一般都设置成非阻塞，但是整个用户的线程一直被阻塞，只不过是被select函数所阻塞，而不是被Socket I/O阻塞</th>
</tr>
</thead>
<tbody><tr>
<td>典型应用</td>
<td>Java NIO，epoll，poll，select</td>
</tr>
<tr>
<td>优点</td>
<td>（1）一个线程可以管理多个Socket连接，性能好，Reactor模式（2）适合高并发服务开发，一个线程响应多个请求</td>
</tr>
<tr>
<td>缺点</td>
<td>开发难度大</td>
</tr>
</tbody></table>
<h3 id="2-3-1-select、epoll、poll"><a href="#2-3-1-select、epoll、poll" class="headerlink" title="2.3.1 select、epoll、poll"></a>2.3.1 select、epoll、poll</h3><blockquote>
<p>Unix系统下多路复用IO模型的三种实现</p>
<p>(1)select </p>
<p>知道有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<p>(2)poll</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.</p>
<p>(3)epoll</p>
<p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。  </p>
<p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。</p>
<p><a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610">(38条消息) 深入理解select、poll和epoll及区别_$好记性还是要多记录$-CSDN博客</a></p>
</blockquote>
<h3 id="2-3-2-Reactor设计模式"><a href="#2-3-2-Reactor设计模式" class="headerlink" title="2.3.2 Reactor设计模式"></a>2.3.2 Reactor设计模式</h3><p>虽然多路复用I/O模型允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长，为了解决这一问题，引入了Reactor设计模式，Java NIO就采用了此方法。</p>
<h2 id="2-4-信号驱动I-O模型（同步非阻塞的改进版）"><a href="#2-4-信号驱动I-O模型（同步非阻塞的改进版）" class="headerlink" title="2.4 信号驱动I/O模型（同步非阻塞的改进版）"></a>2.4 信号驱动I/O模型（同步非阻塞的改进版）</h2><p>线程预先告知内核，向内核注册一个信号处理函数，然后用户线程返回不阻塞，当内核数据就绪时会发送一个信号给线程，用户线程便在信号处理函数中调用IO读取数据。</p>
<p>实际上，信号驱动I/O模型并没有实现真正的异步，因为将数据从内核拷贝到用户空间的过程仍然是阻塞的，需要由用户线程来完成IO操作。</p>
<p><img src="/2021/11/24/io-model/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.jpg" alt="信号驱动IO模型"></p>
<h2 id="2-5-异步I-O模型（异步非阻塞）"><a href="#2-5-异步I-O模型（异步非阻塞）" class="headerlink" title="2.5 异步I/O模型（异步非阻塞）"></a>2.5 异步I/O模型（异步非阻塞）</h2><p>用户线程发起aio_read后可以去做其他事情。</p>
<p>内核收到aio_read后立即返回，待数据准备好后会将数据拷贝到用户空间，然后告诉用户线程数据准备好了，用户线程可以直接对数据进行处理。和信号驱动IO模型的区别是：信号驱动IO模型是由内核告诉我们何时可以启动一个IO操作，这个IO操作由用户自定义的信号函数来实现，而异步IO模型由内核告诉我们IO操作何时完成。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>真正实现了异步IO，是五种IO模型中唯一的异步模型</th>
</tr>
</thead>
<tbody><tr>
<td>典型应用</td>
<td>Java7 AIO</td>
</tr>
<tr>
<td>优点</td>
<td>（1）不阻塞，数据一步到位（2）适合高性能、高并发应用</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）需要操作系统底层支持，Linux 2.5内核首次实现（2）开发难度大</td>
</tr>
</tbody></table>
<p><img src="/2021/11/24/io-model/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B-1637735044420.jpg" alt="异步IO模型"></p>
<h1 id="3-Java中的IO方式"><a href="#3-Java中的IO方式" class="headerlink" title="3. Java中的IO方式"></a>3. Java中的IO方式</h1><p><strong>BIO (Blocking I/O)</strong>: 同步阻塞 I/O 模式，数据的读取写⼊必须阻塞在⼀个线程内等待其完 成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐较不错的，可以让每 ⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。线 程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当⾯对⼗万甚 ⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼效的 I/O 处理 模型来应对更⾼的并发量。 </p>
<p><strong>NIO (Non-blocking/New I/O)</strong>: NIO 是⼀种同步⾮阻塞的 I/O 模型，在 Java 1.4 中引⼊了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可 以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I/O 操作⽅法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模 式。阻塞模式使⽤就像传统中的⽀持⼀样，⽐较简单，但是性能和可靠性都不好；⾮阻塞模式正 好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I/O 来提升开发速率和更好 的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发 </p>
<p><strong>AIO (Asynchronous I/O)</strong>: AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是 异步⾮阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。AIO 是异 步 IO 的缩写，虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程⾃ ⾏进⾏ IO 操作，IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还 不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</p>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>常见算法的 Java 实现</title>
    <url>/2021/03/25/java-algorithm-templates/</url>
    <content><![CDATA[<img src="/2021/03/25/java-algorithm-templates/algorithm-bg.jpg" alt="See the source image" style="zoom:50%;">

<a id="more"></a>



<h1 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h1><h2 id="1-1-DFS"><a href="#1-1-DFS" class="headerlink" title="1.1 DFS"></a>1.1 DFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-BFS"><a href="#1-2-BFS" class="headerlink" title="1.2 BFS"></a>1.2 BFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-最大公约数、最小公倍数"><a href="#1-3-最大公约数、最小公倍数" class="headerlink" title="1.3 最大公约数、最小公倍数"></a>1.3 最大公约数、最小公倍数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; <span class="number">0</span> ? gcd(y, x % y) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-二分查找"><a href="#1-4-二分查找" class="headerlink" title="1.4 二分查找"></a>1.4 二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line"></span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    	mid = ((high - low)/<span class="number">2</span>) + low;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>coding</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Java并发的总结和思考</title>
    <url>/2021/06/15/java-concurrency/</url>
    <content><![CDATA[<img src="/2021/06/15/java-concurrency/bg.jpg" alt="img" style="zoom: 67%;">

<a id="more"></a>

<h1 id="1-进程、线程和协程的基本概念"><a href="#1-进程、线程和协程的基本概念" class="headerlink" title="1. 进程、线程和协程的基本概念"></a>1. 进程、线程和协程的基本概念</h1><h2 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1 什么是进程"></a>1.1 什么是进程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位。</p>
<h2 id="1-2-什么是线程"><a href="#1-2-什么是线程" class="headerlink" title="1.2 什么是线程"></a>1.2 什么是线程</h2><p>线程是程序的一条执行路径，是现代操作系统调度的基本单位。</p>
<p>在Java中，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<p><img src="/2021/06/15/java-concurrency/82539cb6fc7b45bd94c4a6e3ad858bf2.png" alt="img"></p>
<h2 id="1-3-什么是协程"><a href="#1-3-什么是协程" class="headerlink" title="1.3 什么是协程"></a>1.3 什么是协程</h2><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<img src="/2021/06/15/java-concurrency/6765e36cc4604fba897976638af03524.jpeg" alt="img" style="zoom: 67%;">

<h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1><h2 id="2-1-进程和线程的关系"><a href="#2-1-进程和线程的关系" class="headerlink" title="2.1 进程和线程的关系"></a>2.1 进程和线程的关系</h2><p>进程是系统运行程序和<strong>资源分配</strong>的基本单位，线程是<strong>系统调度</strong>的基本单位。</p>
<ul>
<li><p>进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动</p>
</li>
<li><p>区别：</p>
<ul>
<li>程序是指令的有序集合，是一个静态概念</li>
<li>进程是一个能独立运行的单位，能与其他进程并行地活动</li>
<li>线程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。</li>
</ul>
</li>
</ul>
<img src="/2021/06/15/java-concurrency/image-20210721170532276.png" alt="image-20210721170532276" style="zoom: 50%;">

<h2 id="2-2-程序计数器为什么是私有的？"><a href="#2-2-程序计数器为什么是私有的？" class="headerlink" title="2.2 程序计数器为什么是私有的？"></a>2.2 程序计数器为什么是私有的？</h2><p>每个线程拥有不同的执行路径，因此需要程序计数器来记录当前执行到的位置，保证线程切换后能恢复到正确的执行位置。</p>
<h2 id="2-3-虚拟机栈和本地方法栈为什么是私有的？"><a href="#2-3-虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="2.3 虚拟机栈和本地方法栈为什么是私有的？"></a>2.3 虚拟机栈和本地方法栈为什么是私有的？</h2><p>每个线程的方法拥有自己独立的栈帧，以保证线程中的局部变量不被别的线程访问到。</p>
<h2 id="2-4-堆和方法区"><a href="#2-4-堆和方法区" class="headerlink" title="2.4 堆和方法区"></a>2.4 堆和方法区</h2><p>堆和方法区为进程所有，由线程共享。</p>
<p>堆主要用于存放新创建的对象；方法区主要用去存放编译后的代码等信息（例如已被加载的类信息、常量、静态变量）</p>
<h2 id="2-5-线程的生命周期和状态"><a href="#2-5-线程的生命周期和状态" class="headerlink" title="2.5 线程的生命周期和状态"></a>2.5 线程的生命周期和状态</h2><p><img src="/2021/06/15/java-concurrency/82539cb6fc7b45bd94c4a6e3ad858bf2.png" alt="img"></p>
<h2 id="2-6-线程的上下文切换"><a href="#2-6-线程的上下文切换" class="headerlink" title="2.6 线程的上下文切换"></a>2.6 线程的上下文切换</h2><p>当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次 再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换</p>
<h1 id="3-并发和并行"><a href="#3-并发和并行" class="headerlink" title="3. 并发和并行"></a>3. 并发和并行</h1><h2 id="3-1-并发和并行的区别"><a href="#3-1-并发和并行的区别" class="headerlink" title="3.1 并发和并行的区别"></a>3.1 并发和并行的区别</h2><ul>
<li>并发：同一时间段内，多个任务都执行了（例如时间片法）</li>
<li>并行：同一时刻，执行多个任务（例如多核）</li>
</ul>
<h1 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4. 多线程"></a>4. 多线程</h1><h2 id="4-1-为什么使用多线程？"><a href="#4-1-为什么使用多线程？" class="headerlink" title="4.1 为什么使用多线程？"></a>4.1 为什么使用多线程？</h2><ul>
<li>从计算机底层来说： 计算机有多任务调度的需求，最早是基于进程实现的多任务调度，但是进程切换成本较高，由此诞生了更加轻量的线程，满足多任务调度需求。</li>
<li>从互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h2 id="4-2-使用多线程带来的问题"><a href="#4-2-使用多线程带来的问题" class="headerlink" title="4.2 使用多线程带来的问题"></a>4.2 使用多线程带来的问题</h2><ul>
<li>内存泄漏</li>
<li>一致性问题（线程同步）</li>
<li>死锁</li>
</ul>
<h2 id="4-3-Java和线程"><a href="#4-3-Java和线程" class="headerlink" title="4.3 Java和线程"></a>4.3 Java和线程</h2><h3 id="4-3-1-内核线程实现"><a href="#4-3-1-内核线程实现" class="headerlink" title="4.3.1 内核线程实现"></a>4.3.1 内核线程实现</h3><p>使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核 （Multi-Threads Kernel）。</p>
<p>内核线程（Kernel-Level Thread，KLT）</p>
<p>轻量级进程（Light Weight Process，LWP）</p>
<p>一个进程（P）拥有多个线程（LWP），每一个LWP被映射为KLT，由线程调度器调度到物理CPU上执行。</p>
<img src="/2021/06/15/java-concurrency/image-20210720195629494.png" alt="image-20210720195629494" style="zoom:67%;">

<h3 id="4-3-2-用户线程实现"><a href="#4-3-2-用户线程实现" class="headerlink" title="4.3.2 用户线程实现"></a>4.3.2 用户线程实现</h3><p>即协程</p>
<h1 id="5-上下文切换"><a href="#5-上下文切换" class="headerlink" title="5. 上下文切换"></a>5. 上下文切换</h1><p>当线程发生中断，或者用完当前时间片，就会触发上下文切换，操作系统会将CPU的使用权分配给其他线程。</p>
<p>保护现场、恢复现场。</p>
<h1 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6. 死锁"></a>6. 死锁</h1><p>定义：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁</p>
<h2 id="6-1-产生死锁的必要条件"><a href="#6-1-产生死锁的必要条件" class="headerlink" title="6.1 产生死锁的必要条件"></a>6.1 产生死锁的必要条件</h2><ol>
<li>互斥条件：在一段时间内某资源仅为一个进程所占有。</li>
<li>不可剥夺条件：该资源只能由获得该资源的进程自己来释放。</li>
<li>占有并等待条件：进程在等待新资源的同时，继续占用已分配到的资源。</li>
<li>循环等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
<h2 id="6-2-死锁的处理"><a href="#6-2-死锁的处理" class="headerlink" title="6.2 死锁的处理"></a>6.2 死锁的处理</h2><ul>
<li>预防死锁：通过设置某些限制条件，去破坏死锁四个必要条件中的一个或多个</li>
<li>避免死锁：在资源动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁的产生</li>
<li>检测死锁：允许系统在运行过程中发生死锁，但可检测死锁的发生，并采取适当措施加以清除</li>
<li>解除死锁：当检测出死锁后，采取措施将进程从死锁状态中解脱出来</li>
</ul>
<h4 id="6-2-1-预防死锁"><a href="#6-2-1-预防死锁" class="headerlink" title="6.2.1 预防死锁"></a>6.2.1 预防死锁</h4><ul>
<li><p>破坏互斥条件：采用虚拟分配技术排除非共享设备死锁的可能性。</p>
</li>
<li><p>破坏不可剥夺条件：</p>
<ul>
<li>允许资源抢占</li>
</ul>
</li>
<li><p>破坏占有并等待：</p>
<ul>
<li>一次性资源分配方案</li>
<li>每个进程申请资源前，释放它所占有的资源</li>
</ul>
</li>
<li><p>破坏循环等待条：静态资源分配、有序资源分配、修复死锁、重启系统。</p>
</li>
</ul>
<h4 id="6-2-2-避免死锁"><a href="#6-2-2-避免死锁" class="headerlink" title="6.2.2 避免死锁"></a>6.2.2 避免死锁</h4><p><strong>方法：</strong></p>
<ul>
<li><p>有序资源分配法：资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），必须以上升的次序申请资源。</p>
</li>
<li><p>银行家算法：系统给当前进程分配资源时，先检查是否安全，如果安全，允许分配资源，否则让进程进入等待状态。</p>
<ul>
<li><a href="https://blog.csdn.net/wljliujuan/article/details/79651932/">https://blog.csdn.net/wljliujuan/article/details/79651932/</a></li>
</ul>
</li>
</ul>
<p><strong>技术：</strong></p>
<ul>
<li>加锁顺序：线程按照一定的顺序加锁，要求事先知道所有可能会用到的锁，并对这些锁做适当的排序，但总有些时候是无法预知的。</li>
<li>加锁时限：线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁。如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。</li>
<li>死锁检测：死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</li>
</ul>
<h4 id="6-2-3-检测死锁"><a href="#6-2-3-检测死锁" class="headerlink" title="6.2.3 检测死锁"></a>6.2.3 检测死锁</h4><h4 id="6-2-4-解除死锁"><a href="#6-2-4-解除死锁" class="headerlink" title="6.2.4 解除死锁"></a>6.2.4 解除死锁</h4><ul>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ul>
<h1 id="7-Java线程方法"><a href="#7-Java线程方法" class="headerlink" title="7. Java线程方法"></a>7. Java线程方法</h1><h2 id="7-1-sleep-和-wait"><a href="#7-1-sleep-和-wait" class="headerlink" title="7.1 sleep() 和 wait()"></a>7.1 sleep() 和 wait()</h2><ul>
<li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h2 id="7-2-start-和-run"><a href="#7-2-start-和-run" class="headerlink" title="7.2 start() 和 run()"></a>7.2 start() 和 run()</h2><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<blockquote>
<p>Reference<br>[1]: <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93</a><br>[2]: <a href="https://blog.csdn.net/wljliujuan/article/details/79614019">https://blog.csdn.net/wljliujuan/article/details/79614019</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>concurrency</tag>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器</title>
    <url>/2021/06/02/java-containers/</url>
    <content><![CDATA[<img src="/2021/06/02/java-containers/collections.png" alt="See the source image" style="zoom:67%;">

<a id="more"></a>

<h1 id="1-Java集合概述"><a href="#1-Java集合概述" class="headerlink" title="1 Java集合概述"></a>1 Java集合概述</h1><h2 id="1-1-集合的分类"><a href="#1-1-集合的分类" class="headerlink" title="1.1 集合的分类"></a>1.1 集合的分类</h2><ul>
<li>除了 <code>Map</code> 大类， 其他容器类都实现了 <code>Collection</code> 接口</li>
</ul>
<img src="/2021/06/02/java-containers/java-collection-hierarchy.png" alt="img" style="zoom: 67%;">



<h2 id="1-2-List、Set、Map的区别"><a href="#1-2-List、Set、Map的区别" class="headerlink" title="1.2 List、Set、Map的区别"></a>1.2 List、Set、Map的区别</h2><ul>
<li><code>List</code>：保存的元素是可重复、有序的。</li>
<li><code>Set</code>：保存的元素是不可重复、无序的。</li>
<li><code>Map</code>：使用Key-Value存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="1-3-容器结构的底层实现"><a href="#1-3-容器结构的底层实现" class="headerlink" title="1.3 容器结构的底层实现"></a>1.3 容器结构的底层实现</h2><ul>
<li><code>List</code><ul>
<li><code>ArrayList</code>：**Object[]**，<code>List</code>的常见实现类，线程不安全。</li>
<li><code>Vector</code>：**Object[]**，<code>List</code>的古老实现类，线程安全。</li>
<li><code>LinkedList</code>：<strong>双向链表</strong>，JDK7之前采用双向循环链表</li>
</ul>
</li>
<li><code>Set</code><ul>
<li><code>HashSet</code>：基于<code>HashMap</code>实现。</li>
<li><code>LinkedHashSet</code>：基于<code>LinkedHashMap</code>实现。</li>
</ul>
</li>
<li>Map<ul>
<li><code>HashMap</code>：DK1.8 之前 <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成<strong>红黑树</strong>前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。是Map的常见实现类，线程</li>
<li><code>HashTable</code>：<strong>数组+链表</strong>，<code>Map</code>的古老实现类，线程安全。</li>
<li><code>LinkedHashMap</code>：在<code>HashMap</code>的基础上增加了一个<strong>双向链表</strong>，用来记录键值对的插入顺序，通过链表实现了访问顺序的相关逻辑</li>
<li><code>TreeMap</code>：<strong>红黑树</strong>。</li>
</ul>
</li>
</ul>
<h1 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h1><h2 id="2-1-ArrayList和Vector的区别"><a href="#2-1-ArrayList和Vector的区别" class="headerlink" title="2.1 ArrayList和Vector的区别"></a>2.1 ArrayList和Vector的区别</h2><ul>
<li><code>ArrayList</code>是<code>List</code>的主要实现类，底层采用<code>Object[]</code>存储，线程不安全，效率高。</li>
<li><code>Vector</code>是<code>List</code>的古老实现类，底层采用<code>Object[]</code>存储，线程安全，效率低。</li>
</ul>
<h2 id="2-2-ArrayList和LinkedList区别"><a href="#2-2-ArrayList和LinkedList区别" class="headerlink" title="2.2 ArrayList和LinkedList区别"></a>2.2 ArrayList和LinkedList区别</h2><ul>
<li>线程安全性：都是线程不安全的.</li>
<li>底层数据结构：<code>ArrayList</code>底层采用**<code>Object[]</code><strong>，<code>LinkedList</code>底层采用</strong>双向链表**.</li>
<li>插入或删除元素<ul>
<li><code>ArrayList</code>采用数组存储，在非尾部插入元素会产生数据移动，时间复杂度<code>O(n)</code>。</li>
<li><code>LinkedList</code>采用链表存储，插入元素时不会产生数据移动，时间复杂度<code>O(n)</code>。</li>
</ul>
</li>
<li>快速随机访问<ul>
<li><code>ArrayList</code>支持，<code>LinkedList</code>不支持。</li>
</ul>
</li>
<li>内存空间占用<ul>
<li><code>ArrayList</code>会预留一定的空间保存新的元素，<code>LinkedList</code>的每一个元素需要更多的空间保存（前继和后继）</li>
</ul>
</li>
</ul>
<h2 id="2-3-ArrayList的扩容机制★★★"><a href="#2-3-ArrayList的扩容机制★★★" class="headerlink" title="2.3 ArrayList的扩容机制★★★"></a>2.3 ArrayList的扩容机制★★★</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">JavaGuide (gitee.io)</a></p>
<h1 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h1><h2 id="3-1-Comparable和Comparator的区别"><a href="#3-1-Comparable和Comparator的区别" class="headerlink" title="3.1 Comparable和Comparator的区别"></a>3.1 Comparable和Comparator的区别</h2><ul>
<li><code>Comparable</code>接口位于<code>java.lang</code>包，它有一个<code>compareTo(Object obj)</code>方法来排序，是一个内比较器。</li>
<li><code>Comparator</code>接口位于<code>java.util</code>包，它有一个<code>compare(Object obj1, Object obj2)</code>方法来排序，是一个外比较器。</li>
<li>集合自定义排序：重写<code>compareTo()</code>方法或<code>compare()</code>方法。</li>
</ul>
<p><strong>使用<code>Comparable</code>定制排序（重写<code>compareTo</code>方法）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> TreeMap&lt;Person, String&gt;();</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>), <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">        Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">            System.out.println(key.getAge() + <span class="string">&quot;-&quot;</span> + key.getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>使用<code>Comparator</code>定制排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);arrayList.add(-<span class="number">2</span>);arrayList.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="3-2-无序性和不可重复性的含义是什么？"><a href="#3-2-无序性和不可重复性的含义是什么？" class="headerlink" title="3.2 无序性和不可重复性的含义是什么？"></a>3.2 无序性和不可重复性的含义是什么？</h2><ul>
<li>无序性：存储对象在底层数据结构中的位置不是由对象插入的顺序决定的，而是根据对象的哈希值决定的。</li>
<li>不可重复性：不重复的对象指使用<code>equals()</code>比较时返回<code>false</code>。</li>
</ul>
<h1 id="4-Map"><a href="#4-Map" class="headerlink" title="4 Map"></a>4 Map</h1><h2 id="4-1-HashMap和HashTable的区别"><a href="#4-1-HashMap和HashTable的区别" class="headerlink" title="4.1 HashMap和HashTable的区别"></a>4.1 HashMap和HashTable的区别</h2><ul>
<li>线程安全性：<code>HashMap</code>线程不安全，<code>HashTable</code>线程安全（因为其内部的方法都通过<code>synchronized</code>修饰）。</li>
<li>效率：<code>HashMap</code>效率高，<code>HashTable</code>因锁的原因效率低。</li>
<li>对<code>null</code>的支持：<code>HashMap</code>可以存储值为<code>null</code>的<code>key</code>和<code>value</code>，<code>HashTable</code>不允许。</li>
<li>初始容量大小和扩容机制：<code>HashTable</code>默认大小为11，扩容为2n+1；<code>HashMap</code>初始大小为16，扩容为2n。</li>
<li>底层数据结构：数据+链表；JDK1.8之后，<code>HashMap</code>发生了变化：当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ul>
<h2 id="4-2-HashMap和TreeMap区别"><a href="#4-2-HashMap和TreeMap区别" class="headerlink" title="4.2 HashMap和TreeMap区别"></a>4.2 HashMap和TreeMap区别</h2><img src="/2021/06/02/java-containers/TreeMap.png" alt="img" style="zoom:50%;">

<ul>
<li>TreeMap中的元素会根据键值自动排序。</li>
</ul>
<h2 id="4-3-HashSet如何检查重复"><a href="#4-3-HashSet如何检查重复" class="headerlink" title="4.3 HashSet如何检查重复"></a>4.3 HashSet如何检查重复</h2><p>会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h2 id="4-4-HashMap的底层实现"><a href="#4-4-HashMap的底层实现" class="headerlink" title="4.4 HashMap的底层实现"></a>4.4 HashMap的底层实现</h2><ul>
<li>JDK1.8之前： <strong>数组和链表</strong> 结合在一起，即 <strong>链表散列</strong>，使用拉链法解决哈希冲突。</li>
</ul>
<img src="/2021/06/02/java-containers/jdk1.8之前的内部结构-HashMap.png" alt="jdk1.8之前的内部结构-HashMap" style="zoom: 50%;">

<ul>
<li>JDK1.8及之后：当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
<img src="/2021/06/02/java-containers/jdk1.8之后的内部结构-HashMap.png" alt="jdk1.8之后的内部结构-HashMap" style="zoom: 33%;">



<h2 id="4-5-ConcurrentHashMap-和-Hashtable-的区别"><a href="#4-5-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="4.5 ConcurrentHashMap 和 Hashtable 的区别"></a>4.5 ConcurrentHashMap 和 Hashtable 的区别</h2><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<ul>
<li>HashTable</li>
</ul>
<img src="/2021/06/02/java-containers/HashTable全表锁.png" alt="HashTable全表锁" style="zoom: 50%;">

<ul>
<li>ConcurrentHashMap（JDK1.7）：<strong>Segment 数组 + HashEntry 数组 + 链表</strong></li>
</ul>
<img src="/2021/06/02/java-containers/ConcurrentHashMap分段锁.jpg" alt="JDK1.7的ConcurrentHashMap" style="zoom:50%;">

<ul>
<li>ConcurrentHashMap（JDK1.8）：<strong>Node 数组 + 链表 / 红黑树</strong>，冲突链表达到一定长度时，链表会转换成红黑树。</li>
</ul>
<img src="/2021/06/02/java-containers/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" style="zoom:50%;">

<h2 id="4-6-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#4-6-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="4.6 ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>4.6 ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h2><h3 id="4-6-1-JDK1-7（上面有示意图）"><a href="#4-6-1-JDK1-7（上面有示意图）" class="headerlink" title="4.6.1 JDK1.7（上面有示意图）"></a>4.6.1 JDK1.7（上面有示意图）</h3><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</span></span><br><span class="line"><span class="comment">//Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p>
<h3 id="4-6-2-JDK1-8-（上面有示意图）"><a href="#4-6-2-JDK1-8-（上面有示意图）" class="headerlink" title="4.6.2 JDK1.8 （上面有示意图）"></a>4.6.2 JDK1.8 （上面有示意图）</h3><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>learn</tag>
        <tag>collection</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/2021/07/02/java-microservice/</url>
    <content><![CDATA[<img src="/2021/07/02/java-microservice/bg.jpeg" alt="img" style="zoom:33%;">

<a id="more"></a>

<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
<ul>
<li><strong>一致性（Consistence）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA</a></p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<h2 id="Paxos算法和Raft算法"><a href="#Paxos算法和Raft算法" class="headerlink" title="Paxos算法和Raft算法"></a>Paxos算法和Raft算法</h2><p><strong>Paxos 算法</strong>诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—<strong>Raft 算法</strong>。</p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>用于提高搜索效率，功能和浏览器搜索引擎类似。比较常见的搜索引擎是 Elasticsearch和 Solr。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC 让调用远程服务调用像调用本地方法那样简单。</p>
<h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>网关主要用于请求转发、安全认证、协议转换、容灾。</p>
<h2 id="分布式id"><a href="#分布式id" class="headerlink" title="分布式id"></a>分布式id</h2><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。比如数据量太大之后，往往需要对进行对数据进行分库分表，分库分表后需要有一个唯一 ID 来标识一条数据或消息，数据库的自增 ID 显然不能满足需求。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</strong></p>
<p>简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ol>
<li><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/spring-cloud">大白话入门 Spring Cloud</a></li>
<li><a href="https://xiaozhuanlan.com/topic/2895047136">微服务/分布式大厂真实面试问题解答</a></li>
</ol>
<h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></h4><p>消息队列在分布式系统中主要是为了解耦和削峰。相关阅读： <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/message-queue">消息队列常见问题总结</a>。</p>
<ol>
<li><strong>RabbitMQ</strong> : <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/RabbitMQ%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86">RabbitMQ 入门</a></li>
<li><strong>RocketMQ</strong> : <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/RocketMQ">RocketMQ 入门</a>、<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/RocketMQ-Questions">RocketMQ 的几个简单问题与答案</a></li>
<li><strong>Kafka</strong> ：<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/Kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">Kafka 常见问题总结</a></li>
</ol>
<h4 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BBamp%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">读写分离&amp;分库分表</a></h4><p>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。主服务器负责写，从服务器负责读。另外，一主一从或者一主多从都可以。</p>
<p>读写分离可以大幅提高读性能，小幅提高写的性能。因此，读写分离更适合单机并发读请求比较多的场景。</p>
<p>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</p>
<p>常见的分库分表工具有：<code>sharding-jdbc</code>（当当）、<code>TSharding</code>（蘑菇街）、<code>MyCAT</code>（基于 Cobar）、<code>Cobar</code>（阿里巴巴）…。 </p>
<p>相关阅读： <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">读写分离&amp;分库分表常见问题总结</a></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></h4><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。</p>
<p>常见的负载均衡系统包括 3 种：</p>
<ol>
<li><strong>DNS 负载均衡</strong> ：一般用来实现地理级别的均衡。</li>
<li><strong>硬件负载均衡</strong> ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li>
<li><strong>软件负载均衡</strong> ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li>
</ol>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的 。</p>
<p>相关阅读： <strong>《<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9">如何设计一个高可用系统？要考虑哪些地方？</a>》</strong> 。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E9%99%90%E6%B5%81">限流</a></h4><p>限流是从用户访问压力的角度来考虑如何应对系统故障。</p>
<p>限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。比如某一接口的请求限制为 100 个每秒, 对超过限制的请求放弃处理或者放到队列中等待处理。限流可以有效应对突发请求过多。相关阅读：<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/high-availability/limit-request">限流算法有哪些？</a></p>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E9%99%8D%E7%BA%A7">降级</a></h4><p>降级是从系统功能优先级的角度考虑如何应对系统故障。</p>
<p>服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E7%86%94%E6%96%AD">熔断</a></h4><p>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。</p>
<p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>
<h4 id="排队"><a href="#排队" class="headerlink" title="排队"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E6%8E%92%E9%98%9F">排队</a></h4><p>另类的一种限流，类比于现实世界的排队。玩过英雄联盟的小伙伴应该有体会，每次一有活动，就要经历一波排队才能进入游戏。</p>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E9%9B%86%E7%BE%A4">集群</a></h4><p>相同的服务部署多份，避免单点故障。</p>
<h4 id="超时和重试机制"><a href="#超时和重试机制" class="headerlink" title="超时和重试机制"></a><a href="https://snailclimb.gitee.io/javaguide/#/?id=%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6">超时和重试机制</a></h4><p><strong>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</strong> 如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。</p>
<p>另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>learn</tag>
        <tag>distribute</tag>
        <tag>microservice</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 编程习惯和技巧</title>
    <url>/2021/05/28/java-programing-habits/</url>
    <content><![CDATA[<img src="/2021/05/28/java-programing-habits/java-coding.jpg" alt="See the source image" style="zoom:40%;">

<a id="more"></a>



<h1 id="1-编程习惯"><a href="#1-编程习惯" class="headerlink" title="1. 编程习惯"></a>1. 编程习惯</h1><h2 id="1-1-命名"><a href="#1-1-命名" class="headerlink" title="1.1 命名"></a>1.1 命名</h2><ul>
<li>类、方法、变量采用驼峰命名法，类首字母大写</li>
<li>项目名称采用串式命名法（kebab-case），例如“aaa-bbb-ccc”</li>
<li>类、变量用名词、方法用动词</li>
</ul>
<h2 id="1-2-异常处理"><a href="#1-2-异常处理" class="headerlink" title="1.2 异常处理"></a>1.2 异常处理</h2><h3 id="1-2-1-开发中如何选择使用try-catch-finally还是throws？"><a href="#1-2-1-开发中如何选择使用try-catch-finally还是throws？" class="headerlink" title="1.2.1 开发中如何选择使用try-catch-finally还是throws？"></a>1.2.1 开发中如何选择使用try-catch-finally还是throws？</h3><ul>
<li>父类方法没抛异常，则子类重写该方法时也不能抛异常，此时如果在重写方法时出现了异常，需要使用try-catch进行处理</li>
<li>存在调用链main-&gt;A-&gt;B-&gt;C，当方法ABC存在异常时，在main处理异常，方法内部将异常抛出即可。</li>
</ul>
<h2 id="1-3-比较继承-Thread-和实现-Runnable-两种方式实现多线程"><a href="#1-3-比较继承-Thread-和实现-Runnable-两种方式实现多线程" class="headerlink" title="1.3 比较继承 Thread 和实现 Runnable 两种方式实现多线程"></a>1.3 比较继承 <code>Thread</code> 和实现 <code>Runnable</code> 两种方式实现多线程</h2><ul>
<li>优先选择 <code>Runnable</code> 方式</li>
<li>原因：1. 实现的方式没有类的单继承的局限性 2. 实现的方式更适合用来处理多个线程共享数据的情况</li>
</ul>
<h2 id="1-4-Lock和synchronized"><a href="#1-4-Lock和synchronized" class="headerlink" title="1.4 Lock和synchronized"></a>1.4 Lock和synchronized</h2><ul>
<li>都可以解决同步问题</li>
<li>synchronized自动实现获取锁、释放锁，lock需要手动实现</li>
<li>建议使用lock&gt;同步代码块&gt;同步方法</li>
</ul>
<h1 id="2-应用开发"><a href="#2-应用开发" class="headerlink" title="2. 应用开发"></a>2. 应用开发</h1><h2 id="2-1-Properties的使用"><a href="#2-1-Properties的使用" class="headerlink" title="2.1 Properties的使用"></a>2.1 Properties的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.properties&quot;</span>);</span><br><span class="line">    pros.load(fis);</span><br><span class="line"></span><br><span class="line">    String name = pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-Spring-Bean管理"><a href="#2-2-Spring-Bean管理" class="headerlink" title="2.2 Spring Bean管理"></a>2.2 Spring Bean管理</h2><ul>
<li>使用xml管理bean，使用注解注入属性</li>
</ul>
<h2 id="2-3-单例工厂"><a href="#2-3-单例工厂" class="headerlink" title="2.3 单例工厂"></a>2.3 单例工厂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; OBJECT_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        String key = c.toString();</span><br><span class="line">        <span class="keyword">if</span> (OBJECT_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> c.cast(OBJECT_MAP.get(key));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the value is null, the value of the second parameter will be stored and returned</span></span><br><span class="line">            <span class="keyword">return</span> c.cast(OBJECT_MAP.computeIfAbsent(key, k -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> c.getDeclaredConstructor().newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SPI 机制</title>
    <url>/2021/07/28/java-spi/</url>
    <content><![CDATA[<h1 id="SPI机制简介"><a href="#SPI机制简介" class="headerlink" title="SPI机制简介"></a>SPI机制简介</h1><p>SPI，全称Service Provider Interface。</p>
<p>在面向对象的系统设计过程中，推荐各模块之间基于接口编程，同一种接口可能拥有多个的实现类，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，就需要一种服务发现机制，Java SPI就是这样一种机制：为某个接口寻找实现类。</p>
<p>典型示例：JDK中有支持音乐播放，假设只支持mp3的播放，有些厂商想在这个基础之上支持mp4播放，有的想支持mp5播放，如果没有提供SPI这种实现标准，那就只能通过修改Java的源码实现；利用SPI标准，SUN公司只需要提供一个播放接口，在实现播放的功能上通过ServiceLoad的方式加载服务，那么第三方只需要实现这个播放接口，按SPI标准的约定进行打包，再放到classpath下面就OK了，没有一点代码的侵入性。</p>
<h1 id="SPI约定"><a href="#SPI约定" class="headerlink" title="SPI约定"></a>SPI约定</h1><p>Java SPI的具体约定为：当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader。</p>
<h1 id="自定义SPI的实现"><a href="#自定义SPI的实现" class="headerlink" title="自定义SPI的实现"></a>自定义SPI的实现</h1><p><code>java.util.ServiceLoader</code>会自动从META-INF/services/下寻找对应接口的实现类</p>
<p><img src="/2021/07/28/java-spi/image-20210728123630083.png" alt="image-20210728123630083"></p>
<p><strong>MainApplication.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.pancras;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> indi.pancras.service.MusicService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PancrasL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;MusicService&gt; loader = ServiceLoader.load(MusicService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (MusicService musicService : loader) &#123;</span><br><span class="line">            isFound = <span class="keyword">true</span>;</span><br><span class="line">            musicService.playMusic();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isFound) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未发现MusicService实现类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MusicService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.pancras.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PancrasL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MusicService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playMusic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MusicServiceMp3Impl.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.pancras.mp3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> indi.pancras.service.MusicService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PancrasL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicServiceMp3Impl</span> <span class="keyword">implements</span> <span class="title">MusicService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMusic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;play MP3 music...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MusicServiceMp4Impl.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.pancras.mp4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> indi.pancras.service.MusicService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PancrasL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicServiceMp4Impl</span> <span class="keyword">implements</span> <span class="title">MusicService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMusic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;play MP4 music...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/28/java-spi/image-20210728124016090.png" alt="image-20210728124016090"></p>
<p><img src="/2021/07/28/java-spi/image-20210728124030785.png" alt="image-20210728124030785"></p>
<h2 id="music-application不引入实现模块"><a href="#music-application不引入实现模块" class="headerlink" title="music-application不引入实现模块"></a>music-application不引入实现模块</h2><p><img src="/2021/07/28/java-spi/image-20210728124137040.png" alt="image-20210728124137040"></p>
<p><img src="/2021/07/28/java-spi/image-20210728124159209.png" alt="image-20210728124159209"></p>
<h2 id="music-application引入一个实现模块"><a href="#music-application引入一个实现模块" class="headerlink" title="music-application引入一个实现模块"></a>music-application引入一个实现模块</h2><p><img src="/2021/07/28/java-spi/image-20210728124225536.png" alt="image-20210728124225536"></p>
<p><img src="/2021/07/28/java-spi/image-20210728124244496.png" alt="image-20210728124244496"></p>
<h2 id="music-application引入多个实现模块"><a href="#music-application引入多个实现模块" class="headerlink" title="music-application引入多个实现模块"></a>music-application引入多个实现模块</h2><p><img src="/2021/07/28/java-spi/image-20210728124254376.png" alt="image-20210728124254376"></p>
<p><img src="/2021/07/28/java-spi/image-20210728124308008.png" alt="image-20210728124308008"></p>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>spi</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream总结和思考</title>
    <url>/2021/06/22/java-stream/</url>
    <content><![CDATA[<p><img src="/2021/06/22/java-stream/bg.jpeg" alt="img"></p>
<a id="more"></a>

<h1 id="1-Java8的新特性——Stream"><a href="#1-Java8的新特性——Stream" class="headerlink" title="1. Java8的新特性——Stream"></a>1. Java8的新特性——Stream</h1><p>Java 8 API添加了一个新的抽象称为流Stream，可以以一种声明的方式处理数据，专注于对容器对象进行各种非常便利、高效的 <strong>聚合操作（aggregate operation）</strong>或者大批量数据操作。</p>
<p>Stream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时，它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程。</p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<h1 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2. 操作符"></a>2. 操作符</h1><p>操作符就是对数据进行的一种处理工作</p>
<p><strong>Stream</strong>的操作符大体上分为：<strong>中间操作符（Intermediate）</strong>、<strong>终止操作符（Terminal）</strong>、<strong>短路操作符（Short-circuiting）</strong></p>
<h2 id="2-1-中间操作符"><a href="#2-1-中间操作符" class="headerlink" title="2.1 中间操作符"></a>2.1 中间操作符</h2><p>对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。</p>
<p>中间操作符包含8种(排除了parallel,sequential,这两个操作并不涉及到对数据流的加工操作)：</p>
<ul>
<li>map(mapToInt,mapToLong,mapToDouble) 转换操作符，把比如A-&gt;B，这里默认提供了转int，long，double的操作符。</li>
<li>flatmap(flatmapToInt,flatmapToLong,flatmapToDouble) 拍平操作比如把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。</li>
<li>distint 去重操作，对重复元素去重，底层使用了equals方法。</li>
<li>filter 过滤操作，把不想要的数据过滤。</li>
<li>peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。</li>
<li>skip 跳过操作，跳过某些元素。</li>
<li>sorted(unordered) 排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。</li>
</ul>
<h2 id="2-2-终止操作符"><a href="#2-2-终止操作符" class="headerlink" title="2.2 终止操作符"></a>2.2 终止操作符</h2><p>数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。</p>
<ul>
<li>collect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors。</li>
<li>count 统计操作，统计最终的数据个数。</li>
<li>min、max 最值操作，需要自定义比较器，返回数据流中最大最小的值。</li>
<li>reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。</li>
<li>forEach、forEachOrdered 遍历操作，这里就是对最终的数据进行消费了。</li>
<li>toArray 数组操作，将数据流的元素转换成数组。</li>
</ul>
<h2 id="2-3-短路操作符"><a href="#2-3-短路操作符" class="headerlink" title="2.3 短路操作符"></a>2.3 短路操作符</h2><p>有时候需要在遍历中途停止操作，比如查找第一个满足条件的元素或者limit操作。</p>
<ul>
<li>noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。</li>
<li>findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。</li>
<li>limit 限流操作，比如数据流中有10个 我只要出前3个就可以使用。</li>
</ul>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><ul>
<li>map：将T类型转换成R类型的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;waltermaleon&quot;</span>,<span class="string">&quot;grape&quot;</span>)</span><br><span class="line">	.map(e-&gt;e.length()) <span class="comment">// 转成单词的长度 int</span></span><br><span class="line">	.forEach(e-&gt;System.out.println(e)); <span class="comment">// 输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap：将拍扁的元素重新组成Stream</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a-b-c-d&quot;</span>,<span class="string">&quot;e-f-i-g-h&quot;</span>)</span><br><span class="line">	.flatMap(e-&gt;Stream.of(e.split(<span class="string">&quot;-&quot;</span>)))</span><br><span class="line">	.forEach(e-&gt;System.out.println(e));<span class="comment">// 换行输出a、b、c ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>limit：限制元素的个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 限制三个</span></span><br><span class="line">	.forEach(e-&gt;System.out.println(e)); <span class="comment">// 将输出 前三个 1，2，3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>distinct：将根据equals 方法进行判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">	.distinct() <span class="comment">// 去重</span></span><br><span class="line">	.forEach(e-&gt;System.out.println(e));</span><br></pre></td></tr></table></figure>

<ul>
<li>filter：对元素进行过滤，不符合筛选条件的将无法进入流的下游</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">	.filter(e-&gt;e&gt;=<span class="number">5</span>) <span class="comment">// 过滤小于5的</span></span><br><span class="line">	.forEach(e-&gt;System.out.println(e));</span><br></pre></td></tr></table></figure>

<ul>
<li>peek：将元素挑选出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(w,x,y)</span><br><span class="line">	.peek(e-&gt;&#123;e.setName(e.getAge()+e.getName());&#125;) <span class="comment">// 重新设置名字 变成 年龄+名字</span></span><br><span class="line">	.forEach(e-&gt;System.out.println(e.toString()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>skip：跳过元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">	.skip(<span class="number">4</span>) <span class="comment">// 跳过前四个</span></span><br><span class="line">	.forEach(e-&gt;System.out.println(e)); <span class="comment">// 输出的结果应该只有5，6，7，8，9</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sorted：排序，底层依赖Comparable 实现，也可以提供自定义比较器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认排序</span></span><br><span class="line">Stream.of(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>)</span><br><span class="line">	.sorted()</span><br><span class="line">	.forEach(e-&gt;System.out.println(e));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较器</span></span><br><span class="line">Stream.of(w,x,y)</span><br><span class="line">	.sorted((e1,e2)-&gt;e1.age&gt;e2.age?<span class="number">1</span>:e1.age==e2.age?<span class="number">0</span>:-<span class="number">1</span>)</span><br><span class="line">	.forEach(e-&gt;System.out.println(e.toString()));</span><br></pre></td></tr></table></figure>

<ul>
<li>collect：收集，使用系统提供的收集器可以将最终的数据流收集到List，Set，Map等容器中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;waltermaleon&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">	.collect(Collectors.toSet()) <span class="comment">//set 容器</span></span><br><span class="line">	.forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>

<ul>
<li>count：统计数据流中的元素个数，返回的是long 类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;waltermaleon&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">	.count();</span><br></pre></td></tr></table></figure>

<ul>
<li>findFirst：获取流中的第一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; stringOptional = Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;waltermaleon&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">	.findFirst();</span><br><span class="line">stringOptional.ifPresent(e-&gt;System.out.println(e));</span><br></pre></td></tr></table></figure>

<ul>
<li>findAny：获取流中任意一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; stringOptional = Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;waltermaleon&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">	.parallel()</span><br><span class="line">	.findAny(); <span class="comment">//在并行流下每次返回的结果可能一样也可能不一样</span></span><br><span class="line">stringOptional.ifPresent(e-&gt;System.out.println(e));</span><br></pre></td></tr></table></figure>

<ul>
<li>min、max：元素中最小、大的，需要传入比较器，也可能没有（流为Empty时）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; integerOptional = Stream.of(<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,-<span class="number">1</span>)</span><br><span class="line">	.max((e1,e2)-&gt;e1.compareTo(e2));</span><br><span class="line"></span><br><span class="line">integerOptional.ifPresent(e-&gt;System.out.println(e));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>References:</p>
<p>[1] <a href="https://www.jianshu.com/p/11c925cdba50">https://www.jianshu.com/p/11c925cdba50</a><br>[2] <a href="https://www.runoob.com/java/java8-streams.html">https://www.runoob.com/java/java8-streams.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂 Java 虚拟机</title>
    <url>/2021/04/16/java-virtual-machine/</url>
    <content><![CDATA[<img src="/2021/04/16/java-virtual-machine/java.png" alt="img" style="zoom: 40%;">

<a id="more"></a>



<h1 id="1-Java自动内存管理"><a href="#1-Java自动内存管理" class="headerlink" title="1. Java自动内存管理"></a>1. Java自动内存管理</h1><h2 id="1-1-Java虚拟机数据区"><a href="#1-1-Java虚拟机数据区" class="headerlink" title="1.1 Java虚拟机数据区"></a>1.1 Java虚拟机数据区</h2><img src="/2021/04/16/java-virtual-machine/java-memory-data.png" alt="image-20210416193406740" style="zoom:50%;">

<ul>
<li>程序计数器</li>
</ul>
<p>一块较小的内存空间，用于记录当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>Java虚拟机栈</li>
</ul>
<p>Java虚拟机栈是线程私有的，生命周期与线程相同。每一个方法被执行时，Java虚拟机都会创建一个<strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<ul>
<li>本地方法栈</li>
</ul>
<p>为虚拟机使用到的本地方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<ul>
<li>Java堆</li>
</ul>
<p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，<strong>唯一</strong>目的是用于存放对象实例。</p>
<p>Java堆同时是垃圾收集器管理的内存区域，因此又称“GC堆”（Garbage Collected Heap）。</p>
<ul>
<li>方法区</li>
</ul>
<p>存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<ul>
<li>运行时</li>
</ul>
<p>存放编译期生成的各种字面量与符号引用。</p>
<ul>
<li>直接内存</li>
</ul>
<p>基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<h2 id="1-2-HotSpot虚拟机创建、访问对象的过程"><a href="#1-2-HotSpot虚拟机创建、访问对象的过程" class="headerlink" title="1.2 HotSpot虚拟机创建、访问对象的过程"></a>1.2 HotSpot虚拟机创建、访问对象的过程</h2><ul>
<li><strong>对象的创建</strong></li>
</ul>
<p>（1）当Java虚拟机遇到一条字节码new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，需要先执行相应的类加载过程</p>
<p>（2）类加载检查通过后，虚拟机将为新生对象分配内存。</p>
<blockquote>
<p> <strong>内存分配的方法：</strong>①指针碰撞：空闲空间和使用空间位于分界线两侧，把指向空闲空间的指针向下移动一个对象的大小 ②：空闲列表：由虚拟机维护一张列表，用于记录哪些内存块可用，在分配的时候从列表中找到一块足够大的空间分配给对象实例。</p>
</blockquote>
<blockquote>
<p><strong>内存分配时的同步问题：</strong>①对分配动作进行同步处理（加锁） ②本地线程分配缓冲：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，当本地缓冲用完时，分配新的缓冲区才需要同步锁定，减少了同步的开销。</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 和失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
</blockquote>
<p>（3）内存分配完毕后，虚拟机会将内存区域置零。</p>
<p>（4）接下来，虚拟机会对对象进行设置，包括标识对象属于哪个类、类的元数据信息的位置、对象的GC分代年龄、哈希码，这些信息会被记录到对象头中。</p>
<p>（5）new指令执行完毕后会接着执行<init>()方法，对对象进行初始化。</init></p>
<h2 id="1-3-对象的内存布局"><a href="#1-3-对象的内存布局" class="headerlink" title="1.3 对象的内存布局"></a>1.3 对象的内存布局</h2><p>（1）对象头（Header）：用于对象自身的运行时数据：HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p>（2）类型指针：指向所属类的元数据的指针。</p>
<p>（3）实例（Instance Data）：对象存储的数据。</p>
<p>（4）对齐填充（Padding）：起占位符作用。</p>
<h2 id="1-4-对象位置的定位"><a href="#1-4-对象位置的定位" class="headerlink" title="1.4 对象位置的定位"></a>1.4 对象位置的定位</h2><h3 id="1-4-1-通过句柄访问对象"><a href="#1-4-1-通过句柄访问对象" class="headerlink" title="1.4.1 通过句柄访问对象"></a>1.4.1 通过句柄访问对象</h3><p>优点：reference中存储的是句柄地址，在对象被移动时（例如整理内存碎片）无需改变reference本身</p>
<p>缺点：两次寻址开销</p>
<img src="/2021/04/16/java-virtual-machine/obj-handler-ref.png" alt="image-20210416203400581" style="zoom: 67%;">

<h3 id="1-4-2-通过直接指针访问对象"><a href="#1-4-2-通过直接指针访问对象" class="headerlink" title="1.4.2 通过直接指针访问对象"></a>1.4.2 通过直接指针访问对象</h3><p>优点：访问速度快，节省了一次寻址开销（HotSpot采用的方式）</p>
<img src="/2021/04/16/java-virtual-machine/obj-pointer-ref.png" alt="image-20210416203836898" style="zoom:67%;">



<h2 id="1-5-Java内存溢出"><a href="#1-5-Java内存溢出" class="headerlink" title="1.5 Java内存溢出"></a>1.5 Java内存溢出</h2><h3 id="1-5-1-堆溢出"><a href="#1-5-1-堆溢出" class="headerlink" title="1.5.1 堆溢出"></a>1.5.1 堆溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap spacepublic <span class="class"><span class="keyword">class</span> <span class="title">HeapOverflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-2-栈溢出"><a href="#1-5-2-栈溢出" class="headerlink" title="1.5.2 栈溢出"></a>1.5.2 栈溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        dfs(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-3-方法区和运行时常量池溢出"><a href="#1-5-3-方法区和运行时常量池溢出" class="headerlink" title="1.5.3 方法区和运行时常量池溢出"></a>1.5.3 方法区和运行时常量池溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOverflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jdk6报Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</span></span><br><span class="line"><span class="comment">jdk7及以上报Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">原因：自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-4-本机直接内存溢出"><a href="#1-5-4-本机直接内存溢出" class="headerlink" title="1.5.4 本机直接内存溢出"></a>1.5.4 本机直接内存溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOverflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="1-6-Java类加载器"><a href="#1-6-Java类加载器" class="headerlink" title="1.6 Java类加载器"></a>1.6 Java类加载器</h2><h3 id="1-6-1-双亲委派机制"><a href="#1-6-1-双亲委派机制" class="headerlink" title="1.6.1 双亲委派机制"></a>1.6.1 双亲委派机制</h3><p>上层类加载器呼叫底层类加载器加载，如果底层不能加载，再有上层类加载。</p>
<ul>
<li>优点：<ul>
<li>避免类的重复加载</li>
<li>防止核心API被恶意篡改</li>
</ul>
</li>
</ul>
<h3 id="1-6-2-沙箱安全机制"><a href="#1-6-2-沙箱安全机制" class="headerlink" title="1.6.2 沙箱安全机制"></a>1.6.2 沙箱安全机制</h3><h1 id="2-垃圾收集器"><a href="#2-垃圾收集器" class="headerlink" title="2. 垃圾收集器"></a>2. 垃圾收集器</h1><h2 id="2-1-对象的生命周期"><a href="#2-1-对象的生命周期" class="headerlink" title="2.1 对象的生命周期"></a>2.1 对象的生命周期</h2><h3 id="2-1-1-垃圾回收的对象"><a href="#2-1-1-垃圾回收的对象" class="headerlink" title="2.1.1 垃圾回收的对象"></a>2.1.1 垃圾回收的对象</h3><ul>
<li><p>方法结束时该方法所涉及的PC、栈帧</p>
</li>
<li><p>堆中已经“死掉”的对象（垃圾收集）</p>
</li>
</ul>
<h3 id="2-1-2-垃圾回收的时机"><a href="#2-1-2-垃圾回收的时机" class="headerlink" title="2.1.2 垃圾回收的时机"></a>2.1.2 垃圾回收的时机</h3><ul>
<li><p>显式调用 <code>System.gc()</code></p>
</li>
<li><p>每隔一段时间Java虚拟机会自动调用 <code>gc()</code> </p>
</li>
</ul>
<h3 id="2-1-3-对象的引用类型"><a href="#2-1-3-对象的引用类型" class="headerlink" title="2.1.3 对象的引用类型"></a>2.1.3 对象的引用类型</h3><ul>
<li>强引用：形如 <code>Object obj = new Object()</code> 及 <code>obj1.friends = obj2</code> 的形式，垃圾收集器永远不会回收存在强引用的对象。</li>
<li>软引用：一些还有用、但非必须的对象，在内存发生溢出前被回收。使用 <code>SoftReference</code> 类来实现软引用。</li>
<li>弱引用：非必须对象，强度弱于软引用，在下一次垃圾收集时回收。使用 <code>WeakReference</code> 类来实现弱引用。</li>
<li>虚引用：最弱的一种引用关系，只是为了能在对象被回收时收到一个系统通知。使用 <code>PhantomReference</code> 来实现虚引用。</li>
</ul>
<h3 id="2-1-4-对象回收的触发条件"><a href="#2-1-4-对象回收的触发条件" class="headerlink" title="2.1.4 对象回收的触发条件"></a>2.1.4 对象回收的触发条件</h3><ul>
<li>第一次标记（回收）：可达性分析后与GC Roots不相连的对象。</li>
<li>第二次标记（避免被回收）：筛选出有必要执行<code>finalize()</code>方法的对象（即<code>finalize</code>被用户覆盖的对象），将其加入到F-Queue，如果对象在finalize()中重新建立了关联，该对象会拯救，不会被回收。</li>
</ul>
<h3 id="2-1-5-回收方法区的考量"><a href="#2-1-5-回收方法区的考量" class="headerlink" title="2.1.5 回收方法区的考量"></a>2.1.5 回收方法区的考量</h3><ul>
<li>回收方法区的收益低</li>
</ul>
<p>垃圾收集通常可以回收70%-90%的空间，相比之下，方法区回收囿于苛刻的判定条件，回收效果远低于此。</p>
<ul>
<li>方法区的垃圾收集的内容<ul>
<li><strong>废弃的常量</strong><ul>
<li>回收行为和Java堆很类似。</li>
<li>例如：一个字符串 “java” 曾进入常量池，但程序中没有任何字符串对象引用“Java”常量，且虚拟机也没有其他地方引用这个字面量，此时如果发生内存回收，且垃圾收集器判断有必要时，该常量将被清理出常量池。常量池中的其他类、方法、字段的符号同理。</li>
</ul>
</li>
<li><strong>不再使用的类型</strong><ul>
<li>判定条件苛刻<ul>
<li>该类的所有实例被回收</li>
<li>类加载器被回收</li>
<li>类的 <code>java.lang.Class</code> 对象没有在任何地方被应用，无法通过反射创建该类的方法</li>
</ul>
</li>
<li>通过参数 <code>-Xnoclassgc</code> 参数进行控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-引用计数法和可达性分析法"><a href="#2-2-引用计数法和可达性分析法" class="headerlink" title="2.2 引用计数法和可达性分析法"></a>2.2 引用计数法和可达性分析法</h2><h3 id="2-2-1-引用计数法"><a href="#2-2-1-引用计数法" class="headerlink" title="2.2.1 引用计数法"></a>2.2.1 引用计数法</h3><p>使用额外的内存空间进行引用计数，适合大多数场景，但是存在例外情况（例如循环引用），需要大量的额外处理才能解决内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User u1 = <span class="keyword">new</span> User();</span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">u1.friends = u2;</span><br><span class="line">u2.friends = u1;</span><br><span class="line"></span><br><span class="line">u1 = <span class="keyword">null</span>;</span><br><span class="line">u2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法回收u1、u2所占用的空间</span></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-可达性分析算法"><a href="#2-2-2-可达性分析算法" class="headerlink" title="2.2.2 可达性分析算法"></a>2.2.2 可达性分析算法</h3><p>Java、C#、Lisp采用的分析方法。从”GC Roots“开始，根据引用关系向下搜索，标记不可达的对象为待回收。</p>
<h2 id="2-3-垃圾收集算法"><a href="#2-3-垃圾收集算法" class="headerlink" title="2.3 垃圾收集算法"></a>2.3 垃圾收集算法</h2><ul>
<li>计数式垃圾收集（Reference Counting GC）（略）</li>
<li>追踪式垃圾收集（Tracing GC）（Java）</li>
</ul>
<h3 id="2-3-1-分代收集理论"><a href="#2-3-1-分代收集理论" class="headerlink" title="2.3.1 分代收集理论"></a>2.3.1 分代收集理论</h3><ul>
<li><p><strong>弱</strong>分代假说：绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p><strong>强</strong>分代解说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</li>
<li><p>跨代引用假说：跨代引用相较于同代引用来说仅占极少数。</p>
</li>
</ul>
<hr>
<p>垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同区域之中存储。</p>
<ul>
<li>新生代：存活时间短的对象</li>
<li>老生代：存活时间长的对象</li>
</ul>
<h3 id="2-3-2-标记-清除算法"><a href="#2-3-2-标记-清除算法" class="headerlink" title="2.3.2 标记-清除算法"></a>2.3.2 标记-清除算法</h3><ul>
<li>标记</li>
</ul>
<p>标记出所有需要回收的对象</p>
<ul>
<li>清除</li>
</ul>
<p>标记完成过后统一回收所有被标记的对象</p>
<ul>
<li>缺点</li>
</ul>
<p>① 执行效率不稳定，尤其是当Java堆中存在大量需要被回收的对象时。</p>
<p>② 内存碎片化。</p>
<img src="/2021/04/16/java-virtual-machine/mark-clear.png" alt="image-20210418184448479" style="zoom:67%;">



<h3 id="2-3-3-标记-复制算法"><a href="#2-3-3-标记-复制算法" class="headerlink" title="2.3.3 标记-复制算法"></a>2.3.3 标记-复制算法</h3><ul>
<li>半区复制</li>
</ul>
<p>将一块内存分为两块，当一块的内存用完后，将还存活的对象复制到另一块，然后将已使用过的内存空间一次清理掉。</p>
<ul>
<li>缺点</li>
</ul>
<p>浪费空间，可用空间只有原空间的1/2。</p>
<ul>
<li>应用</li>
</ul>
<p>现在的商用Java虚拟机采用该算法回收新生代，但由于新生代的大多数对象的存活时间很短，因此可以修改内存分配比例，例如HotSpot的将划分比例设置为为8：1（Eden：Survivor）。</p>
<img src="/2021/04/16/java-virtual-machine/mark-copy.png" alt="image-20210418184801176" style="zoom: 67%;">



<h3 id="2-3-4-标记-整理算法"><a href="#2-3-4-标记-整理算法" class="headerlink" title="2.3.4 标记-整理算法"></a>2.3.4 标记-整理算法</h3><ul>
<li>标记</li>
</ul>
<p>标记出所有需要回收的对象</p>
<ul>
<li>整理</li>
</ul>
<p>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<img src="/2021/04/16/java-virtual-machine/mark-category.png" alt="image-20210418185507506" style="zoom:67%;">



<h2 id="2-4-HotSpot算法实现细节"><a href="#2-4-HotSpot算法实现细节" class="headerlink" title="2.4 HotSpot算法实现细节"></a>2.4 HotSpot算法实现细节</h2><h2 id="2-5-垃圾收集器"><a href="#2-5-垃圾收集器" class="headerlink" title="2.5 垃圾收集器"></a>2.5 垃圾收集器</h2><h3 id="2-5-1-Serial收集器"><a href="#2-5-1-Serial收集器" class="headerlink" title="2.5.1 Serial收集器"></a>2.5.1 Serial收集器</h3><p>最基础、历史最悠久的收集器。</p>
<p>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生 代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内 存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）[1]最小的；对于单核处理 器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以 获得最高的单线程收集效率。在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚 拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的 内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一 百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。</p>
<p>对于运行在客户端模式下的虚拟机来说是一个很好的选择</p>
<img src="/2021/04/16/java-virtual-machine/image-20210720171839406.png" alt="image-20210720171839406" style="zoom: 80%;">

<h3 id="2-5-2-ParNew收集器"><a href="#2-5-2-ParNew收集器" class="headerlink" title="2.5.2 ParNew收集器"></a>2.5.2 ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本</p>
<p><img src="/2021/04/16/java-virtual-machine/image-20210720171958473.png" alt="image-20210720171958473"></p>
<h3 id="2-5-3-Parallel-Scavenge收集器"><a href="#2-5-3-Parallel-Scavenge收集器" class="headerlink" title="2.5.3 Parallel Scavenge收集器"></a>2.5.3 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能<br>地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐 量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</p>
<h3 id="2-5-4-Serial-Old收集器"><a href="#2-5-4-Serial-Old收集器" class="headerlink" title="2.5.4 Serial Old收集器"></a>2.5.4 Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<p><img src="/2021/04/16/java-virtual-machine/image-20210720172155858.png" alt="image-20210720172155858"></p>
<h3 id="2-5-5-Parrallel-Old收集器"><a href="#2-5-5-Parrallel-Old收集器" class="headerlink" title="2.5.5 Parrallel Old收集器"></a>2.5.5 Parrallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<p><img src="/2021/04/16/java-virtual-machine/image-20210720172218650.png" alt="image-20210720172218650"></p>
<h3 id="2-5-6-CMS收集器"><a href="#2-5-6-CMS收集器" class="headerlink" title="2.5.6 CMS收集器"></a>2.5.6 CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为 关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非 常符合这类应用的需求。</p>
<p>基于标记-清除算法实现，整个过程分为四个步骤，包括： </p>
<p>1）初始标记（CMS initial mark） </p>
<p>2）并发标记（CMS concurrent mark） </p>
<p>3）重新标记（CMS remark） </p>
<p>4）并发清除（CMS concurrent sweep）</p>
<p><img src="/2021/04/16/java-virtual-machine/image-20210720172313424.png" alt="image-20210720172313424"></p>
<h3 id="2-5-7-Garbage-First收集器"><a href="#2-5-7-Garbage-First收集器" class="headerlink" title="2.5.7 Garbage First收集器"></a>2.5.7 Garbage First收集器</h3><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p><img src="/2021/04/16/java-virtual-machine/image-20210720172401674.png" alt="image-20210720172401674"></p>
<h3 id="2-5-8-Shenandoah收集器"><a href="#2-5-8-Shenandoah收集器" class="headerlink" title="2.5.8 Shenandoah收集器"></a>2.5.8 Shenandoah收集器</h3><h3 id="2-5-9-ZGC收集器"><a href="#2-5-9-ZGC收集器" class="headerlink" title="2.5.9 ZGC收集器"></a>2.5.9 ZGC收集器</h3><p>ZGC（“Z”并非什么专业名词的缩写，这款收集器的名字就叫作Z Garbage Collector）是一款在JDK 11中新加入的具有实验性质[1]的低延迟垃圾收集器</p>
<h2 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h2><ul>
<li><p>对象有现在Eden（新生代）分配</p>
</li>
<li><p>大对象直接进入老生代</p>
</li>
<li><p>长期存活的对象进入老生代</p>
</li>
</ul>
<h1 id="3-类文件结构"><a href="#3-类文件结构" class="headerlink" title="3. 类文件结构"></a>3. 类文件结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割 成若干个8个字节进行存储。</p>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>learn</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>k6测试工具的使用</title>
    <url>/2021/05/28/k6-tool-usage/</url>
    <content><![CDATA[<img src="/2021/05/28/k6-tool-usage/k6.png" alt="image-20210528154113942" style="zoom: 67%;">

<a id="more"></a>



<h1 id="1-What-is-K6"><a href="#1-What-is-K6" class="headerlink" title="1. What is K6?"></a>1. What is K6?</h1><ul>
<li>什么是K6？</li>
</ul>
<p>K6是由LoadImpact公司提供的开源工具，该工具已经被微软、亚马逊等公司用于<strong>负载测试</strong>。</p>
<ul>
<li>K6 能用来做什么？</li>
</ul>
<p>K6提供了丰富的脚本API用于描述测试负载，比如可以设置虚拟用户数量来测试不同并发情况下Web应用的性能，还可以设置测试的请求头来定义K6发出的请求。</p>
<p>K6用虚拟用户（Virtual User，VU）模拟真实用户，并通过改变并发的虚拟用户数量来改变系统的负载情况。虚拟用户的本质是线程，每个虚拟用户都在一个完全独立的JavaScript虚拟机中执行测试脚本。</p>
<ul>
<li><p>如何使用？</p>
<ul>
<li><strong>安装</strong></li>
<li><strong>编写</strong></li>
<li><strong>运行</strong></li>
</ul>
</li>
</ul>
<h1 id="2-Installation"><a href="#2-Installation" class="headerlink" title="2. Installation"></a>2. Installation</h1><p>下面介绍 <code>Ubuntu</code> 环境下的<a href="https://k6.io/docs/getting-started/installation/">安装过程</a></p>
<blockquote>
<p>有些镜像并没有捆绑ca-certificates和gnupg2软件包。如果你正在使用这样的镜像，首先需要用下面的命令安装这些软件包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;$ sudo apt-get update &amp;&amp; sudo apt-get install ca-certificates gnupg2 -y</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;deb https://dl.k6.io/deb stable main&quot;</span> | sudo tee /etc/apt/sources.list.d/k6.list</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install k6</span><br></pre></td></tr></table></figure>




<h1 id="3-Running-K6"><a href="#3-Running-K6" class="headerlink" title="3. Running K6"></a>3. Running K6</h1><ul>
<li>编写k6脚本</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&quot;k6/http&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; check, sleep &#125; <span class="keyword">from</span> <span class="string">&quot;k6&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试场景</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> options = &#123;</span><br><span class="line">    duration: <span class="string">&#x27;30s&#x27;</span>,</span><br><span class="line">    vus: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> urls = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">    urls[<span class="number">0</span>] =<span class="string">&quot;http://141.164.39.46:8080/v1/AUTH_753ac424b8104a489b6e69b63b53f7f7/test/1000kbh&quot;</span></span><br><span class="line">    urls[<span class="number">1</span>] =<span class="string">&quot;http://141.164.39.46:8080/v1/AUTH_753ac424b8104a489b6e69b63b53f7f7/test/1000kbc&quot;</span></span><br><span class="line">    urls[<span class="number">2</span>] =<span class="string">&quot;http://141.164.39.46:8080/v1/AUTH_753ac424b8104a489b6e69b63b53f7f7/test/1000kbg&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ndp_url = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    ndp_url[<span class="number">0</span>]=<span class="string">&quot;http://141.164.57.128:7979&quot;</span></span><br><span class="line">    ndp_url[<span class="number">1</span>]=<span class="string">&quot;http://158.247.207.170:7979&quot;</span></span><br><span class="line">    ndp_url[<span class="number">2</span>]=<span class="string">&quot;http://158.247.220.151:7979&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加头部信息</span></span><br><span class="line">    <span class="keyword">var</span> params = &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&quot;X-Auth-Token&quot;</span>: <span class="string">&quot;gAAAAABgr4RQp5xptJ81ivP-oL0Cyr8P3_ePyixGjOK3sSAgVr4CaXupZJi7SRYwFKJZXSG3ZcCyGKM8Q7RhqPEZBHCvxA3OBAyu1Dl7nbiyfaSBMYYjUIosc7jpOl5FTtdPhPRL6ocR8eQ3MYbhCNWRg3xUn7VMF7fehdDxZzxS_DjrWQTWobU&quot;</span>,</span><br><span class="line">            <span class="string">&quot;x-webhook&quot;</span>: ndp_url[index]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = http.get(urls[index], params);</span><br><span class="line">    check(res, &#123;</span><br><span class="line">        <span class="string">&quot;status was 200&quot;</span>: <span class="function">(<span class="params">r</span>) =&gt;</span> r.status == <span class="number">200</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>运行测试脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ k6 run test.js</span><br></pre></td></tr></table></figure>



<h1 id="4-Result-Output"><a href="#4-Result-Output" class="headerlink" title="4. Result Output"></a>4. Result Output</h1><p>k6 可以控制结果的输出位置和格式，以CSV格式举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ k6 run --out csv=my_test_result.csv script.js</span><br></pre></td></tr></table></figure>

<p>更多的输出信息可以查看K6的官方文档：<a href="https://k6.io/docs/results-visualization/">Results visualization (k6.io)</a></p>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>network</tag>
        <tag>k6</tag>
      </tags>
  </entry>
  <entry>
    <title>在国内使用Kubespray搭建Kubernetes集群</title>
    <url>/2020/08/08/k8s-deploy/</url>
    <content><![CDATA[<img src="/2020/08/08/k8s-deploy/k8s.png" alt="image-20210528160938569" style="zoom: 33%;">

<a id="more"></a>



<h1 id="1-Before-Install"><a href="#1-Before-Install" class="headerlink" title="1. Before Install"></a>1. Before Install</h1><h2 id="1-1-虚拟机准备"><a href="#1-1-虚拟机准备" class="headerlink" title="1.1 虚拟机准备"></a>1.1 虚拟机准备</h2><p>本例涉及5个节点，使用kubespray-2.12.7搭建2个master节点和2个node节点的kubernetes集群，其中node0作为ansible的控制节点，node1-node4是受控节点。</p>
<p>操作系统选用<strong>ubuntu18.04</strong>，且以下所有操作都是以<font color="red" size="5"><strong>root</strong></font>用户进行的</p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>角色</th>
<th>ip地址</th>
</tr>
</thead>
<tbody><tr>
<td>node0</td>
<td>controller</td>
<td>192.168.0.2</td>
</tr>
<tr>
<td>node1</td>
<td>kube-master</td>
<td>192.168.0.3</td>
</tr>
<tr>
<td>node2</td>
<td>kube-master</td>
<td>192.168.0.4</td>
</tr>
<tr>
<td>node3</td>
<td>kube-node</td>
<td>192.168.0.5</td>
</tr>
<tr>
<td>node4</td>
<td>kube-node</td>
<td>192.168.0.6</td>
</tr>
</tbody></table>
<h2 id="1-2-镜像准备"><a href="#1-2-镜像准备" class="headerlink" title="1.2 镜像准备"></a>1.2 镜像准备</h2><ul>
<li>在国外租一台服务器，下载谷歌镜像并推送到阿里云镜像仓库，脚本push_img.sh内容如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry_prefix=<span class="string">&quot;registry.ap-northeast-1.aliyuncs.com/google-containers-lpz/&quot;</span></span><br><span class="line"></span><br><span class="line">google_images=(</span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/kube-proxy:v1.16.11&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/kube-controller-manager:v1.16.11&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/kube-scheduler:v1.16.11&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/kube-apiserver:v1.16.11&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/k8s-dns-node-cache:1.15.8&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/cluster-proportional-autoscaler-amd64:1.6.0&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google-containers/pause:3.1&quot;</span></span><br><span class="line">    <span class="string">&quot;gcr.io/google_containers/pause-amd64:3.1&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> images <span class="keyword">in</span> <span class="variable">$&#123;google_images[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#截取镜像地址的最后一段</span></span><br><span class="line">container_name=(<span class="variable">$&#123;images//\// &#125;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#拉取镜像并推送到阿里云的镜像仓库</span></span><br><span class="line">sudo docker pull <span class="variable">$images</span></span><br><span class="line">sudo docker tag <span class="variable">$images</span> <span class="variable">$registry_prefix</span><span class="variable">$&#123;container_name[2]&#125;</span></span><br><span class="line">sudo docker push <span class="variable">$registry_prefix</span><span class="variable">$&#123;container_name[2]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以下文件推送到本地FTP服务器：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.16.11/bin/linux/amd64/kubelet</span><br><span class="line"></span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.16.11/bin/linux/amd64/kubectl</span><br><span class="line"></span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.16.11/bin/linux/amd64/kubeadm</span><br><span class="line"></span><br><span class="line">https://github.com/coreos/etcd/releases/download/v3.3.12/etcd-v3.3.12-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni-plugins-linux-amd64-v0.8.6.tgz</span><br><span class="line"></span><br><span class="line">https://github.com/projectcalico/calicoctl/releases/download/v3.7.3/calicoctl-linux-amd64</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="1-4-镜像修改"><a href="#1-4-镜像修改" class="headerlink" title="1.4 镜像修改"></a>1.4 镜像修改</h2><ul>
<li>修改kubespray-2.12.7/roles/download/defaults/main.yml</li>
</ul>
<blockquote>
<p>由于dashboard-1.10.1和kubernetesv1.16不兼容，需要将dashboard的镜像地址修改为kubernetesui/dashboard:v2.0.0-beta8</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gcr_image_repo: &quot;gcr.io&quot;</span></span><br><span class="line">-&gt; gcr_image_repo: <span class="string">&quot;registry.ap-northeast-1.aliyuncs.com&quot;</span></span><br><span class="line"><span class="comment">#kube_image_repo: &quot;&#123;&#123; gcr_image_repo &#125;&#125;/google-containers&quot;</span></span><br><span class="line">-&gt; kube_image_repo: <span class="string">&quot;&#123;&#123; gcr_image_repo &#125;&#125;/google-containers-lpz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pod_infra_image_repo: &quot;&#123;&#123; gcr_image_repo &#125;&#125;/google_containers/pause-&#123;&#123; image_arch &#125;&#125;&quot;</span></span><br><span class="line">-&gt; pod_infra_image_repo: <span class="string">&quot;&#123;&#123; kube_image_repo &#125;&#125;/pause-&#123;&#123; image_arch &#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#dashboard_image_repo: &quot;&#123;&#123; gcr_image_repo &#125;&#125;/google_containers/kubernetes-dashboard-&#123;&#123; image_arch &#125;&#125;&quot;</span></span><br><span class="line">-&gt; dashboard_image_repo: <span class="string">&quot;kubernetesui/dashboard&quot;</span></span><br><span class="line"><span class="comment">#dashboard_image_tag: &quot;xxx&quot;</span></span><br><span class="line">-&gt; dashboard_image_tag: <span class="string">&quot;v2.0.0-beta8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新增ftp服务器地址</span></span><br><span class="line">-&gt; ftp_url: ftp://192.168.0.2</span><br><span class="line"><span class="comment">#kubelet_download_url: &quot;https://storage.googleapis.com/kubernetes-release/release/&#123;&#123; kube_version &#125;&#125;/bin/linux/&#123;&#123; image_arch &#125;&#125;/kubelet&quot;</span></span><br><span class="line">-&gt; kubelet_download_url: <span class="string">&quot;&#123;&#123; ftp_url &#125;&#125;/kubelet&quot;</span></span><br><span class="line"><span class="comment">#kubectl_download_url: &quot;https://storage.googleapis.com/kubernetes-release/release/&#123;&#123; kube_version &#125;&#125;/bin/linux/&#123;&#123; image_arch &#125;&#125;/kubectl&quot;</span></span><br><span class="line">-&gt; kubectl_download_url: <span class="string">&quot;&#123;&#123; ftp_url &#125;&#125;/kubectl&quot;</span></span><br><span class="line"><span class="comment">#kubeadm_download_url: &quot;https://storage.googleapis.com/kubernetes-release/release/&#123;&#123; kubeadm_version &#125;&#125;/bin/linux/&#123;&#123; image_arch &#125;&#125;/kubeadm&quot;</span></span><br><span class="line">-&gt; kubeadm_download_url: <span class="string">&quot;&#123;&#123; ftp_url &#125;&#125;/kubeadm&quot;</span></span><br><span class="line">etc<span class="comment">#d_download_url: &quot;https://github.com/coreos/etcd/releases/download/&#123;&#123; etcd_version &#125;&#125;/etcd-&#123;&#123; etcd_version &#125;&#125;-linux-&#123;&#123; image_arch &#125;&#125;.tar.gz&quot;</span></span><br><span class="line">-&gt; etcd_download_url: <span class="string">&quot;&#123;&#123; ftp_url &#125;&#125;/etcd-v3.3.12-linux-amd64.tar.gz&quot;</span></span><br><span class="line"><span class="comment">#cni_download_url: &quot;https://github.com/containernetworking/plugins/releases/download/&#123;&#123; cni_version &#125;&#125;/cni-plugins-linux-&#123;&#123; image_arch &#125;&#125;-&#123;&#123; cni_version &#125;&#125;.tgz&quot;</span></span><br><span class="line">-&gt; cni_download_url: <span class="string">&quot;&#123;&#123; ftp_url &#125;&#125;/cni-plugins-linux-amd64-v0.8.6.tgz&quot;</span></span><br><span class="line"><span class="comment">#calicoctl_download_url: &quot;https://github.com/projectcalico/calicoctl/releases/download/&#123;&#123; calico_ctl_version &#125;&#125;/calicoctl-linux-&#123;&#123; image_arch &#125;&#125;&quot;</span></span><br><span class="line">-&gt; calicoctl_download_url: <span class="string">&quot;&#123;&#123; ftp_url &#125;&#125;/calicoctl-linux-amd64&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>修改kubespray-2.12.7/inventory/sample/group_vars/k8s-cluster/k8s-cluster.yml<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#kube_image_repo: &quot;&#123;&#123; gcr_image_repo &#125;&#125;/google-containers&quot;</span></span><br><span class="line">-&gt; kube_image_repo: <span class="string">&quot;&#123;&#123; gcr_image_repo &#125;&#125;/google-containers-lpz&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="2-Installation"><a href="#2-Installation" class="headerlink" title="2. Installation"></a>2. Installation</h1><h2 id="2-1-docker的安装和配置"><a href="#2-1-docker的安装和配置" class="headerlink" title="2.1 docker的安装和配置"></a>2.1 docker的安装和配置</h2><h3 id="2-1-1-安装指定版本的docker"><a href="#2-1-1-安装指定版本的docker" class="headerlink" title="2.1.1 安装指定版本的docker"></a>2.1.1 安装指定版本的docker</h3><p>提前下载docker，配置阿里云镜像加速器，以从阿里云镜像仓库拉取镜像。</p>
<blockquote>
<p>kubespray-2.12.7对应的docker版本为 <strong>docker-ce=5:18.09.7<del>3-0</del>ubuntu-bionic</strong></p>
</blockquote>
<ul>
<li>添加Docker官方的GPG密钥<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li>
<li>设置statble存储库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> </span><br></pre></td></tr></table></figure></li>
<li>安装docker-ce=5:18.09.7<del>3-0</del>ubuntu-bionic<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y docker-ce=5:18.09.7~3-0~ubuntu-bionic</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-1-2-配置docker镜像加速器"><a href="#2-1-2-配置docker镜像加速器" class="headerlink" title="2.1.2 配置docker镜像加速器"></a>2.1.2 配置docker镜像加速器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://htdsx47m.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="2-2-使用Kubespray部署Kubernetes集群"><a href="#2-2-使用Kubespray部署Kubernetes集群" class="headerlink" title="2.2 使用Kubespray部署Kubernetes集群"></a>2.2 使用Kubespray部署Kubernetes集群</h2><h3 id="2-2-1-配置控制节点对其他节点的SSH免密登录"><a href="#2-2-1-配置控制节点对其他节点的SSH免密登录" class="headerlink" title="2.2.1 配置控制节点对其他节点的SSH免密登录"></a>2.2.1 配置控制节点对其他节点的SSH免密登录</h3><ul>
<li>在controller节点生成密钥对(位于~/.ssh/)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<ul>
<li>将公钥上传到其他节点</li>
</ul>
<blockquote>
<p>在上传之前要确保节点的ssh允许root用户登录和密码登录（PermitRootLogin和PasswordAuthentication字段为yes）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub root@192.168.0.3</span><br><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub root@192.168.0.4</span><br><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub root@192.168.0.5</span><br><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub root@192.168.0.6</span><br></pre></td></tr></table></figure>
<ul>
<li>验证是否成功,如果可以直接登录则成功<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ubuntu@192.168.0.3</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2-2-2在控制节点上下载、安装kubepray"><a href="#2-2-2在控制节点上下载、安装kubepray" class="headerlink" title="2.2.2在控制节点上下载、安装kubepray"></a>2.2.2在控制节点上下载、安装kubepray</h3><ul>
<li>安装pip3<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y python3-pip</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>配置pip3加速<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/.pip</span><br><span class="line">$ cat &gt; ~/.pip/pip.conf &lt;&lt; EOF</span><br><span class="line">[global]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>下载kubespray并解压<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;kubespray&#x2F;archive&#x2F;v2.12.7.zip</span><br><span class="line">$ unzip v2.12.7.zip</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>安装kubespray，部署kubernetes<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd kubespray-2.12.7&#x2F;</span><br><span class="line">$ sudo pip3 install -r requirements.txt</span><br><span class="line">$ cp -rfp inventory&#x2F;sample inventory&#x2F;mycluster</span><br><span class="line">$ declare -a IPS&#x3D;(192.168.0.3 192.168.0.4 192.168.0.5 192.168.0.6)</span><br><span class="line">$ CONFIG_FILE&#x3D;inventory&#x2F;mycluster&#x2F;hosts.yaml python3 contrib&#x2F;inventory_builder&#x2F;inventory.py $&#123;IPS[@]&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>修改hosts.ini的内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi inventory/mycluster/hosts.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>最后，执行安装过程。ansible用到的python为python2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml</span><br></pre></td></tr></table></figure>




<blockquote>
<p>Reference ：</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>kubernetes</tag>
        <tag>kubespray</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 kubeless python 运行时Http请求大小限制</title>
    <url>/2020/10/08/kubeless-runtime-modify/</url>
    <content><![CDATA[<img src="/2020/10/08/kubeless-runtime-modify/kubeless-bg.png" alt="image-20210528183518528" style="zoom: 33%;">

<a id="more"></a>



<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h1><ul>
<li>kubeless-v1.0.7</li>
<li>kubeless runtime: python3.7</li>
</ul>
<p>在向kubeless无服务计算框架发送http请求时，如果http的请求实体过大，kubeless会报’413 Request Entity Too Large’的错误。</p>
<p>使用的kubeless runtime为python3.7，主要原因runtime是基于bottle web框架进行构建的，而python bottle模块对请求体的大小进行了限制，解决方案也很简单：基于现有的python3.7 runtime进行修改，并重新制作成镜像，替换掉原来的python3.7 runtime.</p>
<h1 id="2-Python3-7-Runtime修改"><a href="#2-Python3-7-Runtime修改" class="headerlink" title="2. Python3.7 Runtime修改"></a>2. Python3.7 Runtime修改</h1><ul>
<li>向kubeless python3.7 runtime文件——kubeless.py中添加如下内容：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改请求的大小限制</span></span><br><span class="line">bottle.BaseRequest.MEMFILE_MAX = <span class="number">1024</span> * <span class="number">1024</span> <span class="comment"># (or whatever you want)</span></span><br></pre></td></tr></table></figure>



<h1 id="3-制作镜像"><a href="#3-制作镜像" class="headerlink" title="3. 制作镜像"></a>3. 制作镜像</h1><ul>
<li>Dockerfile的内容</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> bitnami/minideb-runtimes:stretch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install required system packages and dependencies</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> install_packages build-essential ca-certificates curl git libbz2-1.0 libc6 libffi6 libncurses5 libreadline7 libsqlite3-0 libssl1.1 libtinfo5 pkg-config unzip wget zlib1g</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -nc -P /tmp/bitnami/pkg/cache/ https://downloads.bitnami.com/files/stacksmith/python-3.7.1-0-linux-amd64-debian-9.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;4f1a47dc398b6942d328662b5a7719358fb7788afc746b0e4935ffb165140596  /tmp/bitnami/pkg/cache/python-3.7.1-0-linux-amd64-debian-9.tar.gz&quot;</span> | sha256sum -c - &amp;&amp; \</span></span><br><span class="line"><span class="bash">    tar -zxf /tmp/bitnami/pkg/cache/python-3.7.1-0-linux-amd64-debian-9.tar.gz -P --transform <span class="string">&#x27;s|^[^/]*/files|/opt/bitnami|&#x27;</span> --wildcards <span class="string">&#x27;*/files&#x27;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -rf /tmp/bitnami/pkg/cache/python-3.7.1-0-linux-amd64-debian-9.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> BITNAMI_APP_NAME=<span class="string">&quot;python&quot;</span> \</span><br><span class="line">    BITNAMI_IMAGE_VERSION=<span class="string">&quot;3.7.1-r0&quot;</span> \</span><br><span class="line">    PATH=<span class="string">&quot;/opt/bitnami/python/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl https://bootstrap.pypa.io/get-pip.py --output get-pip.py</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python ./get-pip.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install bottle==0.12.13 cherrypy==8.9.1 wsgi-request-logger prometheus_client requests</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /</span></span><br><span class="line"><span class="comment"># 修改了kubeless.py的文件内容</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> kubeless.py .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/kubeless.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<ul>
<li>根据Dockerfile创建镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t mykubeless/python37:debug .</span><br></pre></td></tr></table></figure>



<h1 id="4-替换镜像"><a href="#4-替换镜像" class="headerlink" title="4. 替换镜像"></a>4. 替换镜像</h1><p>修改kubeless的安装文件，将python3.7的runtime镜像替换为自己的runtime镜像。文件地址为：</p>
<p><a href="https://github.com/kubeless/kubeless/releases/download/v1.0.7/kubeless-v1.0.7.yaml">https://github.com/kubeless/kubeless/releases/download/v1.0.7/kubeless-v1.0.7.yaml</a></p>
<blockquote>
<p>Reference</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>docker</tag>
        <tag>web</tag>
        <tag>kubeless</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes dashboard 的登录配置</title>
    <url>/2020/09/22/kubernetes-dashboard-login/</url>
    <content><![CDATA[<img src="/2020/09/22/kubernetes-dashboard-login/login.png" alt="kubernetes-dashboard-login" style="zoom: 67%;">

<a id="more"></a>



<h1 id="1-kubernetes-dashboard"><a href="#1-kubernetes-dashboard" class="headerlink" title="1. kubernetes dashboard"></a>1. kubernetes dashboard</h1><p>kubernetes dashboard提供了两种登录方式：</p>
<ul>
<li>kubeconfig</li>
<li>令牌 </li>
</ul>
<p>下面将对这两种登录方式进行介绍。   </p>
<!--more-->

<table>
<thead>
<tr>
<th align="center"><img src="/2020/09/22/kubernetes-dashboard-login/login.png" alt="kubernetes-dashboard-login"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">图1-1 kubernetes dashboard的登录界面</td>
</tr>
</tbody></table>
<h2 id="1-1-令牌登录"><a href="#1-1-令牌登录" class="headerlink" title="1.1 令牌登录"></a>1.1 令牌登录</h2><p>令牌登录就是使用serviceAccount账户的token值登录，在kubernetes中，每个serviceAccount(简称sa)账户都对应一个token值，我们就可以使用该值进行登录。需要注意的是，使用token登录只具有view权限，不能在dashboard中删除或创建pod。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###############################################</span></span><br><span class="line"><span class="comment"># 查看sa账户</span></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">$ kubectl get sa</span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         38d</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line"><span class="comment"># 获取详细的sa账户信息</span></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">$ kubectl describe sa default</span><br><span class="line">Name:                default</span><br><span class="line">Namespace:           default</span><br><span class="line">Labels:              &lt;none&gt;</span><br><span class="line">Annotations:         &lt;none&gt;</span><br><span class="line">Image pull secrets:  &lt;none&gt;</span><br><span class="line">Mountable secrets:   default-token-j27f2</span><br><span class="line">Tokens:              default-token-j27f2</span><br><span class="line">Events:              &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line"><span class="comment"># 获取sa账户的token</span></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">$ kubectl describe secret default-token-j27f2 | awk <span class="string">&#x27;$1==&quot;token:&quot;&#123;print $2&#125;&#x27;</span></span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6ImVUYzFjVUhDeUJqeXNzcnpJUEpfaGpWVnhyOS1TVXV2REZEYjBTazA3NzAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tajI3ZjIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImFjOWE3NjY1LTk3ZmEtNDk1MC05NjBlLTIxNThkNWFiOWMwYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.IJYDGgXRrH--GRiiz2P18RyozsjvIsLIwxVO7azfCUPkjeyjSIwbUrlH75Uxo3LXrQvvSKMKnJOyPovQ7K_zV3Ot0ufjjsoM3IZe3LZllr09JR70AvJkdckXjRnK7QeKoZRJNVKQt45emRCd9PKCbc8m8u3pianRwJWlPBXCTa-uyxWbsgoKXJXBD2HvgkphPDTLKjYQKPvvh6nSs2vfvX2MPaG98njY6F27W-1YFchgo_df3rFS-SoMlXVlizJsjOV-vr1Kye6EFGBI33fHXFCkCxaHE2cpmFtD_bbHZEHK8BdPXT5a5ER19ODlbtPZ8r3ngk8eWqpaSebHv2wWIg</span><br></pre></td></tr></table></figure>



<h2 id="1-2-kubeconfig登录"><a href="#1-2-kubeconfig登录" class="headerlink" title="1.2 kubeconfig登录"></a>1.2 kubeconfig登录</h2><p>kubeconfig文件就是kubect登录使用的验证文件， 一般位于~/.kube/config。如果没有的话需要使用kubectl config命令生成，这里不再详细介绍。</p>
<ul>
<li><p>获取kubeconfig文件内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">config</span> <span class="string">view</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">DATA+OMITTED</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://192.168.0.3:6443</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">cluster.local</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-admin@cluster.local</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kubernetes-admin@cluster.local</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">REDACTED</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>获取sa账户token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###############################################</span></span><br><span class="line"><span class="comment"># 查看sa账户</span></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">$ kubectl get sa</span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         38d</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line"><span class="comment"># 查看default账户的secret</span></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line">$ kubectl describe secret default | awk <span class="string">&#x27;$1==&quot;token:&quot;&#123;print $2&#125;&#x27;</span></span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6ImVUYzFjVUhDeUJqeXNzcnpJUEpfaGpWVnhyOS1TVXV2REZEYjBTazA3NzAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tajI3ZjIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImFjOWE3NjY1LTk3ZmEtNDk1MC05NjBlLTIxNThkNWFiOWMwYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.IJYDGgXRrH--GRiiz2P18RyozsjvIsLIwxVO7azfCUPkjeyjSIwbUrlH75Uxo3LXrQvvSKMKnJOyPovQ7K_zV3Ot0ufjjsoM3IZe3LZllr09JR70AvJkdckXjRnK7QeKoZRJNVKQt45emRCd9PKCbc8m8u3pianRwJWlPBXCTa-uyxWbsgoKXJXBD2HvgkphPDTLKjYQKPvvh6nSs2vfvX2MPaG98njY6F27W-1YFchgo_df3rFS-SoMlXVlizJsjOV-vr1Kye6EFGBI33fHXFCkCxaHE2cpmFtD_bbHZEHK8BdPXT5a5ER19ODlbtPZ8r3ngk8eWqpaSebHv2wWIg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>向kubeconfig文件中添加token</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">DATA+OMITTED</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://192.168.0.3:6443</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">cluster.local</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-admin@cluster.local</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kubernetes-admin@cluster.local</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">eyJhbGciOiJSUzI1NiIsImtpZCI6ImVUYzFjVUhDeUJqeXNzcnpJUEpfaGpWVnhyOS1TVXV2REZEYjBTazA3NzAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkZWZhdWx0LXRva2VuLTJnNTZ6Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImRlZmF1bHQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI3M2M1NjI1Yi1mYWJkLTQzZTUtYjY5Ny0yMWY4MDQ2MDg2YTUiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06ZGVmYXVsdCJ9.Oh9HH5n2QswxakCiBalXyg71P2VMv_CG5NMjmFyK6Fj_gVnUxsIRGNV3z08QMMVE-d3ZyWP-N8xL-MX2aFyoxV4XwjcJh0c8WYMdVdTQzDBJoAf7x9xbI2faduMIrb1c2WgbF74PMRS8yufR3WlSERySDgWWJnhyLvdiNN0HNoS2J2o72AounyXOD5O0GLiKSZujAUV7HH_6pLZ_W6bGlJjMzma68OLlN5sWoikAhHP1MdbwBVpPbMhnl5cbP4rg5Hs_cMr6Wlhw9j2Mi7CGnYI3JVop23ESwoAJmqNX-5ANQ6015KVBmP7_l9_qIikVSCtP9cTErK9gqXQD90YQ3g</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>角色绑定（如果不执行登录后会提示权限不足），即将sa和role进行绑定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=default:default</span><br></pre></td></tr></table></figure>

<ul>
<li>使用kubeconfig文件进行登录</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>最后贴一下kubernetes dashboard的部署文件（基于kubernetesui/dashboard:v2.0.0-beta8）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright 2017 The Kubernetes Authors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configuration to deploy release version of the Dashboard UI compatible with</span></span><br><span class="line"><span class="comment"># Kubernetes 1.8.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example usage: kubectl create -f &lt;this_file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Secrets ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-csrf</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">csrf:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-key-holder</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard ConfigMap ------------------- #</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-settings</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Service Account ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Role &amp; Role Binding ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get, update and delete Dashboard exclusive secrets.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span> [<span class="string">&quot;kubernetes-dashboard-key-holder&quot;</span>, <span class="string">&quot;kubernetes-dashboard-certs&quot;</span>, <span class="string">&quot;kubernetes-dashboard-csrf&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">  <span class="comment"># Allow Dashboard to get and update &#x27;kubernetes-dashboard-settings&#x27; config map.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;configmaps&quot;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span> [<span class="string">&quot;kubernetes-dashboard-settings&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  <span class="comment"># Allow Dashboard to get metrics from heapster.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;services&quot;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span> [<span class="string">&quot;heapster&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;proxy&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;services/proxy&quot;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span> [<span class="string">&quot;heapster&quot;</span>, <span class="string">&quot;http:heapster:&quot;</span>, <span class="string">&quot;https:heapster:&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Gross Hack For anonymous auth through api proxy ------------------- #</span></span><br><span class="line"><span class="comment"># Allows users to reach login page and other proxied dashboard URLs</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-anonymous</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;services/proxy&quot;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span> [<span class="string">&quot;https:kubernetes-dashboard:&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">nonResourceURLs:</span> [<span class="string">&quot;/ui&quot;</span>, <span class="string">&quot;/ui/*&quot;</span>, <span class="string">&quot;/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/*&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-anonymous</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-anonymous</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:anonymous</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Deployment ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">kubernetesui/dashboard:v2.0.0-beta8</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">256M</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">64M</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--auto-generate-certificates</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--authentication-mode=token</span>          <span class="comment"># Uncomment the following line to manually specify Kubernetes API server Host</span></span><br><span class="line">          <span class="comment"># If not specified, Dashboard will attempt to auto discover the API server and connect</span></span><br><span class="line">          <span class="comment"># to it. Uncomment only if the default does not work.</span></span><br><span class="line">          <span class="comment"># - --apiserver-host=http://my-address:port</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--token-ttl=900</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/certs</span></span><br><span class="line">          <span class="comment"># Create on-disk volume to store exec logs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">        <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Service ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30012</span>      <span class="comment"># 节点的端口</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>kubernetes</tag>
        <tag>dashboard</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊本地事务</title>
    <url>/2021/09/15/local-transaction/</url>
    <content><![CDATA[<img src="/2021/09/15/local-transaction/diagram-product-feature-acid-transactions-acronym.svg" alt="Diagram Product Feature Acid Transactions Acronym">

<a id="more"></a>

<p>本地事务，是相对于全局事务来说的，适用于单个服务使用单个数据源的场景，简单理解就是单机环境下的事务。</p>
<h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><p>事务的四大特性大家已经耳熟能详了，回顾一下，事务拥有4个特性：ACID</p>
<ul>
<li>原子性（Atomic）：同一个事务的多个操作，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务前后的数据完整性必须保持一致。</li>
<li>隔离性（Isolation）：事务之间不能相互影响。</li>
<li>持久性（Durability）：事务一旦被提交，数据修改都能够正确的被持久化，不会丢失。</li>
</ul>
<p>多提一句，ACID中的C是最终目的，A、I、D是手段，C的实现需要依靠AID来保证。</p>
<p>在实际开发过程中，本地事务的ACID特性由数据库保证。那么，数据库是如何进行保证的呢？</p>
<h1 id="1-保证原子性和持久性——日志"><a href="#1-保证原子性和持久性——日志" class="headerlink" title="1. 保证原子性和持久性——日志"></a>1. 保证原子性和持久性——日志</h1><h2 id="1-1-不容忽视的问题——系统崩溃"><a href="#1-1-不容忽视的问题——系统崩溃" class="headerlink" title="1.1 不容忽视的问题——系统崩溃"></a>1.1 不容忽视的问题——系统崩溃</h2><p>原子性和持久性是事务最密切相关的两个特性。</p>
<p>原子性保证了事务的多个操作要么全部成功，要么全部失败，不存在中间状态。</p>
<p>持久性保证了事务一旦被提交，修改的数据不会丢失。</p>
<p>我们知道，数据一开始是保存在内存中的，而内存中的数据在系统崩溃后会丢失，只有当数据写入到持久化设备后才能实现持久性。</p>
<p>但是实现原子性和持久性的难点在于<strong>数据写入的操作不具备原子性</strong>，不仅存在写入和未写入两种状态，还存在正在写的中间状态，所以如果不采取一些措施，将内存中的数据写入持久化设备不能保证原子性和持久性。</p>
<p>具体而言，数据的写入过程可能发生以下情形：</p>
<ul>
<li><strong>未提交事务，写入后崩溃</strong>：程序还未修改完所有数据，但部分已修改的数据被写入磁盘，此时出现崩溃，事务执行失败，需要在系统恢复后将已写入的部分数据恢复为事务执行前的状态。</li>
<li><strong>已提交事务，写入前崩溃</strong>：程序已经修改完数据，但数据还未写入磁盘，此时出现崩溃，由于事务已提交，需要在系统恢复后将数据写入磁盘。</li>
</ul>
<h2 id="1-2-补救措施——崩溃恢复"><a href="#1-2-补救措施——崩溃恢复" class="headerlink" title="1.2 补救措施——崩溃恢复"></a>1.2 补救措施——崩溃恢复</h2><p>为了保证原子性和持久性，需要在系统崩溃后采用补救措施，有两种方式：提交日志，以及影子分页；</p>
<h3 id="提交日志（Commit-Logging）"><a href="#提交日志（Commit-Logging）" class="headerlink" title="提交日志（Commit Logging）"></a>提交日志（Commit Logging）</h3><p>事务提交前，写入提交记录，记录将要执行的操作；</p>
<p>事务提交后，写入结束记录，表示事务已完成持久化。</p>
<h3 id="影子分页（Shadow-Paging）"><a href="#影子分页（Shadow-Paging）" class="headerlink" title="影子分页（Shadow Paging）"></a>影子分页（Shadow Paging）</h3><p>对数据的变动会写入到磁盘中，写入过程是先对原数据进行复制，然后修改复制后的数据。当事务成功提交，修改数据的引用指针，将引用从原数据指向复制后的数据，由于”修改指针的操作“可以认为是原子操作，从硬件上保证了原子性和持久性。</p>
<p>由于影子分页实现并发能力相对优先，因此在高性能数据库中的应用不多。</p>
<h2 id="1-3-提交日志的不足"><a href="#1-3-提交日志的不足" class="headerlink" title="1.3 提交日志的不足"></a>1.3 提交日志的不足</h2><p>日志一旦写入Commit Record，那么整个事务就是成功的，即使在修改数据时崩溃了，重启后也可以根据日志进行重新写入，保证了持久性；</p>
<p>日志在写入Commit Record系统崩溃，那么系统重启后会看到一部分没有Commit Record的日志，此时将这部分日志标记为回滚状态即可，保证了原子性。</p>
<p>但是，Commit Logging存在一个<strong>致命问题</strong>，就是对数据的真实修改都发生在事务提交以后，那么在此之前即使磁盘I/O有足够空闲、即使修改的数据量很大、即使占用了大量缓冲区，也不能修改数据，对提升数据库的性能十分不利。</p>
<h2 id="1-4-改进方案——Write-Ahead-Logging"><a href="#1-4-改进方案——Write-Ahead-Logging" class="headerlink" title="1.4 改进方案——Write-Ahead Logging"></a>1.4 改进方案——Write-Ahead Logging</h2><p>为了解决Commit Logging的不足，IBM研究院发表了《ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging 》，提出“Write-Ahead Logging”日志方案。</p>
<p>“Write-Ahead Logging”日志方案允许在事务提交之前提前写入变动数据。按照事务提交时点为界，划分为FORCE和STEAL两类情况。</p>
<ul>
<li><strong>FORCE</strong>：事务提交后，要求变动数据必须同时完成写入成为FORCE，如果不强制变动数据必须同时完成写入则成为NO-FORCE。大多数据库采用NO-FORCE方案，因为只要有了日志，变动数据随时可以持久化，从优化I/O考虑，没必要强制数据写入立即执行。</li>
<li><strong>STEAL</strong>：事务提交前，允许变动数据提前写入成为STEAL，不允许成为NO-STEAL。从优化I/O考虑，允许数据提前写入，有利于利用空闲I/O资源以及节省数据缓冲区内存。</li>
</ul>
<p>按照这个分类，<strong>Commit Logging允许NO-FORCE，不允许STEAL。</strong></p>
<p><strong>Write-Ahead Logging允许NO-FORCE，允许STEAL。</strong></p>
<p>Write-Ahead Logging引入<strong>Undo Log</strong>，记录了修改了什么位置的什么数据，以便在事务回滚或崩溃恢复时根据Undo Log对提前写入的数据进行擦除。</p>
<p>与Undo Log相对应，此前记录的用于崩溃恢复时重演数据变动的日志被称为Redo Log。</p>
<img src="/2021/09/15/local-transaction/image-20210915160108948.png" alt="image-20210915160108948" style="zoom:50%;">

<h3 id="Write-Ahead-Logging崩溃恢复的执行流程"><a href="#Write-Ahead-Logging崩溃恢复的执行流程" class="headerlink" title="Write-Ahead Logging崩溃恢复的执行流程"></a>Write-Ahead Logging崩溃恢复的执行流程</h3><ul>
<li>分析阶段：从最后一次检查点开始扫描日志，找到所有没有End Record的事务，组成待恢复的事务集合。</li>
<li>重做阶段：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作为：找出所有包含 Commit Record 的日志，将这些日志修改的 数据写入磁盘，写入完成后在日志中增加一条 End Record，然后移除出待恢复事务集 合。</li>
<li>回滚阶段：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩 下的都是需要回滚的事务，它们被称为Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。</li>
</ul>
<h1 id="2-实现隔离性——锁"><a href="#2-实现隔离性——锁" class="headerlink" title="2. 实现隔离性——锁"></a>2. 实现隔离性——锁</h1><p>真实场景下，数据库的访问一定是并发的，自然就会出现同步问题，怎么办？</p>
<p>程序员的都知道，<strong>加锁</strong>就完事了。</p>
<p>在现代数据库中，均提供了以下三种锁：</p>
<ul>
<li>写锁（Write Lock，又称排他锁，eXclusive Lock，简写为X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，此时其他事务不能写入数据，也不能施加读锁。</li>
<li>读锁（Read Lock，又称共享锁，Shared Lock，简写为S-Lock）：多个事务可以同时对一个数据添加多个读锁，数据被加上读锁后就不能再被施加写锁。</li>
<li>范围锁（Range Lock）：对某个范围施加排他锁，这个范围内的数据不能被写入。</li>
</ul>
<h2 id="2-1-最高隔离级别——可串行化"><a href="#2-1-最高隔离级别——可串行化" class="headerlink" title="2.1 最高隔离级别——可串行化"></a>2.1 最高隔离级别——可串行化</h2><p>串行化访问提供了强度最高的隔离性，最直接的方式就是对事务所有读、写的数据全部加上读锁、写锁和范围锁。</p>
<p>但鱼和熊掌不可兼得，隔离程度越高，并发性能越低，现代数据库不考虑性能肯定是不行滴，因此有了次一级的隔离级别——可重复读。</p>
<h2 id="2-2-弱化幻读——可重复读"><a href="#2-2-弱化幻读——可重复读" class="headerlink" title="2.2 弱化幻读——可重复读"></a>2.2 弱化幻读——可重复读</h2><p>可重复读对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，不再施加范围锁。</p>
<p>那么，可重复读相对可串行化弱化了哪里呢？</p>
<p>没错，可重复读会出现<strong>幻读</strong>现象，它是指在事务执行过程中，两个完全相同的范围查询得到了不同的结果集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price &lt; <span class="number">100</span></span><br><span class="line"><span class="comment">/* 时间顺序：2，事务： T2 */</span> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books(<span class="keyword">name</span>,price) <span class="keyword">VALUES</span> (<span class="string">&#x27;深入理解Java虚拟机&#x27;</span>,<span class="number">90</span>) </span><br><span class="line"><span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>假如这条 SQL 语句在同一个事务中重复执行 了两次，且这两次执行之间恰好有另外一个事务在数据库插入了一本小于 100 元的书籍， 这是会被允许的，那这两次相同的查询就会得到不一样的结果，原因是可重复读没有范围锁来禁止在该范围内插入新的数据，这是一个事务受到其他事务影响，隔离性被破坏的表现。</p>
<blockquote>
<p>这里的介绍是以 ARIES 理论为讨论目标的，具体的数据库并不一定要完全 遵照着理论去实现。一个例子是MySQL/InnoDB 的默认隔离级别为 可重复读 ，但它在只读事务中可以完全避免幻读问题</p>
</blockquote>
<h2 id="2-3-弱化不可重复读——读已提交"><a href="#2-3-弱化不可重复读——读已提交" class="headerlink" title="2.3 弱化不可重复读——读已提交"></a>2.3 弱化不可重复读——读已提交</h2><p><code>可重复读</code>的下一个隔离级别是<code>读已提交</code>（Read Committed），<code>读已提交</code>对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。<code>读已提交</code>比<code>可重复读</code>弱化的地方在于<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads">不可重复读问题</a>（Non-Repeatable Reads），它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。譬如笔者想要获取 Fenix’s Bookstore 中《深入理解 Java 虚拟机》这本书的售价，同样执行了两条 SQL 语句，在此两条语句执行之间，恰好另外一个事务修改了这本书的价格，将书的价格从 90 元调整到了 110 元，如下 SQL 所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price = <span class="number">110</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="keyword">COMMIT</span>;			<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="keyword">COMMIT</span>;   				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure>

<p>如果隔离级别是<code>读已提交</code>，这两次重复执行的查询结果就会不一样，原因是<code>读已提交</code>的隔离级别缺乏贯穿整个事务周期的读锁，无法禁止读取过的数据发生变化，此时事务 T2 中的更新语句可以马上提交成功，这也是一个事务受到其他事务影响，隔离性被破坏的表现。假如隔离级别是<code>可重复读</code>的话，由于数据已被事务 T1 施加了读锁且读取后不会马上释放，所以事务 T2 无法获取到写锁，更新就会被阻塞，直至事务 T1 被提交或回滚后才能提交。</p>
<h2 id="2-4-弱化脏读——读未提交"><a href="#2-4-弱化脏读——读未提交" class="headerlink" title="2.4 弱化脏读——读未提交"></a>2.4 弱化脏读——读未提交</h2><p><code>读已提交</code>的下一个级别是<code>读未提交</code>（Read Uncommitted），<code>读未提交</code>对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。<code>读未提交</code>比<code>读已提交</code>弱化的地方在于<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads">脏读问题</a>（Dirty Reads），它是指在事务执行过程中，一个事务读取到了另一个事务未提交的数据。譬如笔者觉得《深入理解 Java 虚拟机》从 90 元涨价到 110 元是损害消费者利益的行为，又执行了一条更新语句把价格改回了 90 元，在提交事务之前，同事说这并不是随便涨价，而是印刷成本上升导致的，按 90 元卖要亏本，于是笔者随即回滚了事务，场景如下 SQL 所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/* 注意没有COMMIT */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price = <span class="number">90</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;					<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/* 这条SELECT模拟购书的操作的逻辑 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;			  				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;			  										<span class="comment">/* 时间顺序：4，事务： T2 */</span></span><br></pre></td></tr></table></figure>

<p>不过，在之前修改价格后，事务 T1 已经按 90 元的价格卖出了几本。原因是<code>读未提交</code>在数据上完全不加读锁，这反而令它能读到其他事务加了写锁的数据，即上述事务 T1 中两条查询语句得到的结果并不相同。如果你不能理解这句话中的“反而”二字，请再重读一次写锁的定义：写锁禁止其他事务施加读锁，而不是禁止事务读取数据，如果事务 T1 读取数据并不需要去加读锁的话，就会导致事务 T2 未提交的数据也马上就能被事务 T1 所读到。这同样是一个事务受到其他事务影响，隔离性被破坏的表现。假如隔离级别是<code>读已提交</code>的话，由于事务 T2 持有数据的写锁，所以事务 T1 的第二次查询就无法获得读锁，而<code>读已提交</code>级别是要求先加读锁后读数据的，因此 T1 中的查询就会被阻塞，直至事务 T2 被提交或者回滚后才能得到结果。</p>
<h2 id="2-5-乐观锁和悲观锁"><a href="#2-5-乐观锁和悲观锁" class="headerlink" title="2.5 乐观锁和悲观锁"></a>2.5 乐观锁和悲观锁</h2><p>前面介绍的加锁都属于悲观加锁策略，即认为如果不先做加锁再访问数据，就肯定会出现问题。</p>
<p>相对地，乐观加锁策略认为事务之间数据存在竞争是偶然情况，没有竞争才是普遍情况，这样就不应该在一开始就加锁，而是应当在出现竞争时再找补救措施。</p>
<p>没有必要迷信什么乐观锁要比悲观锁更快的说法，这纯粹看竞争的剧烈程度，<strong>如果竞争剧烈的话，乐观锁反而更慢</strong>。</p>
<blockquote>
<p>Reference:</p>
<p>[1] <a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>database</tag>
        <tag>transcation</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 和 windows 常用终端命令总结</title>
    <url>/2021/06/05/linux-windows/</url>
    <content><![CDATA[<img src="/2021/06/05/linux-windows/bg.jpg" alt="image-20210528160349306" style="zoom:50%;">

<a id="more"></a>



<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ul>
<li><code>XCOPY</code></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /S 递归拷贝（不包括空文件夹）</span></span><br><span class="line"><span class="comment"># /E 递归拷贝（包括空文件夹）</span></span><br><span class="line"><span class="comment"># /Y 确认覆盖</span></span><br><span class="line"><span class="variable">$</span> XCOPY <span class="string">&quot;E:\Album Test\public\*&quot;</span> <span class="string">&quot;D:\Programmes\nginx-1.18.0\html\&quot;</span> /S /Y</span><br></pre></td></tr></table></figure>

<ul>
<li><code>netstat</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr <span class="string">&quot;8080&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul>
<li><code>shell</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for循环，将script中的&#123;&#123;TARGET&#125;&#125;字段替换为$i</span></span><br><span class="line">i=10</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cp ./template/script.js ./script<span class="variable">$&#123;i&#125;</span>.js</span><br><span class="line">    sed -i <span class="string">&#x27;s/&#123;&#123;TARGET&#125;&#125;/&#x27;</span><span class="variable">$i</span><span class="string">&#x27;/g&#x27;</span> ./script<span class="variable">$&#123;i&#125;</span>.js</span><br><span class="line">    i=$(expr <span class="variable">$i</span> + 10)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># AND</span></span><br><span class="line">[ expression_1 ] &amp;&amp; [ expression_2 ]</span><br><span class="line">[ expression_1 ] AND [ expression_2 ]</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">[ expression_1 ] || [ expression_2 ]</span><br><span class="line">[ expression_1 ] OR [ expression_2 ]</span><br><span class="line"><span class="comment"># if语句</span></span><br><span class="line"><span class="keyword">if</span> [ expression_1 ] || [ expression_2 ];  </span><br><span class="line"><span class="keyword">then</span>  </span><br><span class="line">&lt;commands&gt;  </span><br><span class="line"><span class="keyword">elif</span> [ condition ];  </span><br><span class="line"><span class="keyword">then</span>  </span><br><span class="line">&lt;commands&gt;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&lt;commands&gt;  </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line"><span class="comment">## 比较number大于100</span></span><br><span class="line">[ <span class="variable">$number</span> -gt 100 ]</span><br><span class="line"><span class="comment">## 比较number小于100</span></span><br><span class="line">[ <span class="variable">$number</span> -lt 100 ]</span><br><span class="line"><span class="comment">## 数值比较：ge大于等于，le小于等于，eq等于，ne不等于</span></span><br><span class="line"><span class="comment">## 字符串比较： &gt; &lt; ==</span></span><br><span class="line"><span class="comment">## 比较字符串相等</span></span><br><span class="line">[ <span class="string">&quot;yi&quot;</span> == <span class="string">&quot;er&quot;</span> ]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>copy</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归拷贝</span></span><br><span class="line">$ cp -r src dest</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ssh</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh登录</span></span><br><span class="line">$ ssh root@192.168.0.1</span><br><span class="line"><span class="comment"># ssh rsa 生成</span></span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># ssh拷贝rsa</span></span><br><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub ubuntu@119.28.108.221</span><br></pre></td></tr></table></figure>

<ul>
<li><code>netstat</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看5050端口</span></span><br><span class="line">$ netstat -tunlp | grep 5050</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ls</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  列出当前目录下的所有文件和文件夹</span></span><br><span class="line">$ ls -la</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tar</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压缩*.gz</span></span><br><span class="line">$ tar -xzf file.tar.gz</span><br><span class="line"><span class="comment"># 解压缩*.bz2</span></span><br><span class="line">$ tar -xjf file.tar.bz2</span><br><span class="line"><span class="comment"># 解压缩*.xz</span></span><br><span class="line">$ tar -xJf file.tar.xz</span><br><span class="line"><span class="comment"># 解压到指定文件夹</span></span><br><span class="line">$ tar -xzf file.tar.gz -C dir</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unzip</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">$ unzip file.zip -d /dest</span><br></pre></td></tr></table></figure>

<ul>
<li>telnet</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看端口是否开放</span></span><br><span class="line">$ telnet ip port</span><br></pre></td></tr></table></figure>

<ul>
<li>ssr安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line">$ bash shadowsocksR.sh install</span><br></pre></td></tr></table></figure>

<ul>
<li>查看文件大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘大小</span></span><br><span class="line">$ df -h</span><br><span class="line"><span class="comment"># 查看文件夹大小</span></span><br><span class="line">$ du -h --max-depth=1 ~</span><br><span class="line"><span class="comment"># 查看文件大小，-h --human-readable 自适应单位</span></span><br><span class="line">$ ls -lh ~</span><br></pre></td></tr></table></figure>

<ul>
<li>磁盘</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清除磁盘缓存</span></span><br><span class="line">$ <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="comment"># 查看块设备</span></span><br><span class="line">$ lsblk</span><br><span class="line"><span class="comment"># 查看已挂载块设备</span></span><br><span class="line">$ df -h</span><br></pre></td></tr></table></figure>

<ul>
<li>软链接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ln -s src dest</span><br><span class="line">$ ln -s /usr/<span class="built_in">local</span>/mysql/bin/mysql /usr/bin</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j.properties配置详解</title>
    <url>/2021/06/09/log4j/</url>
    <content><![CDATA[<img src="/2021/06/09/log4j/Ra4d602302c78a7af261e908531fe4eb3" alt="查看源图像" style="zoom: 50%;">

<a id="more"></a>

<blockquote>
<p>References: <a href="https://www.jianshu.com/p/ccafda45bcea">https://www.jianshu.com/p/ccafda45bcea</a></p>
</blockquote>
<h1 id="1-配置模板"><a href="#1-配置模板" class="headerlink" title="1. 配置模板"></a>1. 配置模板</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############</span></span><br><span class="line"><span class="comment"># 输出到控制台</span></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log4j.rootLogger日志输出类别和级别：只输出不低于该级别的日志信息DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span></span><br><span class="line"><span class="comment"># WARN：日志级别     CONSOLE：输出位置自己定义的一个名字       logfile：输出位置自己定义的一个名字</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">WARN,CONSOLE,logfile</span></span><br><span class="line"><span class="comment"># 配置CONSOLE输出到控制台</span></span><br><span class="line"><span class="meta">log4j.appender.CONSOLE</span>=<span class="string">org.apache.log4j.ConsoleAppender </span></span><br><span class="line"><span class="comment"># 配置CONSOLE设置为自定义布局模式</span></span><br><span class="line"><span class="meta">log4j.appender.CONSOLE.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="comment"># 配置CONSOLE日志的输出格式  [frame] 2019-08-22 22:52:12,000  %r耗费毫秒数 %p日志的优先级 %t线程名 %C所属类名通常为全类名 %L代码中的行号 %x线程相关联的NDC %m日志 %n换行</span></span><br><span class="line"><span class="meta">log4j.appender.CONSOLE.layout.ConversionPattern</span>=<span class="string">[frame] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; - %-4r %-5p [%t] %C:%L %x - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################</span></span><br><span class="line"><span class="comment"># 输出到日志文件中</span></span><br><span class="line"><span class="comment">################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置logfile输出到文件中 文件大小到达指定尺寸的时候产生新的日志文件</span></span><br><span class="line"><span class="meta">log4j.appender.logfile</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="comment"># 保存编码格式</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.Encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># 输出文件位置此为项目根目录下的logs文件夹中</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.File</span>=<span class="string">logs/root.log</span></span><br><span class="line"><span class="comment"># 后缀可以是KB,MB,GB达到该大小后创建新的日志文件</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="comment"># 设置滚定文件的最大值3 指可以产生root.log.1、root.log.2、root.log.3和root.log四个日志文件</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.MaxBackupIndex</span>=<span class="string">3  </span></span><br><span class="line"><span class="comment"># 配置logfile为自定义布局模式</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################</span></span><br><span class="line"><span class="comment"># 对不同的类输出不同的日志文件</span></span><br><span class="line"><span class="comment">##########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># club.bagedate包下的日志单独输出</span></span><br><span class="line"><span class="meta">log4j.logger.club.bagedate</span>=<span class="string">DEBUG,bagedate</span></span><br><span class="line"><span class="comment"># 设置为false该日志信息就不会加入到rootLogger中了</span></span><br><span class="line"><span class="meta">log4j.additivity.club.bagedate</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 下面就和上面配置一样了</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate.Encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate.File</span>=<span class="string">logs/bagedate.log</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate.MaxBackupIndex</span>=<span class="string">3</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.bagedate.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%n</span></span><br></pre></td></tr></table></figure>



<h1 id="2-Log4j简介"><a href="#2-Log4j简介" class="headerlink" title="2. Log4j简介"></a>2. Log4j简介</h1><p>Log4j配置文件包含三个主要的组件：</p>
<ul>
<li>Loggers(记录器)：配置日志类别和级别。</li>
<li>Appenders (输出源)：配置日志输出位置。</li>
<li>Layouts(布局)：配置日志输出格式。</li>
</ul>
<h2 id="2-1-Loggers"><a href="#2-1-Loggers" class="headerlink" title="2.1 Loggers"></a>2.1 Loggers</h2><p>Loggers被分为五个级别：<code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code> &lt; <code>FATAL</code>，<strong>只会输出级别不低于设定级别的日志信息</strong></p>
<h2 id="2-2-Appenders"><a href="#2-2-Appenders" class="headerlink" title="2.2 Appenders"></a>2.2 Appenders</h2><p>Log4j日志系统提供许多强大的功能：</p>
<p>① 允许把日志输出到不同的地方，例如控制台（Console）、文件（Files）；</p>
<p>② 可以根据天数或者文件大小产生新的文件；</p>
<p>③ 可以以流的形式将日志文件发送到其它位置（文件系统、数据库等）；</p>
<p><strong>常使用的类如下：</strong></p>
<ul>
<li><code>org.apache.log4j.ConsoleAppender</code>（控制台）</li>
<li><code>org.apache.log4j.FileAppender</code>（文件）</li>
<li><code>org.apache.log4j.DailyRollingFileAppender</code>（每天产生一个日志文件）</li>
<li><code>org.apache.log4j.RollingFileAppender</code>（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li><code>org.apache.log4j.WriterAppender</code>（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置方式</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName</span> = <span class="string">className</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.Option1</span> = <span class="string">value1</span></span><br><span class="line"><span class="attr">…</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.OptionN</span> = <span class="string">valueN</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3-Layouts"><a href="#2-3-Layouts" class="headerlink" title="2.3 Layouts"></a>2.3 Layouts</h2><p>Log4j可以在Appenders的后面使用Layouts设置日志输出格式。</p>
<p><strong>常使用的类如下：</strong></p>
<ul>
<li><code>org.apache.log4j.HTMLLayout</code>（以HTML表格形式布局）</li>
<li><code>org.apache.log4j.PatternLayout</code>（可以灵活地指定布局模式）</li>
<li><code>org.apache.log4j.SimpleLayout</code>（包含日志信息的级别和信息字符串）</li>
<li><code>org.apache.log4j.TTCCLayout</code>（包含日志产生的时间、线程、类别等信息）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置方式</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.layout</span> =<span class="string">className</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.layout.Option1</span> = <span class="string">value1</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.layout.OptionN</span> = <span class="string">valueN</span></span><br></pre></td></tr></table></figure>



<h1 id="3-配置详解"><a href="#3-配置详解" class="headerlink" title="3. 配置详解"></a>3. 配置详解</h1><p>配置文件本质上是对Logger、Appender及Layout进行相应设定。</p>
<h2 id="3-1-Logger"><a href="#3-1-Logger" class="headerlink" title="3.1 Logger"></a>3.1 Logger</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">[ level ] , appenderName1, appenderName2, …</span></span><br><span class="line"><span class="meta">log4j.additivity.org.apache</span>=<span class="string">false：表示Logger不会在父Logger的appender里输出，默认为true。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>level</strong> ：设定日志记录的最低级别，可设的值有OFF、FATAL、<strong>ERROR、WARN、INFO、DEBUG</strong>、ALL或者自定义的级别，建议只使用中间四个级别。</li>
<li><strong>appenderName</strong>：指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。例如：log4j.rootLogger＝INFO,A1,B2,C3</li>
</ul>
<h2 id="3-2-日志信息输出位置（Appenders）"><a href="#3-2-日志信息输出位置（Appenders）" class="headerlink" title="3.2 日志信息输出位置（Appenders）"></a>3.2 日志信息输出位置（Appenders）</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.appender.appenderName</span> = <span class="string">className</span></span><br></pre></td></tr></table></figure>

<p><code>appenderName</code>：自定义<code>appderName</code>，在<code>log4j.rootLogger</code>设置中使用；<br><code>className</code>：</p>
<p><code>org.apache.log4j.ConsoleAppender</code>（控制台）<br><code>org.apache.log4j.FileAppender</code>（文件）<br><code>org.apache.log4j.DailyRollingFileAppender</code>（每天产生一个日志文件）<br><code>org.apache.log4j.RollingFileAppender</code>（文件大小到达指定尺寸的时候产生一个新的文件）<br><code>org.apache.log4j.WriterAppender</code>（将日志信息以流格式发送到任意指定的地方）</p>
<h3 id="3-2-1-ConsoleAppender选项"><a href="#3-2-1-ConsoleAppender选项" class="headerlink" title="3.2.1 ConsoleAppender选项"></a>3.2.1 ConsoleAppender选项</h3><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为<code>DEBUG</code>。<br><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为<code>false</code>则不输出，默认值是<code>true</code>。<br><code>Target=System.err</code>：默认值是<code>System.out</code>。</p>
<h3 id="3-2-2-FileAppender选项"><a href="#3-2-2-FileAppender选项" class="headerlink" title="3.2.2 FileAppender选项"></a>3.2.2 FileAppender选项</h3><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为<code>DEBUG</code>。<br><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为<code>false</code>则不输出，默认值是<code>true</code>。<br><code>Append=false</code>：<code>true</code>表示消息增加到指定文件中，<code>false</code>则将消息覆盖指定的文件内容，默认值是<code>true</code>。<br><code>File=D:/logs/mylog.txt</code>：指定消息输出到<code>mylog.txt</code>文件中。</p>
<h3 id="3-2-3-DailyRollingFileAppender选项"><a href="#3-2-3-DailyRollingFileAppender选项" class="headerlink" title="3.2.3 DailyRollingFileAppender选项"></a>3.2.3 DailyRollingFileAppender选项</h3><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为DEBUG。<br><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为false则不输出，默认值是true。<br><code>Append=false</code>：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。<br><code>File=D:/logs/logging.log4j</code>：指定当前消息输出到logging.log4j文件中。<br><code>DatePattern=&#39;.&#39;yyyy-MM</code>：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。<br>另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：</p>
<p><code>&#39;.&#39;yyyy-MM</code>：每月<br><code>&#39;.&#39;yyyy-ww</code>：每周<br><code>&#39;.&#39;yyyy-MM-dd</code>：每天<br><code>&#39;.&#39;yyyy-MM-dd-a</code>：每天两次<br><code>&#39;.&#39;yyyy-MM-dd-HH</code>：每小时<br><code>&#39;.&#39;yyyy-MM-dd-HH-mm</code>：每分钟</p>
<h3 id="3-2-4-RollingFileAppender选项"><a href="#3-2-4-RollingFileAppender选项" class="headerlink" title="3.2.4 RollingFileAppender选项"></a>3.2.4 RollingFileAppender选项</h3><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为DEBUG。<br><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为false则不输出，默认值是true。<br><code>Append=false</code>：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。<br><code>File=D:/logs/logging.log4j</code>：指定消息输出到logging.log4j文件中。<br><code>MaxFileSize=100KB</code>：后缀可以是KB, MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。<br><code>MaxBackupIndex=2</code>：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。</p>
<h2 id="3-3-日志输出格式（Layout）"><a href="#3-3-日志输出格式（Layout）" class="headerlink" title="3.3 日志输出格式（Layout）"></a>3.3 日志输出格式（Layout）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copylog4j.appender.appenderName.layout&#x3D;className</span><br></pre></td></tr></table></figure>

<p><strong>className：可设值如下：</strong></p>
<p><code>org.apache.log4j.HTMLLayout</code>（以HTML表格形式布局）<br><code>org.apache.log4j.PatternLayout</code>（可以灵活地指定布局模式）<br><code>org.apache.log4j.SimpleLayout</code>（包含日志信息的级别和信息字符串）<br><code>org.apache.log4j.TTCCLayout</code>（包含日志产生的时间、线程、类别等等信息）</p>
<h3 id="3-3-1-HTMLLayout选项"><a href="#3-3-1-HTMLLayout选项" class="headerlink" title="3.3.1 HTMLLayout选项"></a>3.3.1 HTMLLayout选项</h3><p><code>LocationInfo=true</code>：输出java文件名称和行号，默认值是false。<br><code>Title=My Logging</code>： 默认值是Log4J Log Messages。</p>
<h3 id="3-3-2-PatternLayout选项"><a href="#3-3-2-PatternLayout选项" class="headerlink" title="3.3.2 PatternLayout选项"></a>3.3.2 PatternLayout选项</h3><p><code>ConversionPattern=%m%n</code>：设定以怎样的格式显示消息。<br>格式化符号说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。</span><br><span class="line">%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d&#123;yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS&#125;。</span><br><span class="line">%r：输出自应用程序启动到输出该log信息耗费的毫秒数。</span><br><span class="line">%t：输出产生该日志事件的线程名。</span><br><span class="line">%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。</span><br><span class="line">%c：输出日志信息所属的类目，通常就是所在类的全名。</span><br><span class="line">%M：输出产生日志信息的方法名。</span><br><span class="line">%F：输出日志消息产生时所在的文件名称。</span><br><span class="line">%L：输出代码中的行号。</span><br><span class="line">%m：输出代码中指定的具体日志信息。</span><br><span class="line">%n：输出一个回车换行符，Windows平台为&quot;\r\n&quot;，Unix平台为&quot;\n&quot;。</span><br><span class="line">%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。</span><br><span class="line">%%：输出一个&quot;%&quot;字符。</span><br><span class="line"></span><br><span class="line">另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：</span><br><span class="line">1）c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。</span><br><span class="line">2）%-20c：&quot;-&quot;号表示左对齐。</span><br><span class="line">3）%.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2022/01/06/maven/</url>
    <content><![CDATA[<img src="/2022/01/06/maven/bg.jpeg" alt="img" style="zoom:50%;">

<a id="more"></a>

<h1 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h1><p><img src="/2022/01/06/maven/maven-package-build-phase.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">处理</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">验证 validate</td>
<td align="left">验证项目</td>
<td align="left">验证项目是否正确且所有必须信息是可用的</td>
</tr>
<tr>
<td align="left">编译 compile</td>
<td align="left">执行编译</td>
<td align="left">源代码编译在此阶段完成</td>
</tr>
<tr>
<td align="left">测试 Test</td>
<td align="left">测试</td>
<td align="left">使用适当的单元测试框架（例如JUnit）运行测试。</td>
</tr>
<tr>
<td align="left">包装 package</td>
<td align="left">打包</td>
<td align="left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td>
</tr>
<tr>
<td align="left">检查 verify</td>
<td align="left">检查</td>
<td align="left">对集成测试的结果进行检查，以保证质量达标</td>
</tr>
<tr>
<td align="left">安装 install</td>
<td align="left">安装</td>
<td align="left">安装打包的项目到本地仓库，以供其他项目使用</td>
</tr>
<tr>
<td align="left">部署 deploy</td>
<td align="left">部署</td>
<td align="left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td>
</tr>
</tbody></table>
<h1 id="常用Maven命令"><a href="#常用Maven命令" class="headerlink" title="常用Maven命令"></a>常用Maven命令</h1><ul>
<li>安装单独的jar包到本地仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn install:install-file -Dfile=sparrow-core-1.0-SNAPSHOT-jar-with-dependencies.jar -DgroupId=github.pancras -DartifactId=sparrow-core -Dversion=1.0-SNAPSHOT -Dpackaging=jar</span><br></pre></td></tr></table></figure>

<ul>
<li>将源码一同发布到本地仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn clean <span class="built_in">source</span>:jar install</span><br></pre></td></tr></table></figure>

<ul>
<li>将依赖也打包进jar</li>
</ul>
<p>添加依赖，并使用<code>assembly:assembly</code>打包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>github.pancras.NettyServerMain<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn assembly:assembly</span><br></pre></td></tr></table></figure>



<ul>
<li>测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行测试</span></span><br><span class="line">$ mvn clean <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 跳过测试</span></span><br><span class="line">$ mvn clean package -DskipTests=<span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>运行jar</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -classpath **.jar **.**.className</span><br><span class="line">$ mvn <span class="built_in">exec</span>:java -Dexec.mainClass=<span class="string">&quot;MainApplication&quot;</span>  </span><br></pre></td></tr></table></figure>



<ul>
<li>打包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn clean install -DskipTests=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 对指定模块及其依赖的模块进行操作</span></span><br><span class="line">$ mvn clean package -pl</span><br><span class="line"><span class="comment"># 打包并进行格式检查</span></span><br><span class="line">$ mvn clean package -P checkstyle -DskipTests</span><br></pre></td></tr></table></figure>



<ul>
<li>seata安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn clean install -P checkstyle -DskipTests</span><br></pre></td></tr></table></figure>



<ul>
<li>引入外部依赖</li>
</ul>
<p>先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。我们使用的是 ldapjdk.jar.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 库名称，也可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--库名称，也可以自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> <span class="comment">&lt;!--项目根目录下的lib文件夹下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="Maven模板文件"><a href="#Maven模板文件" class="headerlink" title="Maven模板文件"></a>Maven模板文件</h1><ul>
<li>父模块</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-spi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子模块</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>indi.pancras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-spi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>apt、docker、maven等镜像源更换</title>
    <url>/2020/03/21/mirrors/</url>
    <content><![CDATA[<p><img src="/2020/03/21/mirrors/ubuntu.png" alt="img"></p>
<a id="more"></a>



<h1 id="apt文件源"><a href="#apt文件源" class="headerlink" title="apt文件源"></a>apt文件源</h1><ul>
<li>20.04</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>



<ul>
<li>18.04</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>



<ul>
<li>16.04</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></table></figure>



<h1 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://htdsx47m.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>



<h1 id="Maven镜像加速"><a href="#Maven镜像加速" class="headerlink" title="Maven镜像加速"></a>Maven镜像加速</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># conf/settings.xml</span></span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">        &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="NodeJS镜像加速"><a href="#NodeJS镜像加速" class="headerlink" title="NodeJS镜像加速"></a>NodeJS镜像加速</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>



<h1 id="Pip3镜像加速"><a href="#Pip3镜像加速" class="headerlink" title="Pip3镜像加速"></a>Pip3镜像加速</h1>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty - 高性能网络应用框架</title>
    <url>/2021/06/16/netty/</url>
    <content><![CDATA[<img src="/2021/06/16/netty/components.png" alt="img" style="zoom: 80%;">

<a id="more"></a>

<h1 id="1-什么是Netty？"><a href="#1-什么是Netty？" class="headerlink" title="1. 什么是Netty？"></a>1. 什么是Netty？</h1><p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。</p>
<h1 id="2-Netty的特性"><a href="#2-Netty的特性" class="headerlink" title="2. Netty的特性"></a>2. Netty的特性</h1><h2 id="2-1-并发高"><a href="#2-1-并发高" class="headerlink" title="2.1 并发高"></a>2.1 并发高</h2><h2 id="2-2-传输快"><a href="#2-2-传输快" class="headerlink" title="2.2 传输快"></a>2.2 传输快</h2><p>Netty的传输快其实也是依赖了NIO的一个特性——<em>零拷贝</em>。我们知道，Java的内存有堆内存、栈内存和字符串常量池等等，其中堆内存是占用内存空间最大的一块，也是Java对象存放的地方，一般我们的数据如果需要从IO读取到堆内存，中间需要经过Socket缓冲区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会造成不必要的资源浪费。<br> Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</p>
<p><img src="/2021/06/16/netty/1089449-014c9e07d56e4be5.png" alt="img"></p>
<p><img src="/2021/06/16/netty/1089449-50e5aa5eec7e86cc.png" alt="img"></p>
<h2 id="2-3-封装好"><a href="#2-3-封装好" class="headerlink" title="2.3 封装好"></a>2.3 封装好</h2><p>Netty是对Java NIO的封装，易于使用，性能好</p>
<h1 id="3-Netty中的关键概念"><a href="#3-Netty中的关键概念" class="headerlink" title="3. Netty中的关键概念"></a>3. Netty中的关键概念</h1><h2 id="3-1-Channel"><a href="#3-1-Channel" class="headerlink" title="3.1 Channel"></a>3.1 Channel</h2><p><strong>Channel是对Socket的抽象，NioSocketChannel的底层是基于java.nio.SocketChannel实现的，NioServerSocketChannel的底层是基于Java.nio.ServerSocketChannel实现的</strong></p>
<ul>
<li><p>Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。</p>
</li>
<li><p><strong>ChannelHandler</strong>，核心处理业务就在这里，用于处理业务请求。</p>
</li>
<li><p>ChannelHandlerContext，用于传输业务数据。</p>
</li>
<li><p>ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。</p>
</li>
</ul>
<p>他们的交互流程是：</p>
<ol>
<li>事件传递给 ChannelPipeline 的第一个 ChannelHandler</li>
<li>ChannelHandler 通过关联的 ChannelHandlerContext 传递事件给 ChannelPipeline 中的 下一个</li>
<li>ChannelHandler 通过关联的 ChannelHandlerContext 传递事件给 ChannelPipeline 中的 下一个</li>
</ol>
<p><img src="/2021/06/16/netty/1089449-afd9e14197e1ef11.png" alt="img"></p>
<p><strong>NioEventLoopGroup可以理解为一个线程池，内部维护了一组线程，每个线程负责处理多个Channel上的事件，而一个Channel只对应于一个线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Server</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 监听线程组，监听客户端请求</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 工作线程组，处理与客户端的数据通讯</span></span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Client</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"><span class="comment">// 处理与服务端通信的线程组</span></span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">bootstrap.group(workerGroup)</span><br></pre></td></tr></table></figure>



<h2 id="3-2-Bootstrap"><a href="#3-2-Bootstrap" class="headerlink" title="3.2 Bootstrap"></a>3.2 Bootstrap</h2><p>客户端和服务端的对象工厂，用来创建具体的Channel</p>
<h2 id="3-3-EventLoop"><a href="#3-3-EventLoop" class="headerlink" title="3.3 EventLoop"></a>3.3 EventLoop</h2><p>任务执行者：</p>
<ul>
<li>每个Channel有且仅有一个EventLoop与之关联</li>
</ul>
<h2 id="3-4-Pipeline"><a href="#3-4-Pipeline" class="headerlink" title="3.4 Pipeline"></a>3.4 Pipeline</h2><p>每个Channel有且仅有一个ChannelPipeline与之对应</p>
<h2 id="3-5-Future和ChannelFuture"><a href="#3-5-Future和ChannelFuture" class="headerlink" title="3.5 Future和ChannelFuture"></a>3.5 Future和ChannelFuture</h2><h3 id="3-5-1-Future"><a href="#3-5-1-Future" class="headerlink" title="3.5.1 Future"></a>3.5.1 Future</h3><ul>
<li>java.util.concurrent.Future：记录异步执行的状态，调用get()方法阻塞到任务完成</li>
<li>io.netty.util.concurrent.Future：扩展了Java的Future，实现了监听器（Listener）接口，可以通过监听器回调来处理任务执行结果</li>
</ul>
<h3 id="3-5-2-ChannelFuture"><a href="#3-5-2-ChannelFuture" class="headerlink" title="3.5.2 ChannelFuture"></a>3.5.2 ChannelFuture</h3><p>扩展了Netty的Future，表示一种没有返回值的异步调用，同时和一个Channel进行绑定。</p>
<h2 id="3-4-ByteBuf"><a href="#3-4-ByteBuf" class="headerlink" title="3.4 ByteBuf"></a>3.4 ByteBuf</h2><p>ByteBuf是一个存储字节的容器，最大特点就是<strong>使用方便</strong>，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写，他的数据结构如下图所示：</p>
<p><img src="/2021/06/16/netty/1089449-b1ec677f253b692a.png" alt="img"></p>
<p>有三种使用模式：</p>
<ol>
<li><p>Heap Buffer 堆缓冲区<br> 堆缓冲区是ByteBuf最常用的模式，他将数据存储在堆空间。</p>
</li>
<li><p>Direct Buffer 直接缓冲区</p>
<p>直接缓冲区是ByteBuf的另外一种常用模式，他的内存分配都不发生在堆，jdk1.4引入的nio的ByteBuffer类允许jvm通过本地方法调用分配内存，这样做有两个好处</p>
<ul>
<li>通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外。</li>
<li>DirectBuffer 在 -XX:MaxDirectMemorySize=xxM大小限制下, 使用 Heap 之外的内存, GC对此”无能为力”,也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响.</li>
</ul>
</li>
<li><p>Composite Buffer 复合缓冲区<br> 复合缓冲区相当于多个不同ByteBuf的视图，这是netty提供的，jdk不提供这样的功能。</p>
</li>
</ol>
<h2 id="3-5-Codec"><a href="#3-5-Codec" class="headerlink" title="3.5 Codec"></a>3.5 Codec</h2><p>Netty中的编码/解码器，通过它完成字节与pojo、pojo与pojo的相互转换，从而实现自定义协议。</p>
<h1 id="4-Netty进阶"><a href="#4-Netty进阶" class="headerlink" title="4. Netty进阶"></a>4. Netty进阶</h1><h2 id="4-1-IO线程和业务线程分离"><a href="#4-1-IO线程和业务线程分离" class="headerlink" title="4.1 IO线程和业务线程分离"></a>4.1 IO线程和业务线程分离</h2><p>客户端调用服务，服务端的操作基本都是修改数据库数据或获取数据库数据。数据库的操作可以认为是比较耗时的，所以在Netty的I/O线程中不适合处理这些操作。</p>
<p>I/O线程：服务端Netty的I/O线程是处理客户端的连接和处理数据读写的（根据主从Reactor多线程模型，已经将网络读写和客户端进行连接分开），耗时的业务逻辑是不适合也在I/O线程中执行的。</p>
<p>业务线程：处理比较耗时的业务。</p>
<ul>
<li>方法一：在添加 pipeline 中的 handler 时候，添加一个Netty提供的线程池。</li>
<li>方法二：在ChannelHandler的回调方法中，使用自己定义的业务线程池。</li>
</ul>
<h2 id="4-2-Netty和Reactor"><a href="#4-2-Netty和Reactor" class="headerlink" title="4.2 Netty和Reactor"></a>4.2 Netty和Reactor</h2><h3 id="4-2-1-单线程模型"><a href="#4-2-1-单线程模型" class="headerlink" title="4.2.1 单线程模型"></a>4.2.1 单线程模型</h3><p>Acceptor的处理和Handler的处理都在一个线程中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup);<span class="comment">// 底层调用了 server.group(bossGroup, bossGroup)</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2-2-多线程模型"><a href="#4-2-2-多线程模型" class="headerlink" title="4.2.2 多线程模型"></a>4.2.2 多线程模型</h3><p>有一个专门的线程Acceptor用于监听客户端的TCP连接请求</p>
<p>客户端连接后的IO操作都有一个特定的NIO线程池负责</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>



<h3 id="4-2-3-主从多线程模型"><a href="#4-2-3-主从多线程模型" class="headerlink" title="4.2.3 主从多线程模型"></a>4.2.3 主从多线程模型</h3><p>将Acceptor由一个线程改为一个线程池（例如需要在客户端连接时增加一些权限校验等操作的场景）</p>
<p>客户端连接后的IO操作都有一个特定的NIO线程池负责</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>



<h2 id="4-3-Netty和拆包、粘包"><a href="#4-3-Netty和拆包、粘包" class="headerlink" title="4.3 Netty和拆包、粘包"></a>4.3 Netty和拆包、粘包</h2><h3 id="4-3-1-TCP拆包、粘包"><a href="#4-3-1-TCP拆包、粘包" class="headerlink" title="4.3.1 TCP拆包、粘包"></a>4.3.1 TCP拆包、粘包</h3><p>严格来讲，TCP是不存在粘包拆包的，这里的粘包拆包是指应用层上的一个数据包会被合并为一个或分割为多个TCP数据包进行传输。</p>
<p>原因是TCP数据包有大小限制，因此业务上一个完整的包在发送时可能会被拆分为多个TCP包进行发送，此为<strong>拆包</strong>；也有可能把多个小的包封装成一个大的数据包发送，此为<strong>粘包</strong>。</p>
<h3 id="4-3-2-粘包问题的解决策略"><a href="#4-3-2-粘包问题的解决策略" class="headerlink" title="4.3.2 粘包问题的解决策略"></a>4.3.2 粘包问题的解决策略</h3><p>底层的TCP无法理解上层业务数据，因此只能通过应用层协议来解决TCP拆包、粘包问题，其问题核心就是如何处理<strong>应用消息边界</strong>，主要解决思路就是把不同应用<strong>数据包用分隔符分隔开</strong>，具体实现有以下方法：</p>
<ol>
<li>消息定长</li>
<li>数据包尾部添加特殊分隔符，例如换行符（FTP采用）</li>
<li>将消息分为消息头和消息体，消息头是定长的，且包含了消息体的长度</li>
<li>其他自定义方案，例如根据消息头类型来默认消息体长度</li>
</ol>
<p>Netty的处理方案：每个Channel仅和一个Handler绑定，如果数据包不完整，Channel中的数据读取的时候可以对数据包进行保存，等下次解析时再对这个数据包进行组装解析，直到获取完整的数据包后再将数据包向下传递。</p>
<p>解决方案：</p>
<ul>
<li>LineBasedFrameDecoder：行解码器</li>
<li>DelimiterBasedFrameDecoder：分隔符解码器</li>
<li>FixedLengthFrameDecoder：固定长度解码器</li>
<li>LengthFieldBasedFrameDecoder：length属性解码器</li>
</ul>
<h2 id="4-4-设计模式在Netty中的应用"><a href="#4-4-设计模式在Netty中的应用" class="headerlink" title="4.4 设计模式在Netty中的应用"></a>4.4 设计模式在Netty中的应用</h2><p>// todo</p>
<h1 id="5-Netty常见问题"><a href="#5-Netty常见问题" class="headerlink" title="5. Netty常见问题"></a>5. Netty常见问题</h1><p>// todo</p>
<blockquote>
<p>Reference</p>
<p>[1] <a href="https://www.jianshu.com/p/b9f3f6a16911">https://www.jianshu.com/p/b9f3f6a16911</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>web</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>网络文件系统搭建</title>
    <url>/2021/10/27/nfs/</url>
    <content><![CDATA[<img src="/2021/10/27/nfs/Network-File-Systems.jpg" alt="查看源图像" style="zoom: 25%;">

<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>主机A：192.168.3.155</p>
<p>主机B：192.168.3.195</p>
<p>将主机A的/mnt/nfs-share目录挂载到主机B的/mnt/nfs-share目录</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="主机A（192-168-3-155）"><a href="#主机A（192-168-3-155）" class="headerlink" title="主机A（192.168.3.155）"></a>主机A（192.168.3.155）</h2><ul>
<li>安装nfs-server</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure>

<ul>
<li>创建目录并修改权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line">sudo mkdir nfs-share</span><br><span class="line"><span class="comment"># 允许非root用户访问</span></span><br><span class="line">sudo chmod 777 nfs-share</span><br></pre></td></tr></table></figure>

<ul>
<li>允许该文件被共享</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br><span class="line"><span class="comment"># 添加如下内容 *是ip地址通配符，表示可以共享给任何ip的主机</span></span><br><span class="line">/mnt/nfs-share *(rw,sync,no_subtree_check,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新配置</span></span><br><span class="line">sudo exportfs -arv</span><br></pre></td></tr></table></figure>



<h2 id="主机B（192-168-3-195）"><a href="#主机B（192-168-3-195）" class="headerlink" title="主机B（192.168.3.195）"></a>主机B（192.168.3.195）</h2><ul>
<li>安装nfs-client</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install nfs-common</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将主机A的/mnt/nfs-share文件夹挂载到本地的/mnt/nfs-share文件夹</span></span><br><span class="line">sudo mount 192.168.1.195:/mnt/nfs-share /mnt/nfs-share</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>论文写作金句</title>
    <url>/2020/03/21/paper-writing/</url>
    <content><![CDATA[<img src="/2020/03/21/paper-writing/bg.jpeg" alt="img" style="zoom:50%;">

<a id="more"></a>

<h1 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h1><h1 id="计算存储"><a href="#计算存储" class="headerlink" title="计算存储"></a>计算存储</h1><ul>
<li>一方面，将计算转移到嵌入式内核上是有利的，可以通过减轻繁重的交通和带宽需求来减少主机和存储的通信延迟。另一方面，与主机处理器相比，嵌入式处理器的性能相对薄弱，执行存储计算需要更多的处理时间。因此，在嵌入式处理器所带来的计算开销和向主机系统传输数据的通信延迟的减少之间存在着一种权衡。</li>
<li>手编优化虽然比基线要好，但总体上要比动态工作负载分配方法更出色。动态方法在实践中更容易采用。程序员不必担心工作负载分配，系统会根据动态系统状态自动决定在哪里执行代码。</li>
</ul>
<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><ul>
<li>对象存储可以包含各种各样的对象类型和大小</li>
</ul>
<blockquote>
<p>Raúl Gracia-Tinedo, Yongchao Tian, Josep Sampé, Hamza Harkous, John Lenton, Pedro García-López, Marc Sánchez-Artigas, and Marko Vukolic. 2015. Dissecting UbuntuOne: Autopsy of a Global-scale Personal Cloud Back-end. In IMC. 155– 168.</p>
</blockquote>
<ul>
<li>部署在分布式对象存储系统中的现有近数据处理方案或受限于数据所在存储节点的可用资源，或需要大量额外的计算节点提供资源。</li>
</ul>
<h1 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h1><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><ul>
<li>CNDP根据系统中所有存储节点的资源占用情况，将近数据处理任务调度到资源更充足的存储节点及独立计算节点上，实现了在不同的存储节点间及其与独立计算节点间的协作。</li>
</ul>
<h1 id="测试评估"><a href="#测试评估" class="headerlink" title="测试评估"></a>测试评估</h1><ul>
<li>模拟仿真结果显示，相比xxx执行同任务达到5x加速。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>python垃圾回收</title>
    <url>/2020/10/15/python-garbage-collection/</url>
    <content><![CDATA[<img src="/2020/10/15/python-garbage-collection/python.png" alt="img" style="zoom: 50%;">

<a id="more"></a>



<h1 id="引用计数——reference-counting"><a href="#引用计数——reference-counting" class="headerlink" title="引用计数——reference counting"></a>引用计数——reference counting</h1><h2 id="一个简单样例"><a href="#一个简单样例" class="headerlink" title="一个简单样例"></a>一个简单样例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于获取引用计数的函数，输出结果会比实际引用数多1，因为在调用该函数时引用数增加了1</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">11</span>)</span><br><span class="line">print(getrefcount(s1) - <span class="number">1</span>)  <span class="comment"># 引用数为1</span></span><br><span class="line"></span><br><span class="line">s2 = s1</span><br><span class="line">s3 = s1</span><br><span class="line">s4 = s1</span><br><span class="line">print(getrefcount(s1) - <span class="number">1</span>)  <span class="comment"># 引用数为1+3=4</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<!--more-->

<h2 id="缺陷：循环引用导致的内存泄漏"><a href="#缺陷：循环引用导致的内存泄漏" class="headerlink" title="缺陷：循环引用导致的内存泄漏"></a>缺陷：循环引用导致的内存泄漏</h2><ul>
<li>内存泄漏</li>
</ul>
<p>指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>有 <strong>del</strong>() 函数的对象间的循环引用是导致内存泄漏的主凶</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, deskmate = None</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.deskmate = deskmate  <span class="comment"># 同桌:引用另一个学生</span></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">11</span>)</span><br><span class="line">s2 = Student(<span class="string">&quot;Mike&quot;</span>, <span class="number">12</span>)</span><br><span class="line">print(<span class="string">f&#x27;循环引用前, s1：<span class="subst">&#123;sys.getrefcount(s1)<span class="number">-1</span>&#125;</span>，s2：<span class="subst">&#123;sys.getrefcount(s2)<span class="number">-1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s1.deskmate = s2</span><br><span class="line">s2.deskmate = s1</span><br><span class="line">print(<span class="string">f&#x27;循环引用后, s1：<span class="subst">&#123;sys.getrefcount(s1)<span class="number">-1</span>&#125;</span>，s2：<span class="subst">&#123;sys.getrefcount(s2)<span class="number">-1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 理论上del s1 和 del s2后s1,s2的引用次数应该为0，但由于循环引用，删除对象后引用计数仍然为1</span></span><br><span class="line"><span class="comment"># 由于循环引用，del 对象后仍然会使引用计数+1，导致垃圾回收器都不会回收它们，所以就会导致内存泄露</span></span><br><span class="line"><span class="keyword">del</span> s1</span><br><span class="line"><span class="keyword">del</span> s2</span><br><span class="line"><span class="comment"># print(f&#x27;del对象后, s1：&#123;sys.getrefcount(s1)-1&#125;，s2：&#123;sys.getrefcount(s2)-1&#125;&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">循环引用前, s1：1，s2：1</span><br><span class="line">循环引用后, s1：2，s2：2</span><br><span class="line"><span class="comment"># del对象后, s1：1，s2：1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案<ul>
<li>标记清除技术——mark and sweep</li>
<li>分代回收技术——generation collection</li>
<li>手动使用gc模块</li>
</ul>
</li>
</ul>
<h1 id="标记-清除机制——mark-and-sweep"><a href="#标记-清除机制——mark-and-sweep" class="headerlink" title="标记-清除机制——mark and sweep"></a>标记-清除机制——mark and sweep</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历<strong>以对象为节点、以引用为边构成的图</strong>，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。</p>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</p>
<p><img src="/2020/10/15/python-garbage-collection/img" alt="img"></p>
<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p>
<h1 id="分代技术——generation-collection"><a href="#分代技术——generation-collection" class="headerlink" title="分代技术——generation collection"></a>分代技术——generation collection</h1><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<blockquote>
<p>Reference</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata——分布式事务中间件</title>
    <url>/2021/07/16/seata/</url>
    <content><![CDATA[<img src="/2021/07/16/seata/bg.jpeg" alt="img" style="zoom:50%;">

<a id="more"></a>

<h1 id="1-Seata简介"><a href="#1-Seata简介" class="headerlink" title="1. Seata简介"></a>1. Seata简介</h1><p>Seata(Simple Extensible Autonomous Transaction Architecture) 是 阿里巴巴开源的分布式事务中间件，以高效并且对业务 0 侵入的方式，解决微服务场景下面临的分布式事务问题。</p>
<p>Seata支持AT、TCC、SAGA 和 XA 事务模式。</p>
<p>事务模式对比</p>
<table>
<thead>
<tr>
<th>分布式事务模式</th>
<th>介绍</th>
<th>技术栈</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AT 模式</strong></td>
<td>无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本（sql都由框架托管统一执行，会存在<strong>脏写</strong>问题）</td>
<td>seata、shardingsphere</td>
</tr>
<tr>
<td><strong>TCC 模式</strong></td>
<td>高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景（第一阶段会产生行锁，事务执行太久会<strong>锁行很久</strong>）</td>
<td>seata、service-comb</td>
</tr>
<tr>
<td><strong>Saga 模式</strong></td>
<td>长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统（第一阶段就操作DB，会存在<strong>脏读</strong>问题）</td>
<td>seata、shardingsphere、service-comb</td>
</tr>
<tr>
<td><strong>XA模式</strong></td>
<td>分布式强一致性的解决方案，但<strong>性能低</strong>而使用较少。</td>
<td>seata、shardingsphere</td>
</tr>
</tbody></table>
<h2 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1 核心组件"></a>1.1 核心组件</h2><ul>
<li><strong>TC (Transaction Coordinator) - 事务协调者</strong></li>
</ul>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<ul>
<li><strong>TM (Transaction Manager) - 事务管理器</strong></li>
</ul>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<ul>
<li><strong>RM (Resource Manager) - 资源管理器</strong></li>
</ul>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<img src="/2021/07/16/seata/image-20210716124159995.png" alt="image-20210716124159995" style="zoom: 67%;">



<h2 id="1-2-全局事务和分支事务"><a href="#1-2-全局事务和分支事务" class="headerlink" title="1.2 全局事务和分支事务"></a>1.2 全局事务和分支事务</h2><img src="/2021/07/16/seata/image-20210716124213606.png" alt="image-20210716124213606" style="zoom:80%;">

<h1 id="2-Seata事务过程解析"><a href="#2-Seata事务过程解析" class="headerlink" title="2. Seata事务过程解析"></a>2. Seata事务过程解析</h1><h2 id="2-1-全局事务扫描器"><a href="#2-1-全局事务扫描器" class="headerlink" title="2.1 全局事务扫描器"></a>2.1 全局事务扫描器</h2><p>通过再配置文件中配置<code>GlobalTransactionScanner</code>，这个实例在项目启动时会扫描所有实例，具体实现见【spring】模块。并将标注了@GlobalTransactional注解的方法织入GlobalTransactionalInterceptor的invoke方法逻辑。同时应用启动时，会初始化TM（TmRpcClient）和RM（RmRpcClient）的实例，这个时候，服务已经和TC事务控制中心勾搭上了。在往下看就涉及到TM模块的事务模板类TransactionalTemplate。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fescar.spring.annotation.GlobalTransactionScanner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;dubbo-demo-app&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;my\_test\_tx_group&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-【TM】模块启动全局事务"><a href="#2-2-【TM】模块启动全局事务" class="headerlink" title="2.2 【TM】模块启动全局事务"></a>2.2 【TM】模块启动全局事务</h2><p>DefaultGlobalTransaction ：全局事务具体的开启，提交、回滚动作</p>
<p>DefaultTransactionManager ：负责使用TmRpcClient向TC控制中心发送指令，如开启全局事务（GlobalBeginRequest）、提交（GlobalCommitRequest）、回滚（GlobalRollbackRequest）、查询状态（GlobalStatusRequest）等。</p>
<p>以上是TM模块核心内容点，TM模块完成全局事务开启后，接下来就开始看看全局事务iD，xid是如何传递、RM组件是如何介入的</p>
<h2 id="2-3-【dubbo】全局事务xid的传递"><a href="#2-3-【dubbo】全局事务xid的传递" class="headerlink" title="2.3 【dubbo】全局事务xid的传递"></a>2.3 【dubbo】全局事务xid的传递</h2><p>首先是xid的传递，目前已经实现了dubbo框架实现的微服务架构下的传递，其他的像spring cloud和motan等的想要实现也很容易，通过一般RPC通讯框架都有的filter机制，将xid从全局事务的发起节点传递到服务协从节点，从节点接收到后绑定到当前线程上线文环境中，用于在分支事务执行sql时判断是否加入全局事务。</p>
<h2 id="2-4-【RM】模块本地资源管理的介入"><a href="#2-4-【RM】模块本地资源管理的介入" class="headerlink" title="2.4 【RM】模块本地资源管理的介入"></a>2.4 【RM】模块本地资源管理的介入</h2><h1 id="3-各事务模式介绍"><a href="#3-各事务模式介绍" class="headerlink" title="3. 各事务模式介绍"></a>3. 各事务模式介绍</h1><h2 id="3-1-AT模式（Automatic-Transaction）"><a href="#3-1-AT模式（Automatic-Transaction）" class="headerlink" title="3.1 AT模式（Automatic Transaction）"></a>3.1 AT模式（Automatic Transaction）</h2><p><img src="/2021/07/16/seata/image-20210716124237493.png" alt="image-20210716124237493"></p>
<h2 id="3-2-SAGA模式"><a href="#3-2-SAGA模式" class="headerlink" title="3.2 SAGA模式"></a>3.2 SAGA模式</h2><p><img src="/2021/07/16/seata/image-20210716124304758.png" alt="image-20210716124304758"></p>
<h2 id="3-3-XA模式"><a href="#3-3-XA模式" class="headerlink" title="3.3 XA模式"></a>3.3 XA模式</h2><p>两阶段提交理论的一个广泛工业应用是XA协议。目前几乎所有收费的商业数据库都支持XA协议。<strong>XA协议已在业界成熟运行数十年，但目前它在互联网海量流量的应用场景中，吞吐量这个瓶颈变得十分致命，因此很少被用到。</strong></p>
<img src="/2021/07/16/seata/TB1hSpccIVl614jSZKPXXaGjpXa-1330-924.png" alt="img" style="zoom: 67%;">

<h2 id="3-4-TCC模式-Try、Confirm、Cancel"><a href="#3-4-TCC模式-Try、Confirm、Cancel" class="headerlink" title="3.4 TCC模式(Try、Confirm、Cancel)"></a>3.4 TCC模式(Try、Confirm、Cancel)</h2><img src="/2021/07/16/seata/image-20210716133155144.png" alt="image-20210716133155144" style="zoom:67%;">

<img src="/2021/07/16/seata/image-20210716124251062.png" alt="image-20210716124251062" style="zoom:67%;">

<p>TCC事务其实主要包含两个阶段：Try阶段、Confirm/Cancel阶段。TCC 模式需要用户根据自己的业务场景实现 Try、Confirm 和 Cancel 三个操作，事务发起方在一阶段执行 Try 方式，在二阶段提交执行 Confirm 方法，二阶段回滚执行 Cancel 方法。</p>
<p>TCC的核心思想是try阶段检查并预留资源，确保在confirm阶段有资源可用，这样可以最大程度的确保confirm阶段能够执行成功，避免死锁问题。</p>
<p>（1）try：尝试执行业务</p>
<p>完成所有业务检查(一致性)</p>
<p>预留必须业务资源(准隔离性)</p>
<p>（2）confirm：确认执行业务</p>
<p>真正执行业务</p>
<p>不作任何业务检查</p>
<p>只使用Try阶段预留的业务资源</p>
<p>Confirm操作必须保证幂等性 </p>
<p>（3）cancel：取消执行业务</p>
<p>释放Try阶段预留的业务资源</p>
<p>Cancel操作必须保证幂等性</p>
<p>TCC具有三大特性：允许空回滚、防悬挂控制、幂等控制。</p>
<p><strong>允许空回滚</strong></p>
<p>当 Try 接口因丢包出现超时，或未收到Try而收到Cancel时，事务管理器会触发Cancel 接口执行回滚，如果执行时发现没有对应的事务不存在时，需要返回回滚成功，以让事务服务管理器认为已执行回滚，避免不断重试。</p>
<p><strong>防悬挂控制</strong></p>
<p>悬挂：Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，即Cancel 比 Try 接口先执行。</p>
<p>因允许空回滚的逻辑，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致。Cancel空回滚返回成功之前标识这条记录已回滚，Try接口先检查该事务是否被标记为回滚成功来决定是否执行。</p>
<p><strong>幂等控制</strong></p>
<p>幂等性：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要在服务设计时进行幂等控制。</p>
<h1 id="4-TCC二阶段异步提交功能实现"><a href="#4-TCC二阶段异步提交功能实现" class="headerlink" title="4. TCC二阶段异步提交功能实现"></a>4. TCC二阶段异步提交功能实现</h1><h2 id="4-1-总体思路"><a href="#4-1-总体思路" class="headerlink" title="4.1 总体思路"></a>4.1 总体思路</h2><p>修改tcc模块和server模块的相关代码，参考异步提交的实现，完成异步回滚特性，通过异步操作提升回滚性能，从而降低全局回滚的时间成本。</p>
<p>同步全局回滚时，跳过可异步执行的分支，将它们交由handleAsyncRollbacking()来处理。特性的实现主要涉及以下内容：</p>
<ul>
<li><p>为分支调用过程的方法添加rollbackType参数，以及对应的日志。</p>
</li>
<li><p>实现handleAsyncRollbacking()的处理逻辑。</p>
</li>
<li><p>通过默认参数保证不同版本之间的兼容性问题。</p>
</li>
</ul>
<h2 id="4-2-方案设计"><a href="#4-2-方案设计" class="headerlink" title="4.2 方案设计"></a>4.2 方案设计</h2><ul>
<li><p>修改TCC的注解@TwoPhaseBusinessAction，添加TCCRollbackType rollbackType() default TCCRollbackType.SyncRollback</p>
</li>
<li><p>分支注册接口，添加参数TCCRollbackType rollbackType，且RPC交易时的序列化中，添加对该参数的序列化</p>
</li>
<li><p>TC端三种store模式，添加对rollbackType的持久化功能。db模式添加字段rollback_type</p>
</li>
<li><p>同步全局回滚时，将可异步执行的分支加入到待处理集合中</p>
</li>
<li><p>实现handleAsyncRollbacking()的处理逻辑：</p>
<ul>
<li>配置：修改server模块，使该方法由异步定时任务触发。</li>
<li>算法逻辑：获取待异步处理的分支，枚举回滚分支，调用doGlobalRollback方法执行回滚操作。</li>
</ul>
</li>
</ul>
<h2 id="4-3-方案实现"><a href="#4-3-方案实现" class="headerlink" title="4.3 方案实现"></a>4.3 <strong>方案实现</strong></h2><p>首先，学习异步提交的代码接口设计，设计异步回滚操作的代码接口，参考其实现完成TCC异步回滚的特性。其次，编写的测试用例，保证功能的正常执行，在测试时需要注意不同版本之间的兼容性，保证高版本兼容低版本。最后，撰写方案测试和使用文档。</p>
<blockquote>
<p>Reference:<br>[1] <a href="https://seata.io/zh-cn/blog/seata-analysis-simple.html">https://seata.io/zh-cn/blog/seata-analysis-simple.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Spark</title>
    <url>/2020/12/28/spark-deploy/</url>
    <content><![CDATA[<img src="/2020/12/28/spark-deploy/spark-bg.jpg" alt="See the source image" style="zoom:80%;">

<a id="more"></a>



<h1 id="部署单机环境下的Spark"><a href="#部署单机环境下的Spark" class="headerlink" title="部署单机环境下的Spark"></a>部署单机环境下的Spark</h1><ul>
<li>在官网下载Spark安装包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官网地址</span></span><br><span class="line">https://www.apache.org/dyn/closer.lua/spark/spark-2.4.7/spark-2.4.7-bin-hadoop2.7.tgz</span><br><span class="line"><span class="comment"># 下载链接</span></span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.7/spark-2.4.7-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure>

<!--more-->



<ul>
<li>解压缩</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf spark-2.4.7-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure>

<ul>
<li>安装Java</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install openjdk-8-jdk -y</span><br></pre></td></tr></table></figure>

<ul>
<li>启动Spark Shell</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> spark-2.4.7-bin-hadoop2.7</span><br><span class="line">$ bin/spark-shell</span><br><span class="line">20/12/23 18:19:08 WARN Utils: Your hostname, Mi-Lv resolves to a loopback address: 127.0.1.1; using 192.168.52.1 instead (on interface eth1)</span><br><span class="line">20/12/23 18:19:08 WARN Utils: Set SPARK_LOCAL_IP <span class="keyword">if</span> you need to <span class="built_in">bind</span> to another address</span><br><span class="line">20/12/23 18:19:08 WARN NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using <span class="built_in">builtin</span>-java classes <span class="built_in">where</span> applicable</span><br><span class="line">Using Spark<span class="string">&#x27;s default log4j profile: org/apache/spark/log4j-defaults.properties</span></span><br><span class="line"><span class="string">Setting default log level to &quot;WARN&quot;.</span></span><br><span class="line"><span class="string">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span></span><br><span class="line"><span class="string">Spark context Web UI available at http://192.168.52.1:4040</span></span><br><span class="line"><span class="string">Spark context available as &#x27;</span>sc<span class="string">&#x27; (master = local[*], app id = local-1608718759318).</span></span><br><span class="line"><span class="string">Spark session available as &#x27;</span>spark<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">Welcome to</span></span><br><span class="line"><span class="string">      ____              __</span></span><br><span class="line"><span class="string">     / __/__  ___ _____/ /__</span></span><br><span class="line"><span class="string">    _\ \/ _ \/ _ `/ __/  &#x27;</span>_/</span><br><span class="line">   /___/ .__/\_,_/_/ /_/\_\   version 2.4.7</span><br><span class="line">      /_/</span><br><span class="line">         </span><br><span class="line">Using Scala version 2.11.12 (OpenJDK 64-Bit Server VM, Java 1.8.0_275)</span><br><span class="line">Type <span class="keyword">in</span> expressions to have them evaluated.</span><br><span class="line">Type :<span class="built_in">help</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">scala&gt; </span><br></pre></td></tr></table></figure>

<ul>
<li>word count程序</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; sc.textFile(<span class="string">&quot;/home/pancras/input.txt&quot;</span>).flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_).collect</span><br><span class="line">res1: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((hello,<span class="number">2</span>), (morning,<span class="number">1</span>), (world,<span class="number">2</span>), (good,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SPDK安装指南</title>
    <url>/2021/03/04/spdk-install/</url>
    <content><![CDATA[<img src="/2021/03/04/spdk-install/spdk.jpg" alt="See the source image" style="zoom:50%;">

<a id="more"></a>



<h1 id="1-安装SPDK"><a href="#1-安装SPDK" class="headerlink" title="1. 安装SPDK"></a>1. 安装SPDK</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><ul>
<li>系统环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/version</span><br><span class="line">Linux version 5.4.0-66-generic (buildd@lgw01-amd64-039) (gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04))</span><br></pre></td></tr></table></figure>



<!--more-->



<ul>
<li>下载SPDK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:spdk/spdk.git</span><br><span class="line">$ <span class="built_in">cd</span> spdk</span><br><span class="line"><span class="comment"># 切换到某一个分支</span></span><br><span class="line">$ git checkout branch v21.01.x</span><br><span class="line"><span class="comment"># 安装子模块</span></span><br><span class="line">$ git submodule update --init</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：由于网络原因，获取子模块时可能会失败，可通过手动修改github的dns映射解决。</p>
<p>参考<a href="https://www.cnblogs.com/melodyjerry/p/13031571.html">https://www.cnblogs.com/melodyjerry/p/13031571.html</a></p>
</blockquote>
<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./scripts/pkgdep.sh</span><br></pre></td></tr></table></figure>



<ul>
<li>编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>



<h2 id="1-2-检测是否安装成功"><a href="#1-2-检测是否安装成功" class="headerlink" title="1.2 检测是否安装成功"></a>1.2 检测是否安装成功</h2><ul>
<li>执行单元测试，查看是否安装成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./<span class="built_in">test</span>/unit/unittest.sh</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">=====================</span><br><span class="line">All unit tests passed</span><br><span class="line">=====================</span><br><span class="line">WARN: lcov not installed or SPDK built without coverage!</span><br><span class="line">WARN: neither valgrind nor ASAN is enabled!</span><br></pre></td></tr></table></figure>



<h1 id="2-运行示例程序"><a href="#2-运行示例程序" class="headerlink" title="2. 运行示例程序"></a>2. 运行示例程序</h1><h2 id="2-1-分配大页面"><a href="#2-1-分配大页面" class="headerlink" title="2.1 分配大页面"></a>2.1 分配大页面</h2><p>在运行SPDK应用程序之前，必须分配一些大页面，并且必须从本机内核驱动程序中取消绑定任何NVMe和I / OAT设备。SPDK包含一个脚本，可以在Linux和FreeBSD上自动执行此过程。该脚本应该以root身份运行。它只需要在系统上运行一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo scripts/setup.sh</span><br></pre></td></tr></table></figure>

<p>要将设备重新绑定回内核，您可以运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解除绑定</span></span><br><span class="line">$ sudo scripts/setup.sh reset</span><br><span class="line"><span class="comment"># 查看所有可用参数</span></span><br><span class="line">$ sudo scripts/setup.sh <span class="built_in">help</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-查看系统中所有NVMe设备的示例程序"><a href="#2-2-查看系统中所有NVMe设备的示例程序" class="headerlink" title="2.2 查看系统中所有NVMe设备的示例程序"></a>2.2 查看系统中所有NVMe设备的示例程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/pancras/spdk</span><br><span class="line">$ sudo ./build/examples/identify</span><br><span class="line">...some info...</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Reference<br><a href="https://spdk.io/doc/getting_started.html">https://spdk.io/doc/getting_started.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>spdk</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SPDK部署iSCSI</title>
    <url>/2021/03/04/spdk-iscsi/</url>
    <content><![CDATA[<img src="/2021/03/04/spdk-iscsi/iSCSI structure.png" alt="image-20210305102234994" style="zoom: 67%;">

<a id="more"></a>



<h1 id="iSCSI"><a href="#iSCSI" class="headerlink" title="iSCSI"></a>iSCSI</h1><p>简单的说，iSCSI是一种存储设备远程映射技术，它可以将一个远程服务器上的存储设备映射到本地，并呈现为一个块设备（大白话就是磁盘）。从普通用户的角度，映射过来的磁盘与本地安装的磁盘毫无差异。iSCSI 这个架构主要将储存装置与使用的主机分为两个部分，负责连接的软件成为<strong>启动器</strong>。而提供存储服务的计算机成为服务端，其中的软件成为<strong>目标器</strong>。</p>
<ul>
<li>iSCSI Target：储存设备端，存放磁盘或 RAID 的设备。</li>
<li>iSCSI Initiator：能够使用 Target 的客户端，通常是服务器。</li>
</ul>
<p>与iSCSI类似的是NFS技术，它们都是为了解决存储资源共享的方案，只不过工作层次不一样，前者在客户机呈现的是一个块设备，后者呈现的是一个目录树。</p>
<p>在这篇文章中，我们将使用SPDK开发工具包的 <code>iscsi_tgt</code> 程序来部署iSCSI。</p>
<p>本文在第二章对部署步骤和常用命令进行介绍 ，第三章将演示一个完整的部署过程。</p>
<p>如果您想获取更详细的信息，请参考<a href="https://spdk.io/doc/iscsi.html">官方文档</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>![image-20210305102234994](spdk-iscsi/iSCSI structure.png)</p>
<ul>
<li><p><strong>Network Portal</strong>: 网络端口。网络实体的一个组成部分，它有一个 TCP/IP 地址。 网络端口在 Initiator 用 IP 地址标识， 在 Target 用 IP 地址＋侦听的 TCP 端口标识。</p>
</li>
<li><p><strong>Session</strong>: 连接 Initiator 和 Target 的一组 TCP 连接构成一个 session(可以简单理解为 I_T nexus)。可以向 session 添加 TCP 连接，也可以把 TCP 连接从 session 删除。 也就是说一个session中是可以有多个连接的。通过一个 session 的所有连接，Initiator 只看到同一个 Target。</p>
</li>
<li><p><strong>Connection</strong> : 一个 TCP 连接。Initiator 和 Target 之间使用一或者多个 TCP 连接通信。</p>
</li>
<li><p><strong>CID(Connection ID)</strong>: 一个 session 里的每个 connection 用 CID 进行标识，该标识在 session 范围内是唯一。CID 由 Initiator 产生，在 login 请求和使用 logout 关闭 连接时传递给 Target。</p>
</li>
<li><p><strong>SSID（Session ID）</strong>：一个 iSCSI Initiator 与 iSCSI Target 之间的会话（Session）由会话ID（SSID）定义，该会话ID是一个由发起方部分（ISID）和目标部分（Target Portal Group Tag）组成的元组。 ISID 在会话建立时由发起者明确指定。 Target Portal Group Tag 由发起者在连接建立时选择的 TCP端口来隐式指定。 当给定 targetName 时，targetPortalGroupTag 也必须由目标在连接建立期间作为确认返回。</p>
</li>
<li><p><strong>Portal Groups</strong>: 网络端口组。iSCSI session 支持多连接，一些实现能把通过多个端口建立的多个连接捆绑到一个 session。 一个 iSCSI 网络实体的多个网络端口被定义为一个网络端口组，把该组和一个 session 联系起来，该 session 就可以捆绑通过该组内多个端口建立的多个连接，再使它们一起协同工作以达到捆绑的目的。每一个该组的 session 并不需要包括该组的所有网络端口。一个 iSCSI 节点可能有一或者多个网络端口组，但是每一个 iSCSI 使用的网络端口只能属于 iSCSI 节点的一个组。</p>
</li>
<li><p><strong>Target Portal Group Tag</strong>: 网络端口组标识。使用 16 比特的数标识一个网络端口组。在 一个 iSCSI 节点里，所有具有同样组标志的端口构成一个网络端口组。</p>
</li>
<li><p><strong>iSCSI Task</strong>: 一个 iSCSI 任务是指一个需要响应的 iSCSI 请求。</p>
</li>
<li><p><strong>I_T nexus</strong>: I_T nexus 是指一个 SCSI Initiator 的端口和一个 SCSI Target 端口之间 的关系。 对于 iSCSI， 这个关系对应一个 session， 它指 session 的 Initiator 端和 iSCSI Target 网络端口组之间的关系。I_T nexus 的标识是一对端口名称(iSCSI Initiator 名称＋i＋ISID，iSCSI Target 名称＋t＋网络端口组标识)。 PDU (Protocol Data Unit): Initiator 和 Target 之间通信时把信息分割为消息。这些 消息称为 iSCSI PDU。 SSID (Session ID): iSCSI Initiator 和 iSCSI Target 之间的 session 用 SSID 进行标识， 该标识由 Initiator 部分的 ISID 和 Target 部分的 TPGT 构成。</p>
</li>
<li><p><strong>ISID（The Initiator part of the Session Identifier）</strong>：发起方会话标识，由 Initiator 在 session 建立的时候明确给出，</p>
</li>
<li><p><strong>TSIH (Target Session Identifying Handle)</strong>: Target 分配给与特定名称 Initiator 建立的 session 的标识。 但是 0 值被保留着用于 Initiator 告知 Target 这是一个新 session。 在为一个 session 添加一个 connect 时，TSIH 已经隐含指明。</p>
</li>
</ul>
<h1 id="iSCSI-Target入门指南"><a href="#iSCSI-Target入门指南" class="headerlink" title="iSCSI Target入门指南"></a>iSCSI Target入门指南</h1><p>我们将使用SPDK开发工具包的 <code>iscsi_tgt</code> 程序来部署iSCSI，该程序位于 <code>build/bin</code></p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本指南首先假设您已经可以在平台上构建标准SPDK发行版。 </p>
<p>构建完成后，二进制文件将位于 <code>build / bin</code> 中。</p>
<p>如果要通过信号杀死应用程序，请确保使用SIGTERM，然后应用程序将在退出前释放所有共享内存资源，SIGKILL将使共享内存资源没有机会被应用程序释放，您可能需要手动释放资源。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>下图显示了本文档中描述的iSCSI结构的不同部分之间的关系.</p>
<p>![image-20210305102234994](spdk-iscsi/iSCSI structure.png)</p>
<h3 id="将-CPU-和-iSCSI-Target-绑定"><a href="#将-CPU-和-iSCSI-Target-绑定" class="headerlink" title="将 CPU 和 iSCSI Target 绑定"></a>将 CPU 和 iSCSI Target 绑定</h3><p>SPDK使用DPDK环境抽象层来访问硬件资源，例如大内存页和CPU内核。 DPDK EAL提供了将线程分配给特定内核的功能。 为确保SPDK iSCSI目标具有最佳性能，请将NIC和NVMe设备放在同一NUMA节点上，然后将目标配置为在与该节点关联的CPU内核上运行。 以下命令行选项用于配置SPDK iSCSI Target：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-m 0xF000000</span><br></pre></td></tr></table></figure>

<p> 在此示例中，将使用CPU内核24、25、26和27。 </p>
<h2 id="通过RPC方法配置iSCSI-Target"><a href="#通过RPC方法配置iSCSI-Target" class="headerlink" title="通过RPC方法配置iSCSI Target"></a>通过RPC方法配置iSCSI Target</h2><p>iSCSI目标是通过JSON-RPC调用配置的，SPDK在 <code>spdk/scripts/rpc.py</code> 提供了一个python脚本用来简化配置。 有关详细信息，请参见<a href="https://spdk.io/doc/jsonrpc.html">JSON-RPC</a>。 </p>
<p>以下列出常用的几个命令：</p>
<h3 id="Portal-groups"><a href="#Portal-groups" class="headerlink" title="Portal groups"></a>Portal groups</h3><ul>
<li>iscsi_create_portal_group – Add a portal group.</li>
<li>iscsi_delete_portal_group – Delete an existing portal group.</li>
<li>iscsi_target_node_add_pg_ig_maps – Add Initiator group to portal group mappings to an existing iSCSI Target node.</li>
<li>iscsi_target_node_remove_pg_ig_maps – Delete Initiator group to portal group mappings from an existing iSCSI Target node.</li>
<li>iscsi_get_portal_groups – Show information about all available portal groups.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo scripts/rpc.py iscsi_create_portal_group 1 10.0.0.1:3260</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里的ip地址时你的taget主机的ip地址，端口是一个未被占用的端口</p>
</blockquote>
<h3 id="Initiator-groups"><a href="#Initiator-groups" class="headerlink" title="Initiator groups"></a>Initiator groups</h3><ul>
<li>iscsi_create_initiator_group – Add an Initiator group.</li>
<li>iscsi_delete_initiator_group – Delete an existing Initiator group.</li>
<li>iscsi_initiator_group_add_initiators – Add initiators to an existing Initiator group.</li>
<li>iscsi_get_initiator_groups – Show information about all available Initiator groups.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo scripts/rpc.py iscsi_create_initiator_group 2 ANY 10.0.0.2/32</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里的ip地址是你的client主机的ip地址</p>
</blockquote>
<h3 id="Target-nodes"><a href="#Target-nodes" class="headerlink" title="Target nodes"></a>Target nodes</h3><ul>
<li>iscsi_create_target_node – Add an iSCSI Target node.</li>
<li>iscsi_delete_target_node – Delete an iSCSI Target node.</li>
<li>iscsi_target_node_add_lun – Add a LUN to an existing iSCSI Target node.</li>
<li>iscsi_get_target_nodes – Show information about all available iSCSI Target nodes.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo scripts/rpc.py iscsi_create_target_node target3 target3_alias MyBdev:0 1:2 64 -d</span><br></pre></td></tr></table></figure>



<h2 id="配置iSCSI启动器"><a href="#配置iSCSI启动器" class="headerlink" title="配置iSCSI启动器"></a>配置iSCSI启动器</h2><p>Linux启动器是open-iscsi。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装open-iscsi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 软件包Fedora： </span></span><br><span class="line"></span><br><span class="line">$ yum install -y iscsi-initiator-utils </span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu： </span></span><br><span class="line"></span><br><span class="line">$ apt install -y open-iscsi </span><br></pre></td></tr></table></figure>



<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>假设taget主机的ip地址是 10.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iscsiadm -m discovery -t sendtargets -p 10.0.0.1</span><br></pre></td></tr></table></figure>



<h3 id="连接到Target"><a href="#连接到Target" class="headerlink" title="连接到Target"></a>连接到Target</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iscsiadm -m node --login</span><br></pre></td></tr></table></figure>

<p>此时，iSCSI目标应显示为SCSI磁盘。检查dmesg以查看它们出现的情况。</p>
<h3 id="断开与Target的连接"><a href="#断开与Target的连接" class="headerlink" title="断开与Target的连接"></a>断开与Target的连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iscsiadm -m node --<span class="built_in">logout</span></span><br></pre></td></tr></table></figure>



<h3 id="删除Target节点缓存"><a href="#删除Target节点缓存" class="headerlink" title="删除Target节点缓存"></a>删除Target节点缓存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iscsiadm -m node -o delete</span><br></pre></td></tr></table></figure>

<p>这将导致启动器忘记所有先前发现的iSCSI目标节点。</p>
<h3 id="查找iSCSI-LUN的-dev-sdX节点"><a href="#查找iSCSI-LUN的-dev-sdX节点" class="headerlink" title="查找iSCSI LUN的/ dev / sdX节点"></a>查找iSCSI LUN的/ dev / sdX节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iscsiadm -m session -P 3 | grep <span class="string">&quot;Attached scsi disk&quot;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这将显示所有已登录iSCSI会话中每个SCSI LUN的/ dev节点名称。</p>
<h1 id="示例-配置简单的iSCSI-Target"><a href="#示例-配置简单的iSCSI-Target" class="headerlink" title="示例: 配置简单的iSCSI Target"></a>示例: 配置简单的iSCSI Target</h1><blockquote>
<p> 本示例演示挂载nvme磁盘，如果没有磁盘的话可以参考<a href="https://spdk.io/doc/iscsi.html#">官方教程</a>挂载内存模拟的块设备。</p>
</blockquote>
<p>假设我们在Target端拥有一块nvme磁盘，位于192.168.0.22，现在想通过配置iSCSI让192.168.0.21主机访问到该磁盘。</p>
<h2 id="前期准备-1"><a href="#前期准备-1" class="headerlink" title="前期准备"></a>前期准备</h2><p>通过VMware在Target端挂载一块5GB的NVMe硬盘，并将控制权移交给SPDK</p>
<p>![nvme ssd](spdk-iscsi/nvme ssd.png)</p>
<ul>
<li>在Target端查看挂载情况</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /dev | grep nvme</span><br><span class="line">nvme0</span><br><span class="line">nvme0n1</span><br></pre></td></tr></table></figure>



<ul>
<li>启动SPDK，指示操作系统放弃控制设备，让SPDK控制设备</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> spdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本转让设备控制权给SPDK</span></span><br><span class="line">$ sudo /scripts/setup.sh</span><br><span class="line">0000:03:00.0 (15ad 07f0): nvme -&gt; uio_pci_generic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看设备状态</span></span><br><span class="line">$ sudo scripts/setup.sh status</span><br><span class="line">Hugepages</span><br><span class="line">node     hugesize     free /  total</span><br><span class="line">node0   1048576kB        0 /      0</span><br><span class="line">node0      2048kB     1024 /   1024</span><br><span class="line"></span><br><span class="line">Type     BDF             Vendor Device NUMA    Driver           Device     Block devices</span><br><span class="line">NVMe     0000:03:00.0    15ad   07f0   0       uio_pci_generic  -          -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时设备将从/dev目录下消失</span></span><br><span class="line">$ ls /dev | grep nvme</span><br><span class="line"><span class="comment"># 无输出信息</span></span><br></pre></td></tr></table></figure>



<h2 id="配置iSCSI-Target"><a href="#配置iSCSI-Target" class="headerlink" title="配置iSCSI Target"></a>配置iSCSI Target</h2><ul>
<li>启动 <code>iscsi_tgt</code> 应用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./build/bin/iscsi_tgt</span><br></pre></td></tr></table></figure>



<ul>
<li>创建ID为1的新的端口组，地址为 192.168.0.21:3111 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./scripts/rpc.py iscsi_create_portal_group 1 192.168.0.22:3111</span><br></pre></td></tr></table></figure>



<ul>
<li>创建一个ID为2的启动器组以接受来自0.0.0.0/0的任何连接：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./scripts/rpc.py iscsi_create_initiator_group 2 ANY 0.0.0.0/0</span><br></pre></td></tr></table></figure>



<ul>
<li>在SPDK中基于NVMe设备创建块设备(bdev)</li>
</ul>
<blockquote>
<p>也可以基于其他设备创建bdev，详见 <a href="https://spdk.io/doc/bdev.html">https://spdk.io/doc/bdev.html</a> </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取NVMe设备的地址</span></span><br><span class="line">$ sudo ./scripts/setup.sh status</span><br><span class="line">Hugepages</span><br><span class="line">node     hugesize     free /  total</span><br><span class="line">node0   1048576kB        0 /      0</span><br><span class="line">node0      2048kB      655 /   1024</span><br><span class="line"></span><br><span class="line">Type     BDF             Vendor Device NUMA    Driver           Device     Block devices</span><br><span class="line">NVMe     0000:03:00.0    15ad   07f0   0       uio_pci_generic  -          -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接本地PCIe驱动器，在系统中创建物理设备的NVMe bdev</span></span><br><span class="line">$ sudo ./scripts/rpc.py bdev_nvme_attach_controller -b NVMe1 -t PCIe -a 0000:03:00.0</span><br><span class="line">NVMe1n1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看块设备</span></span><br><span class="line">$ sudo ./scripts/rpc.py bdev_get_bdevs</span><br><span class="line">...</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;NVMe1n1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;aliases&quot;</span>: [],</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>使用先前创建的bdev构建一个目标，如LUN0（NVMe1n1），名称为“myNVMeDisk1”，别名为“My NVMe Disk1”，使用portal group 1和Initiator group 2。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./scripts/rpc.py iscsi_create_target_node myNVMeDisk1 <span class="string">&quot;My NVMe Disk1&quot;</span> <span class="string">&quot;NVMe1n1:0&quot;</span> 1:2 64 -d</span><br></pre></td></tr></table></figure>



<h2 id="配置-Initiator"><a href="#配置-Initiator" class="headerlink" title="配置 Initiator"></a>配置 Initiator</h2><ul>
<li>发现 Target</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iscsiadm -m discovery -t sendtargets -p 192.168.0.22:3111</span><br><span class="line">192.168.0.22:3111,1 iqn.2016-06.io.spdk:myNVMeDisk1</span><br></pre></td></tr></table></figure>



<ul>
<li>连接Target</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iscsiadm -m node –T iqn.2016-06.io.spdk:myNVMeDisk1 --login</span><br></pre></td></tr></table></figure>

<p>此时，iSCSI Target应该显示为SCSI磁盘。 </p>
<ul>
<li>使用 dmesg 命令以查看它们的状态。 在此示例中，它可能如下所示： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[ 3032.069633] Loading iSCSI transport class v2.0-870.</span><br><span class="line">[ 3032.096151] iscsi: registered transport (tcp)</span><br><span class="line">[ 3096.810163] scsi host33: iSCSI initiator over TCP&#x2F;IP</span><br><span class="line">[ 3096.819259] scsi 33:0:0:0: Direct-Access     INTEL    NVMe disk        0001 PQ: 0 ANSI: 5</span><br><span class="line">[ 3096.820165] sd 33:0:0:0: Attached scsi generic sg3 type 0</span><br><span class="line">[ 3096.822238] sd 33:0:0:0: [sdb] 10485760 512-byte logical blocks: (5.37 GB&#x2F;5.00 GiB)</span><br><span class="line">[ 3096.822470] sd 33:0:0:0: [sdb] Write Protect is off</span><br><span class="line">[ 3096.822472] sd 33:0:0:0: [sdb] Mode Sense: 83 00 00 08</span><br><span class="line">[ 3096.822814] sd 33:0:0:0: [sdb] Write cache: disabled, read cache: disabled, doesn&#39;t support DPO or FUA</span><br><span class="line">[ 3096.823122] sd 33:0:0:0: [sdb] Optimal transfer size 4194304 bytes</span><br><span class="line">[ 3096.829189] sd 33:0:0:0: [sdb] Attached SCSI disk</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<ul>
<li>还可以使用简单的bash命令在所有记录的iSCSI会话中为每个iSCSI LUN查找 /dev/sdX 节点： </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iscsiadm -m session -P 3 | grep <span class="string">&quot;Attached scsi disk&quot;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">sdb</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Reference<br>[1]: <a href="https://zhuanlan.zhihu.com/p/60986068">https://zhuanlan.zhihu.com/p/60986068</a><br>[2]: <a href="https://spdk.io/doc/iscsi.html">https://spdk.io/doc/iscsi.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>spdk</tag>
        <tag>iscsi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SPDK部署NVMe over TCP</title>
    <url>/2021/03/08/spdk-nvme/</url>
    <content><![CDATA[<img src="/2021/03/08/spdk-nvme/nvme-bg.jpg" alt="See the source image" style="zoom: 25%;">

<a id="more"></a>



<h1 id="1-NVMe-oF-Target入门指南"><a href="#1-NVMe-oF-Target入门指南" class="headerlink" title="1. NVMe-oF Target入门指南"></a>1. NVMe-oF Target入门指南</h1><p>SPDK NVMe over Fabrics Target是一个用户空间应用程序，通过以太网，Infiniband或光纤通道等结构呈现块设备,SPDK目前支持RDMA和TCP传输。</p>
<p>本文将在已经编译好SPDK的基础上演示如何使用SPDK搭建NVMe over TCP，前提是您已经将一块NVMe硬盘挂载到linux系统中。</p>
<p>如果您想获取有关SPDK更详细的信息，请参考 <a href="https://spdk.io/doc/iscsi.html">官方文档</a>。</p>
<p>演示过程的Host主机的ip地址是192.168.0.21，Target主机的ip地址是192.168.0.22</p>
<h2 id="1-1-Target端配置"><a href="#1-1-Target端配置" class="headerlink" title="1.1 Target端配置"></a>1.1 Target端配置</h2><blockquote>
<p> 假设您已经成功编译SPDK</p>
</blockquote>
<ul>
<li>初始化SPDK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入spdk目录</span></span><br><span class="line">$ <span class="built_in">cd</span> spdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本转让设备控制权给SPDK</span></span><br><span class="line">$ sudo scripts/setup.sh</span><br><span class="line">0000:03:00.0 (15ad 07f0): nvme -&gt; uio_pci_generic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看设备状态</span></span><br><span class="line">$ sudo scripts/setup.sh status</span><br><span class="line">Hugepages</span><br><span class="line">node     hugesize     free /  total</span><br><span class="line">node0   1048576kB        0 /      0</span><br><span class="line">node0      2048kB     1024 /   1024</span><br><span class="line"></span><br><span class="line">Type     BDF             Vendor Device NUMA    Driver           Device     Block devices</span><br><span class="line">NVMe     0000:03:00.0    15ad   07f0   0       uio_pci_generic  -          -</span><br></pre></td></tr></table></figure>



<ul>
<li>启动 <code>nvmf-tgf</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo build/bin/nvmf_tgt</span><br></pre></td></tr></table></figure>



<ul>
<li>创建TCP传输</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo scripts/rpc.py nvmf_create_transport -t TCP -u 16384 -m 8 -c 8192</span><br></pre></td></tr></table></figure>



<ul>
<li>创建 NVMe 块设备</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo scripts/rpc.py bdev_nvme_attach_controller -b NVMe1 -t PCIe -a 0000:03:00.0</span><br></pre></td></tr></table></figure>



<ul>
<li>将NVMe块设备分配给子系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建子系统</span></span><br><span class="line">$ sudo scripts/rpc.py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s SPDK00000000000001 -d SPDK_Controller1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将NVMe块设备分配给刚刚创建的子系统</span></span><br><span class="line">$ sudo scripts/rpc.py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 NVMe1n1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子系统添加TCP监听器</span></span><br><span class="line">$ sudo scripts/rpc.py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t TCP -a 192.168.0.22 -s 4420</span><br></pre></td></tr></table></figure>



<h2 id="1-2-Host端配置"><a href="#1-2-Host端配置" class="headerlink" title="1.2 Host端配置"></a>1.2 Host端配置</h2><ul>
<li>安装 nvme-cli </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nvme-cli</span><br></pre></td></tr></table></figure>



<ul>
<li>加载驱动程序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo modprobe nvme-tcp</span><br></pre></td></tr></table></figure>



<ul>
<li>发现 Target </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nvme discover -t tcp -a 192.168.0.22 -s 4420</span><br><span class="line">Discovery Log Number of Records 1, Generation counter 5</span><br><span class="line">=====Discovery Log Entry 0======</span><br><span class="line">trtype:  tcp</span><br><span class="line">adrfam:  ipv4</span><br><span class="line">subtype: nvme subsystem</span><br><span class="line">treq:    not required</span><br><span class="line">portid:  0</span><br><span class="line">trsvcid: 4420</span><br><span class="line">subnqn:  nqn.2016-06.io.spdk:cnode1</span><br><span class="line">traddr:  192.168.0.22</span><br><span class="line">sectype: none</span><br></pre></td></tr></table></figure>



<ul>
<li>连接Target</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nvme connect -t tcp -n <span class="string">&quot;nqn.2016-06.io.spdk:cnode1&quot;</span> -a 192.168.0.22 -s 4420</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看设备方法1</span></span><br><span class="line">$ sudo fdisk -l</span><br><span class="line">...</span><br><span class="line">Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors</span><br><span class="line">Disk model: SPDK_Controller1</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x441af706</span><br><span class="line"></span><br><span class="line">Device         Boot Start      End  Sectors Size Id Type</span><br><span class="line">/dev/nvme0n1p1       2048 10485759 10483712   5G 83 Linux</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看设备方法2</span></span><br><span class="line">$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0                         2:0    1    4K  0 disk </span><br><span class="line">loop0                       7:0    0 55.5M  1 loop /snap/core18/2074</span><br><span class="line">loop2                       7:2    0 67.6M  1 loop /snap/lxd/20326</span><br><span class="line">loop3                       7:3    0 32.3M  1 loop /snap/snapd/11107</span><br><span class="line">loop4                       7:4    0 32.3M  1 loop /snap/snapd/12398</span><br><span class="line">loop5                       7:5    0 55.5M  1 loop /snap/core18/1988</span><br><span class="line">loop6                       7:6    0 70.3M  1 loop /snap/lxd/21029</span><br><span class="line">sda                         8:0    0   20G  0 disk </span><br><span class="line">├─sda1                      8:1    0    1M  0 part </span><br><span class="line">├─sda2                      8:2    0    1G  0 part /boot</span><br><span class="line">└─sda3                      8:3    0   19G  0 part </span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0   19G  0 lvm  /</span><br><span class="line">sr0                        11:0    1 1024M  0 rom  </span><br><span class="line">sr1                        11:1    1  1.1G  0 rom  </span><br><span class="line">nvme0n1                   259:1    0   20G  0 disk</span><br></pre></td></tr></table></figure>

<p>此时可将块设备nvme0n1p1进行挂载访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将/dev/nvme0n1挂载到/root/data/下</span></span><br><span class="line">$ mount -t ext4 -o rw /dev/nvme0n1 /root/data/</span><br></pre></td></tr></table></figure>



<ul>
<li>取消连接Target</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvme disconnect -n <span class="string">&quot;nqn.2016-06.io.spdk:cnode1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ nvme disconnect-all</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Reference<br>[1]: <a href="https://spdk.io/doc/nvmf.html">https://spdk.io/doc/nvmf.html</a><br>[2]: <a href="https://www.cnblogs.com/JamesLi/p/11399054.html">https://www.cnblogs.com/JamesLi/p/11399054.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>spdk</tag>
        <tag>nvme</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot简介与入门</title>
    <url>/2021/04/08/spring-boot/</url>
    <content><![CDATA[<img src="/2021/04/08/spring-boot/spring-boot.png" alt="img" style="zoom:50%;">

<a id="more"></a>



<h1 id="1-SpringBoot快速入门"><a href="#1-SpringBoot快速入门" class="headerlink" title="1. SpringBoot快速入门"></a>1. SpringBoot快速入门</h1><h2 id="1-1-Quickstart"><a href="#1-1-Quickstart" class="headerlink" title="1.1 Quickstart"></a>1.1 Quickstart</h2><ul>
<li>pom.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>主程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>业务逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>默认包结构<ul>
<li>主程序同包或主程序子包下的类</li>
<li>使用 <code>@SpringBootApplication(scanBasePackages=&quot;indi.pancras&quot;)</code> 指定</li>
<li>使用 <code>@ComponentScan(&quot;indi.pancras&quot;)</code> 指定扫面路径</li>
</ul>
</li>
</ul>
<h2 id="1-2-配置绑定"><a href="#1-2-配置绑定" class="headerlink" title="1.2 配置绑定"></a>1.2 配置绑定</h2><ul>
<li>Car.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Integer price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>application.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">mycar.brand</span>=<span class="string">BYD</span></span><br><span class="line"><span class="meta">mycar.price</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure>



<h1 id="2-SpringBoot的两大机制"><a href="#2-SpringBoot的两大机制" class="headerlink" title="2. SpringBoot的两大机制"></a>2. SpringBoot的两大机制</h1><h2 id="2-1-依赖管理"><a href="#2-1-依赖管理" class="headerlink" title="2.1 依赖管理"></a>2.1 依赖管理</h2><ul>
<li>父项目做依赖管理</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开发场景导入starter场景启动器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-自动配置"><a href="#2-2-自动配置" class="headerlink" title="2.2 自动配置"></a>2.2 自动配置</h2><ul>
<li>自动配好Tomcat<ul>
<li>引入Tomcat依赖</li>
</ul>
</li>
<li>自动配好SpringMVC</li>
<li>自动配好web常见功能：如字符编码问题</li>
<li>默认的包结构</li>
<li>各种配置拥有默认值</li>
<li>按需加载所有自动配置项</li>
<li>…</li>
</ul>
<h1 id="3-SpringBoot功能"><a href="#3-SpringBoot功能" class="headerlink" title="3. SpringBoot功能"></a>3. SpringBoot功能</h1><h2 id="3-1-组件添加"><a href="#3-1-组件添加" class="headerlink" title="3.1 组件添加"></a>3.1 组件添加</h2><ul>
<li>@Configuration</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, pet01());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pet01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>Full 模式和 Lite 模式</p>
<ul>
<li>组件无依赖：采用Lite模式，启动快</li>
<li>组件有依赖：采用Full模式，多了一些判断步骤</li>
</ul>
</li>
<li><p>@Import</p>
<ul>
<li>向容器中加入组件，默认是全类名</li>
</ul>
</li>
<li><p>@Conditional</p>
<ul>
<li>条件装配</li>
</ul>
</li>
<li><p>@ImportResource</p>
<ul>
<li>导入xml中的bean</li>
</ul>
</li>
</ul>
<h2 id="3-2-配置绑定"><a href="#3-2-配置绑定" class="headerlink" title="3.2 配置绑定"></a>3.2 配置绑定</h2><p>将properties中的配置绑定到配置类中</p>
<ul>
<li><p>@ConfigurationProperties+@Component</p>
<ul>
<li><pre><code class="JAVA">@Component
@ConfigurationProperties(prefix = &quot;mycar&quot;)
public class Car &#123;
    private String brand;
    private Integer price;
&#125;

//mycar.brand=BYD
//mycar.price=100000
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ @EnableConfigurationProperties</span><br><span class="line"></span><br><span class="line">  + &#96;&#96;&#96;java</span><br><span class="line">    @Configuration</span><br><span class="line">    @EnableConfigurationProperties(Car.class)&#x2F;&#x2F; 开启Car的属性配置</span><br><span class="line">    public class MyConfig &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;car&quot;)</span><br><span class="line">    @Data</span><br><span class="line">    @ToString</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    public class Car &#123;</span><br><span class="line">        private String brand;</span><br><span class="line">        private Integer price;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-最佳实践"><a href="#3-3-最佳实践" class="headerlink" title="3.3 最佳实践"></a>3.3 最佳实践</h2><ul>
<li>引入场景依赖</li>
<li>修改配置项</li>
<li>替换部分组件</li>
</ul>
<h1 id="4-Web开发"><a href="#4-Web开发" class="headerlink" title="4. Web开发"></a>4. Web开发</h1><h2 id="4-1-应用配置项"><a href="#4-1-应用配置项" class="headerlink" title="4.1 应用配置项"></a>4.1 应用配置项</h2><ul>
<li>静态资源的访问</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 修改静态资源的请求路径</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line">  <span class="comment"># 修改静态资源的物理位置</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> [ <span class="string">classpath:/images</span> ]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>spring- boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-mvc</title>
    <url>/2021/05/28/spring-mvc/</url>
    <content><![CDATA[<img src="/2021/05/28/spring-mvc/springmvc-bg.jpg" alt="modules" style="zoom: 67%;">



<a id="more"></a>



<h1 id="1-MVC基本概念"><a href="#1-MVC基本概念" class="headerlink" title="1. MVC基本概念"></a>1. MVC基本概念</h1><p>（1）Controller：控制器</p>
<ul>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定页面</li>
</ul>
<p>（2）Model：模型</p>
<ul>
<li>业务逻辑</li>
<li>保存数据</li>
<li>处理数据库</li>
</ul>
<p>（3）View：视图</p>
<ul>
<li>显示页面</li>
</ul>
<p>（4）SpringMVC架构图如下：</p>
<p><img src="/2021/05/28/spring-mvc/spring-mvc.png" alt="mvc"></p>
<h1 id="2-DispatcherServlet"><a href="#2-DispatcherServlet" class="headerlink" title="2. DispatcherServlet"></a>2. DispatcherServlet</h1><ul>
<li>DispatcherServlet：负责将请求分发到不同的处理单元</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &#x2F;：匹配所有的请求，不包括*.jsp  &#x2F;*：匹配所有的请求，包括*.jsp --&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于web应用，需要在pom.xml中显式配置packagin为war</li>
</ul>
<h1 id="3-RESTful风格"><a href="#3-RESTful风格" class="headerlink" title="3. RESTful风格"></a>3. RESTful风格</h1><ul>
<li><p>传统： <a href="http://localhost/item/queryItem.action?id=1">http://localhost/item/queryItem.action?id=1</a></p>
</li>
<li><p>RESTful：</p>
<ul>
<li><a href="http://localhost/item/1">http://localhost/item/1</a> + GET 表示查询</li>
<li><a href="http://localhost/item/1">http://localhost/item/1</a> + PUT 表示更新</li>
</ul>
</li>
</ul>
<h1 id="4-转发和重定向"><a href="#4-转发和重定向" class="headerlink" title="4. 转发和重定向"></a>4. 转发和重定向</h1><ul>
<li>转发</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;<span class="comment">//配置了视图解析器的前缀后缀</span></span><br></pre></td></tr></table></figure>



<ul>
<li>重定向</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="5-常用注解"><a href="#5-常用注解" class="headerlink" title="5. 常用注解"></a>5. 常用注解</h1><ul>
<li>@ResponseBody：直接返回字符串，不再走视图解析器</li>
</ul>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spirng5快速入门</title>
    <url>/2021/03/26/spring5/</url>
    <content><![CDATA[<img src="/2021/03/26/spring5/spring5.png" style="zoom: 50%;">

<a id="more"></a>



<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><p>（1）轻量级的JavaEE开发框架</p>
<p>（2）Spring的两个特性</p>
<ul>
<li>IOC：控制反转，将创建对象的过程交给Spring进行管理</li>
<li>AOP：面向切面，不修改源代码的情况加进行功能增强</li>
</ul>
<h1 id="2-IOC容器"><a href="#2-IOC容器" class="headerlink" title="2. IOC容器"></a>2. IOC容器</h1><p><strong>控制反转：从主动创建对象变为被动接受对象</strong>（例如使用setter方式创建）</p>
<p>IOC是一个容器，帮我们管理所有的组件。</p>
<p>容器启动的时候创建所有单实例对象。</p>
<p>我们可以从直接从容器中获取到这个对象。</p>
<p>DI是实现IOC的一种方法。</p>
<ul>
<li><p><strong>Question 1：</strong>IOC容器的启动过程？启动期间都做了什么？</p>
<ul>
<li><ol>
<li><pre><code class="java"> // 构造器ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;); // 构造器
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 执行refresh()</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;java</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();&#x2F;&#x2F; 解析xml文件</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="java">finishBeanFactoryInitialization(beanFactory); // 初始化bean
//调用了↓进行初始化
beanFactory.preInstantiateSingletons();
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;&#96;&#96;java</span><br><span class="line">   &#x2F;&#x2F; 获取需要创建的单实例对象</span><br><span class="line">   List&lt;String&gt; beanNames &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 获取代创建bean的类信息</span><br><span class="line">   RootBeanDefinition bd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 创建非抽象单实例对象</span><br><span class="line">   if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())&#123;</span><br><span class="line">       &#x2F;&#x2F; 创建对象</span><br><span class="line">       getBean(xx);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 创建好的对象最终保存在map中</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Question 2：</strong>IOC是如何创建并管理单实例bean的？保存到了哪里？</li>
</ul>
<h2 id="2-1-IOC概念和原理"><a href="#2-1-IOC概念和原理" class="headerlink" title="2.1 IOC概念和原理"></a>2.1 IOC概念和原理</h2><h3 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h3><ol>
<li><p>什么是IOC</p>
<p>（1） 控制反转：把对象创建和对象之间的调用过程交给Spring进行管理</p>
<p>（2） 使用IOC的目的：降低耦合度</p>
<ul>
<li>控制：资源的获取方式<ul>
<li>主动式：使用new方式创建资源，复杂对象的创建过于繁琐、麻烦。</li>
<li>被动式：资源的创建过程由容器来创建和设置，我们直接使用资源即可。</li>
</ul>
</li>
<li>容器：管理所有的组件（有功能的类）。</li>
<li>反转：将资源创建的过程交给Spring来做。</li>
<li>DI，Denpendency Injection：依赖注入，通过反射创建组件。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-底层原理"><a href="#2-1-2-底层原理" class="headerlink" title="2.1.2 底层原理"></a>2.1.2 底层原理</h3><ol>
<li><p>IOC底层原理</p>
<p>（1）xml解析、工厂模式、反射</p>
</li>
</ol>
<h2 id="2-2-IOC操作Bean管理（基于注解）"><a href="#2-2-IOC操作Bean管理（基于注解）" class="headerlink" title="2.2 IOC操作Bean管理（基于注解）"></a>2.2 IOC操作Bean管理（基于注解）</h2><blockquote>
<p>tips：使用xml管理bean，使用注解注入属性</p>
</blockquote>
<h3 id="2-2-1-使用注解创建对象"><a href="#2-2-1-使用注解创建对象" class="headerlink" title="2.2.1 使用注解创建对象"></a>2.2.1 使用注解创建对象</h3><ul>
<li><p>@Component：控制器，推荐给控制器层（servlet包下的组件）添加</p>
</li>
<li><p>@Service：业务逻辑，推荐个service包下的组件添加</p>
</li>
<li><p>@Repository：数据库层（持久化层、dao层）的组件添加</p>
</li>
<li><p>@Controller：不属于以上三层的组件</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;indi.pancras.spring5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-使用注解注入属性"><a href="#2-2-2-使用注解注入属性" class="headerlink" title="2.2.2 使用注解注入属性"></a>2.2.2 使用注解注入属性</h3><p><strong>A. @Autowired</strong></p>
<p>根据属性类型进行注入</p>
<p>原理：</p>
<ul>
<li>按照类型区容器中寻找对应的组件：<strong>bookService = ioc.getBean(BookService.class);</strong><ul>
<li>① 找到一个就赋值</li>
<li>② 没找到，抛异常（或者可通过设置<strong>required=false</strong>设置为<strong>null</strong>）</li>
<li>③ 找到多个，按照变量名作为id进行匹配：<strong>bookService = ioc.getBean(“bookService”);</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法上有@Autowire时，方法的每一个参数都会自动注入值</p>
</blockquote>
<p><strong>B. @Qualifier</strong></p>
<p>当同一个接口有两个实现类时，使用 <code>@Qualifier</code> 指定id进行装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserService.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class">    @<span class="title">Autowired</span></span></span><br><span class="line"><span class="class">    @<span class="title">Qualifier</span>(<span class="title">value</span> </span>= <span class="string">&quot;userDaoImpl2&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>);</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>C. @Resource</strong></p>
<p>根据属性类型或属性名称注入</p>
<blockquote>
<p>属于java拓展包里的内容，不建议使用</p>
</blockquote>
<p><strong>D. @Value</strong></p>
<p>注入普通类型属性，和配置文件搭配使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;my name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add....&quot;</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-Bean的作用域和生命周期"><a href="#2-3-Bean的作用域和生命周期" class="headerlink" title="2.3 Bean的作用域和生命周期"></a>2.3 Bean的作用域和生命周期</h2><ul>
<li>默认单实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        User user1 = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        User user2 = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user1);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">indi.pancras.spring5.User@f107c50</span></span><br><span class="line"><span class="comment">indi.pancras.spring5.User@f107c50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过scope属性配置作用域</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.pancras.spring5.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.pancras.spring5.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4-Java配置类"><a href="#2-4-Java配置类" class="headerlink" title="2.4 Java配置类"></a>2.4 Java配置类</h2><p>使用@Configuration表明，等效于xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 方法名就是bean的id</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfiguration.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3 AOP"></a>3 AOP</h1><h2 id="3-1-AOP概念和原理"><a href="#3-1-AOP概念和原理" class="headerlink" title="3.1 AOP概念和原理"></a>3.1 AOP概念和原理</h2><h3 id="3-1-1-什么是AOP"><a href="#3-1-1-什么是AOP" class="headerlink" title="3.1.1 什么是AOP"></a>3.1.1 什么是AOP</h3><ul>
<li>定义：AOP（Aspect Oriented Programming）：面向切面编程，指在<strong>程序运行期间</strong>，将<font color="red"><strong>某段代码</strong></font><font color="blue"><strong>动态的切入</strong></font>到**<font color="green">指定方法的指定位置</font>**进行运行的编程方式。</li>
<li>场景：计算器运行计算方法的时候进行日志记录<ul>
<li>直接编写在方法内部：耦合度太高，修改维护麻烦，不推荐</li>
<li>使用动态代理加入日志</li>
</ul>
</li>
<li>JDK动态代理缺陷：如果类没有实现任何接口，则不能创建代理。</li>
<li>Spring动态代理：实现简单，无需要求被代理类实现接口</li>
<li>AOP的底层：动态代理  </li>
</ul>
<p>降低模块的耦合度、添加新的功能而不修改源代码</p>
<h3 id="3-1-2-AOP底层原理"><a href="#3-1-2-AOP底层原理" class="headerlink" title="3.1.2 AOP底层原理"></a>3.1.2 AOP底层原理</h3><p>使用动态代理：</p>
<ul>
<li>有接口：使用JDK动态代理</li>
<li>无接口：使用CGLIB动态代理 </li>
</ul>
<h3 id="3-1-3-专业术语"><a href="#3-1-3-专业术语" class="headerlink" title="3.1.3 专业术语"></a>3.1.3 专业术语</h3><ul>
<li>连接点：每一个方法的每一个可以被通知的位置</li>
<li>切入点：连接点的子类，实际被插入代码的</li>
<li>通知（增强）：实际增强的逻辑<ul>
<li>前置通知：方法执行前执行，@Before</li>
<li>后置通知：方法执行后执行，@After</li>
<li>环绕通知：方法执行前后执行，@Around</li>
<li>异常通知：方法出现异常时执行，@AfterThrowing</li>
<li>返回通知：方法返回后执行，@AfterReturning</li>
</ul>
</li>
<li>切面：把通知应用到切入点的过程</li>
</ul>
<p><strong>(4) 使用场景</strong></p>
<ul>
<li>AOP+日志保存到数据库中</li>
<li>权限认证</li>
<li>安全检查</li>
<li>事务控制</li>
</ul>
<h2 id="3-2-AOP操作"><a href="#3-2-AOP操作" class="headerlink" title="3.2 AOP操作"></a>3.2 AOP操作</h2><p>Spring框架一般基于AspectJ实现AOP操作</p>
<h3 id="3-2-1-切入点表达式"><a href="#3-2-1-切入点表达式" class="headerlink" title="3.2.1 切入点表达式"></a>3.2.1 切入点表达式</h3><ul>
<li>execution()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对indi.pancras.spring5.User类里面的add()进行增强</span></span><br><span class="line">execution(* indi.pancras.spring5.User.add(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对indi.pancras.spring5.User类里面的所有方法进行增强</span></span><br><span class="line">execution(* indi.pancras.spring5.User.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对indi.pancras.spring5包里的所有类的所有方法进行增强</span></span><br><span class="line">execution(* indi.pancras.spring5.*.*(..))</span><br></pre></td></tr></table></figure>



<h3 id="3-2-2-一个示例"><a href="#3-2-2-一个示例" class="headerlink" title="3.2.2 一个示例"></a>3.2.2 一个示例</h3><ul>
<li>bean5.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;indi.pancras.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>User.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserProxy.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.pancras.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* indi.pancras.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean5.xml&quot;</span>);</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<blockquote>
<p>Reference:</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack Swift中间件的原理及编写方式</title>
    <url>/2020/09/15/swift-middleware/</url>
    <content><![CDATA[<img src="/2020/09/15/swift-middleware/middleware01.jpeg" alt="img" style="zoom: 67%;">

<a id="more"></a>



<h1 id="中间件原理"><a href="#中间件原理" class="headerlink" title="中间件原理"></a>中间件原理</h1><h2 id="中间件的数据流"><a href="#中间件的数据流" class="headerlink" title="中间件的数据流"></a>中间件的数据流</h2><p>OpenStack Swift的中间件采用流处理模式，如图1-1所示，最外层的中间件收到请求，并可能会对它进行修改，然后再传递给下一层中间件。随后，下一层中间件同样可能在请求向内层传递前对它进行修改。当请求到达中间件管道（pipeline）的末尾时，由 Swift 核⼼心程序进行处理，并产生一个响应。之后，响应顺着管道反向传递，管道中所有中间件都可以对响应进行修改。当然，任何一层中间件也可以选择不对请求或响应做任何更改(大多数情况下都如此)。一旦最外层的中间件对响应进行处理(或者不作任何修改)之后，最终的响应就会返回给⽤用户。 </p>
<!--more-->

<table>
<thead>
<tr>
<th align="center"><img src="/2020/09/15/swift-middleware/middleware01.jpeg" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">图1-1 中间件的数据流图</td>
</tr>
</tbody></table>
<h2 id="中间件的短路请求"><a href="#中间件的短路请求" class="headerlink" title="中间件的短路请求"></a>中间件的短路请求</h2><p>管道的每层中间件都可以短路请求并返回一个响应或错误。例如，如果未认证用户想要执行一个 需要认证的操作，认证中间件就会返回一个错误。当收到健康检查请求时，健康检查中间件可以选择 直接返回一个成功的响应，而不会继续向内层中间件传递该健康检查请求。在这些短路的例子中，都 不会将请求传递到下游的中间件或Swift核心程序，如图1-2所示。</p>
<table>
<thead>
<tr>
<th align="center"><img src="/2020/09/15/swift-middleware/middleware02.jpeg" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">图1-2 中间件的短路请求</td>
</tr>
</tbody></table>
<h1 id="中间件的编写"><a href="#中间件的编写" class="headerlink" title="中间件的编写"></a>中间件的编写</h1><h2 id="修改请求头部信息"><a href="#修改请求头部信息" class="headerlink" title="修改请求头部信息"></a>修改请求头部信息</h2><p>对头部信息的修改不会直接更改头部，而是通过一个函数完成，如果该函数被调⽤，除了完成start_response的工作，还会添加一个额外的头部。代码样例如下所示，我们将new_start_response作为app的第二个参数向下传递即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderAddingMiddleware</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, app</span>):</span></span><br><span class="line">        self.app = app</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">env, start_response</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">new_start_response</span>(<span class="params">status, headers</span>):</span></span><br><span class="line">            <span class="keyword">return</span> start_response(status, headers+(<span class="string">&#x27;X-New-Header&#x27;</span>, <span class="string">&#x27;info&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> self.app(env, new_start_response)</span><br></pre></td></tr></table></figure>

<h2 id="修改响应数据"><a href="#修改响应数据" class="headerlink" title="修改响应数据"></a>修改响应数据</h2><p>调用self.app(env,  start_response)会将数据传入到下一个中间件，并在其之后的中间件处理完毕后传回相应，因此对响应数据的修改就是对self.app(env, start_response)的返回值进行修改。需要注意的是，返回值类型是生成器类型（generator，一种特殊的迭代器），如果我们使用其进行遍历操作，需要先使用itertools.tee()方法复制生成器。下面是将响应数据转换成大写字符的例子（假设响应数据为字符串）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModifyDataMiddleware</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, app</span>):</span></span><br><span class="line">        self.app = app</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">env, start_response</span>):</span></span><br><span class="line">        <span class="comment"># 需要注意，body类型是生成器类型（generator，一种特殊的迭代器），因此如果需要遍历时，需要先进行复制</span></span><br><span class="line">        body = self.app(env, start_response)</span><br><span class="line">        <span class="comment"># 复制生成器</span></span><br><span class="line">        body, body1 = itertools.tee(body, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 查看body的数据，或者修改body的数据为大写（假设为字符数据）</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> body1:</span><br><span class="line">            pprint(chunk)</span><br><span class="line">            chunk.upper()</span><br><span class="line">        <span class="keyword">return</span> body</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Reference ：</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存地址</title>
    <url>/2020/11/15/virtual-memory-address-space/</url>
    <content><![CDATA[<img src="/2020/11/15/virtual-memory-address-space/address-space.png" alt="image-20201115181629849" style="zoom:50%;">

<a id="more"></a>



<h1 id="虚拟内存的地址空间"><a href="#虚拟内存的地址空间" class="headerlink" title="虚拟内存的地址空间"></a>虚拟内存的地址空间</h1><ul>
<li>虚拟内存的地址空间如下图所示</li>
</ul>
<p><img src="/2020/11/15/virtual-memory-address-space/address-space.png" alt="image-20201115181629849"></p>
<ul>
<li><p>通过c程序进行验证</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;code address: %p\n&quot;</span>, main);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap address: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">10e7</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack address: %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out:</span></span><br><span class="line">code address: <span class="number">0x7fa463a1f189</span></span><br><span class="line">heap address: <span class="number">0x7fa45d880010</span></span><br><span class="line"><span class="built_in">stack</span> address: <span class="number">0x7fffc7df9124</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>os</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 编程示例</title>
    <url>/2021/04/14/java-basic-concepts/</url>
    <content><![CDATA[<img src="/2021/04/14/java-basic-concepts/java.jpg" alt="General 1920x1080 Java development logo" style="zoom: 25%;">

<a id="more"></a>



<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><ul>
<li>面向对象（封装、继承、多态）</li>
<li>由于jvm的存在，Java和平台无关，一次编译，多地运行</li>
<li>编译和解释并存：Java源码→（javac编译）→.class字节码→（JVM解释）→机器码<ul>
<li>为了加速解释过程，引入运行时编译，即JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</li>
</ul>
</li>
<li>支持网络编程和多线程，能很方便地编写出多线程程序和网络程序。</li>
<li>自动内存管理，无需像C++一样要手动管理内存。</li>
</ul>
<h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h1><h2 id="2-1-Java容器之间的区别"><a href="#2-1-Java容器之间的区别" class="headerlink" title="2.1 Java容器之间的区别"></a>2.1 Java容器之间的区别</h2><p><strong>（1）ArrayList、Vector、LinkedList的区别？</strong></p>
<ul>
<li>同</li>
</ul>
<p>都实现了 <code>List</code> 接口，用来存储有序、可重复的数据</p>
<ul>
<li>异</li>
</ul>
<p><code>ArrayList</code>是<code>List</code>的主要实现类，底层采用<code>Object[]</code>存储，线程不安全，效率高。</p>
<p><code>Vector</code>是<code>List</code>的古老实现类，底层采用<code>Object[]</code>存储，线程安全，效率低。</p>
<p><code>LinkedList</code>底层采用双向链表存储，线程不安全。</p>
<p><strong>（2）HashSet、LinkedHashSet、HashTree的区别？</strong></p>
<ul>
<li>同</li>
</ul>
<p>都实现了 <code>Set</code> 接口，用来存储无序、不可重复的数据</p>
<ul>
<li>异</li>
</ul>
<p><code>HashSet</code>： <code>Set</code> 接口的主要实现类，线程不安全，可存储 <code>null</code> </p>
<p><code>LinkedHashSet</code>：<code>HashSet</code> 的子类，遍历其内部数据时，可以按照添加的顺序遍历。每个节点处理包含自身数据，还记录了前一个数据和后一个数据的应用，在频繁遍历时效率高</p>
<p><code>TreeSet</code>：可以按照添加元素的指定属性进行排序，元素必须是同一个类，底层采用红黑树</p>
<p><strong>（3）HashMap、HashTable、TreeMap的区别？</strong></p>
<ul>
<li><code>HashMap</code>： <code>Map</code> 的主要实现类，线程不安全，效率高，可以存储 <code>null</code> ， jdk7 之前底层时数组+链表， jdk8 采用数组+链表+红黑树，具体为：当数组中某一个索引位置上的以链表形式存在的元素个数&gt;8且当前数组长度&gt;64时，改用数组+红黑树存储<ul>
<li><code>LinkedHashMap</code>：在遍历元素时，可以按照添加顺序遍历，每个节点多了一对指针，指向前一个和后一个元素，适合频繁的遍历操作。</li>
</ul>
</li>
<li><code>HashTable</code>： <code>Map</code> 的古老实现类，线程安全，效率低，不能存储<code>null</code><ul>
<li><code>Prosperities</code>：常用来处理配置文件， Key 和 Value 都是 String 类型</li>
</ul>
</li>
<li><code>TreeMap</code>：可以按照Key值进行排序</li>
</ul>
<p><strong>（4）自定义类需要重写的方法</strong></p>
<ul>
<li>HashSet、LinkedHashSet<ul>
<li>重写equals、hashCode</li>
</ul>
</li>
<li>TreeSet<ul>
<li>如果要自定义排序：Comparable、Comparator</li>
</ul>
</li>
</ul>
<h2 id="2-2-Java-int-和-List-lt-gt-的相互转换"><a href="#2-2-Java-int-和-List-lt-gt-的相互转换" class="headerlink" title="2.2 Java int[] 和 List&lt;&gt; 的相互转换"></a>2.2 Java int[] 和 List&lt;&gt; 的相互转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java 8的Stream</span></span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Arrays.asList</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Guava</span></span><br><span class="line"><span class="comment">//对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于可变集合，你可以使用Lists类及其newArrayList()工厂方法：</span></span><br><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>



<p><strong>不要在 foreach 循环里进行元素的 remove/add 操作</strong></p>
<img src="/2021/04/14/java-basic-concepts/foreach-remove-add.png" alt="image-20210519155801109" style="zoom:50%;">



<h2 id="2-3-String类和常量池"><a href="#2-3-String类和常量池" class="headerlink" title="2.3 String类和常量池"></a>2.3 String类和常量池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abcd&quot;</span>;<span class="comment">//如果字符串常量池中没有&quot;abcd&quot;，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;；</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str4 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;cd&quot;</span>).toString();<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str5 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;cd&quot;</span>).toString();<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str6 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;cd&quot;</span>).toString().intern();<span class="comment">//常量池中有&quot;abcd&quot;，因此str6指向它</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str1:&quot;</span> + System.identityHashCode(str1));</span><br><span class="line">        System.out.println(<span class="string">&quot;str2:&quot;</span> + System.identityHashCode(str2));</span><br><span class="line">        System.out.println(<span class="string">&quot;str3:&quot;</span> + System.identityHashCode(str3));</span><br><span class="line">        System.out.println(<span class="string">&quot;str4:&quot;</span> + System.identityHashCode(str4));</span><br><span class="line">        System.out.println(<span class="string">&quot;str5:&quot;</span> + System.identityHashCode(str5));</span><br><span class="line">        System.out.println(<span class="string">&quot;str6:&quot;</span> + System.identityHashCode(str6));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str1:711327356</span></span><br><span class="line"><span class="comment">str2:1297978429</span></span><br><span class="line"><span class="comment">str3:915349526</span></span><br><span class="line"><span class="comment">str4:1280851663</span></span><br><span class="line"><span class="comment">str5:1764696127</span></span><br><span class="line"><span class="comment">str6:711327356</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
</blockquote>
<ul>
<li>intern()方法：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.6及之前的处理方式是<strong>在常量池中创建</strong>与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7及之后的处理方式是<strong>在常量池中记录</strong>此字符串的引用，并返回该引用。</li>
</ul>
<h1 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><ul>
<li>程序（program）：一段静态的代码。</li>
<li>进程（process）：正在运行的一个程序。是<strong>资源分配的单位</strong>。</li>
<li>线程（thread）：进程可进一步细化为线程，是一个程序内部的一条执行路径。是<strong>调度和执行的单位</strong>。</li>
</ul>
<h2 id="3-2-线程的创建和使用"><a href="#3-2-线程的创建和使用" class="headerlink" title="3.2 线程的创建和使用"></a>3.2 线程的创建和使用</h2><ul>
<li>方法一：继承 <code>Thread</code> 类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyThreadTest.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//t1.join();</span></span><br><span class="line">        <span class="comment">//t2.join();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>方法二：实现 <code>Runnable</code> 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyRunnableTest.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        t1.start();t2.start();t3.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();t2.join();t3.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>方法三：实现  <code>Callable</code> 接口（新）<ul>
<li>重写 <code>call()</code> 方法，相比 <code>run()</code> 方法，可以有返回值</li>
<li>可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助 <code>FutureTask</code> 类，比如获取返回结果</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(myCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>方法四：使用线程池（新）<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次创建）</li>
<li>便于线程管理  </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread2());<span class="comment">//适合Runnable</span></span><br><span class="line">        <span class="comment">//service.submit();//适合Callable</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-3-线程的生命周期"><a href="#3-3-线程的生命周期" class="headerlink" title="3.3 线程的生命周期"></a>3.3 线程的生命周期</h2><p><img src="/2021/04/14/java-basic-concepts/lifecycle.png" alt="image-20210602102740366"></p>
<h2 id="3-4-线程的同步"><a href="#3-4-线程的同步" class="headerlink" title="3.4 线程的同步"></a>3.4 线程的同步</h2><ul>
<li>方式一：同步代码块（多个线程需要同用一把锁lock）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票，票号为：&quot;</span> + tickets);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>方式二：同步方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runnable实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        sell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;<span class="comment">// 同步监视器：this</span></span><br><span class="line">        <span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票，票号为：&quot;</span> + tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// private synchronized void sell() &#123;// 同步监视器：t1,t2,t3</span></span><br><span class="line">        <span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票，票号为：&quot;</span> + tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>方式三：Lock锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票，票号为：&quot;</span> + tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-线程的通信"><a href="#3-5-线程的通信" class="headerlink" title="3.5 线程的通信"></a>3.5 线程的通信</h2><p><strong>（1）两个线程交替从1打印到100</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（2）生产者消费者问题</strong></p>
<ul>
<li>Productor.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + name + <span class="string">&quot;准备生产商品&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Consumer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + name + <span class="string">&quot;准备消费商品&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Clerk.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (productCount &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始生产&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productCount++;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始消费&quot;</span> + productCount + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productCount--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>test.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProConTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        Productor productor = <span class="keyword">new</span> Productor(clerk);</span><br><span class="line">        productor.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        consumer.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread p1 = <span class="keyword">new</span> Thread(productor);</span><br><span class="line">        Thread c1 = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">        Thread c2 = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p1.join();</span><br><span class="line">            c1.join();</span><br><span class="line">            c2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="4-I-O流"><a href="#4-I-O流" class="headerlink" title="4. I/O流"></a>4. I/O流</h1><h2 id="4-1-File类的基本使用"><a href="#4-1-File类的基本使用" class="headerlink" title="4.1 File类的基本使用"></a>4.1 File类的基本使用</h2><ul>
<li><p>java.io.File</p>
<ul>
<li>一个File对象代表一个文件或文件目录</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个与hello.txt同目录下的文件，文件名为good.txt</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">File destFile = <span class="keyword">new</span> File(file.getAbsoluteFile().getParent(), <span class="string">&quot;good.txt&quot;</span>);</span><br><span class="line">destFile.createNewFile();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line">destFile.delete();</span><br></pre></td></tr></table></figure>



<h2 id="4-2-IO流原理及流的分类"><a href="#4-2-IO流原理及流的分类" class="headerlink" title="4.2 IO流原理及流的分类"></a>4.2 IO流原理及流的分类</h2><p><strong>（1）流的分类</strong></p>
<ul>
<li>按数据单位：字节流（8bit）、字符流（16bit）</li>
<li>按数据流向：输入流、输出流</li>
<li>按流的角色：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td align="center">Wrider</td>
</tr>
</tbody></table>
<ul>
<li>IO流体系</li>
</ul>
<p><img src="/2021/04/14/java-basic-concepts/iostream.png" alt="img"></p>
<p><strong>（2）流的使用</strong></p>
<ul>
<li>FileReader</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">       Reader reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">       <span class="keyword">int</span> data;</span><br><span class="line">       <span class="keyword">while</span>((data = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">       &#125;</span><br><span class="line">       reader.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReader1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">       Reader reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">       <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">       <span class="keyword">int</span> len;</span><br><span class="line">       <span class="keyword">while</span> ((len = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print(String.valueOf(cbuf, <span class="number">0</span>, len));</span><br><span class="line">       &#125;</span><br><span class="line">       reader.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>FileWriter</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFileWriter</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">    Writer w = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">    w.write(<span class="string">&quot;hello, world!你好&quot;</span>);</span><br><span class="line">    w.write(<span class="string">&quot;hello, world!你好&quot;</span>);</span><br><span class="line">    w.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-节点流（文件流）"><a href="#4-3-节点流（文件流）" class="headerlink" title="4.3 节点流（文件流）"></a>4.3 节点流（文件流）</h2><p>使用FileReader、FileWrite复制文本文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFileReaderWriterCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File src = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">&quot;dest.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(src);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(dest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用FileInputStream、FileOutputStream复制二进制文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testFileInOutStreamCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       File src = <span class="keyword">new</span> File(<span class="string">&quot;curl.jpeg&quot;</span>);</span><br><span class="line">       File dest = <span class="keyword">new</span> File(<span class="string">&quot;curl1.jpeg&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           InputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">           OutputStream fout = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">           <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> ((len = fin.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               fout.write(buf, <span class="number">0</span>, len);</span><br><span class="line">           &#125;</span><br><span class="line">           fin.close();</span><br><span class="line">           fout.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-4-缓冲流"><a href="#4-4-缓冲流" class="headerlink" title="4.4 缓冲流"></a>4.4 缓冲流</h2><p><strong>提升流的读取、写入速度。</strong></p>
<ul>
<li>二进制文件的复制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBufferedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File src = <span class="keyword">new</span> File(<span class="string">&quot;curl.jpeg&quot;</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">&quot;curl1.jpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bin.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bout.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭外层流的同时，会自动关闭内层流</span></span><br><span class="line">        bin.close();</span><br><span class="line">        bout.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-5-转换流"><a href="#4-5-转换流" class="headerlink" title="4.5 转换流"></a>4.5 转换流</h2><p><strong>字节流和字符流之间的转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入字节流 → 字符流</span></span><br><span class="line">InputStreamReader charIn = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 输出字节流 → 字符流</span></span><br><span class="line">OutputStreamWriter charOut = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(dest));</span><br></pre></td></tr></table></figure>



<h2 id="4-6-标准输入、输出流"><a href="#4-6-标准输入、输出流" class="headerlink" title="4.6 标准输入、输出流"></a>4.6 标准输入、输出流</h2><p><strong>重定向标准输入、输出流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setIn(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>)));</span><br><span class="line">System.setOut(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)), <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>



<h2 id="4-7-对象流"><a href="#4-7-对象流" class="headerlink" title="4.7 对象流"></a>4.7 对象流</h2><p>需要实现 <code>Serializable</code> 接口。</p>
<h2 id="4-8-随机读写文件流"><a href="#4-8-随机读写文件流" class="headerlink" title="4.8 随机读写文件流"></a>4.8 随机读写文件流</h2><ul>
<li>RandomAccessFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="5-网络编程"><a href="#5-网络编程" class="headerlink" title="5. 网络编程"></a>5. 网络编程</h1><h2 id="5-1-IP"><a href="#5-1-IP" class="headerlink" title="5.1 IP"></a>5.1 IP</h2><ul>
<li>ip的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        InetAddress inet1 =  InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        InetAddress inet2 =  InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(inet1);</span><br><span class="line">        System.out.println(inet2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">localhost/127.0.0.1</span></span><br><span class="line"><span class="comment">www.baidu.com/182.61.200.7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="5-2-TCP"><a href="#5-2-TCP" class="headerlink" title="5.2 TCP"></a>5.2 TCP</h2><ul>
<li>简单的通讯样例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;hello,计算机科学与技术&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">    Socket socket = ss.accept();</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3-UDP"><a href="#5-3-UDP" class="headerlink" title="5.3 UDP"></a>5.3 UDP</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">       String str = <span class="string">&quot;UDP发送数据&quot;</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] data = str.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">       DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data, <span class="number">0</span>, data.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">9000</span>);</span><br><span class="line">       socket.send(packet);</span><br><span class="line">       socket.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9000</span>);</span><br><span class="line">       <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">500</span>];</span><br><span class="line">       DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">       socket.receive(packet);</span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-动态代理和反射"><a href="#6-动态代理和反射" class="headerlink" title="6. 动态代理和反射"></a>6. 动态代理和反射</h1><ul>
<li>反射：允许程序在执行期间借助于Refelction API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</li>
</ul>
<p>正常方式：引入“包类”名称 → 通过new实例化 → 取得实例对象</p>
<p>反射方式：实例化对象 → getClass()方法 → 得到完整的“包类”名称</p>
<h2 id="6-1-获取Class实例"><a href="#6-1-获取Class实例" class="headerlink" title="6.1 获取Class实例"></a>6.1 获取Class实例</h2><ul>
<li>获取Class实例的四种方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：调用运行时类的属性：class.class</span></span><br><span class="line">    Class clazz1 = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：通过运行时类的对象获取：obj.class</span></span><br><span class="line">    Class clazz2 = <span class="keyword">new</span> Person().getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式三：调用Class的静态方法：forName(String classPath)//较多</span></span><br><span class="line">    Class clazz3 = Class.forName(<span class="string">&quot;indi.pancras.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式四：使用类的加载器：ClassLoader//较少</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class clazz4 = classLoader.loadClass(<span class="string">&quot;indi.pancras.Person&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-2-使用Class创建、访问对象"><a href="#6-2-使用Class创建、访问对象" class="headerlink" title="6.2 使用Class创建、访问对象"></a>6.2 使用Class创建、访问对象</h2><ul>
<li>通过反射创建类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    p.showName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射访问类属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Class clazz = Person.class;</span><br><span class="line">       Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">       Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">       System.out.println(p.toString());</span><br><span class="line">       Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">       age.set(p, <span class="number">10</span>);</span><br><span class="line">       System.out.println(p.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射调用类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    Method showName = clazz.getDeclaredMethod(<span class="string">&quot;showName&quot;</span>);</span><br><span class="line">    showName.invoke(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射访问私有属性、方法、构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 调用私有构造器</span></span><br><span class="line">    Constructor cons = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person p1 = (Person) cons.newInstance(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p1, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有方法</span></span><br><span class="line">    Method showAge = clazz.getDeclaredMethod(<span class="string">&quot;showAge&quot;</span>);</span><br><span class="line">    showAge.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    showAge.invoke(p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-3-反射的应用：动态代理"><a href="#6-3-反射的应用：动态代理" class="headerlink" title="6.3 反射的应用：动态代理"></a>6.3 反射的应用：动态代理</h2><ul>
<li>可以通过字符串动态创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object </span><br><span class="line">    getInstance(String classPath) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Class clazz = Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>静态代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory cloth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory cloth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cloth = cloth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一些准备工作&quot;</span>);</span><br><span class="line">        cloth.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;一些收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产Nike衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NikeClothFactory nike = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ProxyClothFactory proxy = <span class="keyword">new</span> ProxyClothFactory(nike);</span><br><span class="line"></span><br><span class="line">        proxy.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>动态代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产Nike衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AntaClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产Anta衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此方法返回一个代理类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span> </span>&#123;<span class="comment">// obj:被代理类的对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">new</span> MyInvocationHandler(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当通过代理类调用a方法时，会调用invoke()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一些准备工作&quot;</span>);</span><br><span class="line">        Object returnObj = method.invoke(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;一些收尾工作&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClothFactory proxy1 = (ClothFactory) ProxyFactory.getProxyInstance(<span class="keyword">new</span> NikeClothFactory());</span><br><span class="line">        proxy1.produceCloth();</span><br><span class="line">        ClothFactory proxy2 = (ClothFactory) ProxyFactory.getProxyInstance(<span class="keyword">new</span> AntaClothFactory());</span><br><span class="line">        proxy2.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础知识</title>
    <url>/2021/04/21/java-guide/</url>
    <content><![CDATA[<img src="/2021/04/21/java-guide/java.jpg" alt="General 2560x1440 digitalocean Java coffee cup food artwork machine" style="zoom: 20%;">

<a id="more"></a>



<h1 id="1-Java特性"><a href="#1-Java特性" class="headerlink" title="1 Java特性"></a>1 Java特性</h1><h2 id="1-1-Java的特点？"><a href="#1-1-Java的特点？" class="headerlink" title="1.1 Java的特点？"></a>1.1 Java的特点？</h2><ul>
<li>面向对象（封装、继承、多态）</li>
<li>由于jvm的存在，Java和平台无关，一次编译，多地运行</li>
<li>编译和解释并存：Java源码→（javac编译）→.class字节码→（JVM解释）→机器码<ul>
<li>为了加速解释过程，引入运行时编译，即JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</li>
</ul>
</li>
<li>支持网络编程和多线程，能很方便地编写出多线程程序和网络程序。</li>
<li>自动内存管理，无需像C++一样要手动管理内存。</li>
</ul>
<h2 id="1-2-JVM、JDK、JRE的区别和联系？"><a href="#1-2-JVM、JDK、JRE的区别和联系？" class="headerlink" title="1.2 JVM、JDK、JRE的区别和联系？"></a>1.2 JVM、JDK、JRE的区别和联系？</h2><ul>
<li>JVM，Java Virtual Machine：运行Java字节码的虚拟机，在不同平台上有不同的实现（win、linux、macos），是Java语言跨平台的基础。</li>
<li>JRE，Java Runtime Environment：Java运行时环境，是运行已编译Java程序所需要内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他一些基础组件，但是它不能创建新程序。</li>
<li>JDK，Java Development Kit：它是JRE的超集，还包括编译器javac、工具如javadoc、jdb等，能够创建、编译和调试Java程序。</li>
</ul>
<h2 id="1-3-Java和C-的区别和联系"><a href="#1-3-Java和C-的区别和联系" class="headerlink" title="1.3 Java和C++的区别和联系"></a>1.3 Java和C++的区别和联系</h2><ul>
<li>Java是面向对象的语言，C++既可以面向对象，也可以面向过程。</li>
<li>Java不能操作指针，更加安全，C++可以操作指针，更加灵活。</li>
<li>Java有自动内存管理机制，无需程序员手动释放内存，而C++需要。</li>
<li>Java的类只支持单继承，C++类支持多继承，Java接口可以多继承。</li>
<li>C/C++的字符串以’\0’表示结束，但Java中没有这一概念。原因：Java中一切都是对象，字符串对象本身会记录自己的长度，无需浪费额外的空间存储’\0’。</li>
</ul>
<h2 id="1-4-面向过程和面向对象？"><a href="#1-4-面向过程和面向对象？" class="headerlink" title="1.4 面向过程和面向对象？"></a>1.4 面向过程和面向对象？</h2><p><strong>面向过程：</strong>分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展。</p>
<p><strong>面向对象：</strong>把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。<br>缺点：性能比面向过程低。</p>
<h2 id="1-5-为什么说Java编译和解释并存？"><a href="#1-5-为什么说Java编译和解释并存？" class="headerlink" title="1.5 为什么说Java编译和解释并存？"></a>1.5 为什么说Java编译和解释并存？</h2><p>Java编写的程序首先需要进行编译，生成字节码文件*.class，这种文件必须由Java解释器来解释执行，同时为了加快解释速度，引入运行时编译JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<p>![Java程序运行过程](java-guide/Java 程序运行过程.png)</p>
<h1 id="2-Java语法"><a href="#2-Java语法" class="headerlink" title="2 Java语法"></a>2 Java语法</h1><h2 id="2-1-字符型常量和字符串常量的区别？"><a href="#2-1-字符型常量和字符串常量的区别？" class="headerlink" title="2.1 字符型常量和字符串常量的区别？"></a>2.1 字符型常量和字符串常量的区别？</h2><ul>
<li>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的0个或多个字符。</li>
<li>含义上：字符常量相当于一个整型值（ASCII值），可以参与表达式运算；字符串常量代表字符串在内存中存放的位置。</li>
<li>占内存大小：字符常量占用2字节；字符串常量占用若干字节。</li>
</ul>
<h2 id="2-2-continue、break、return的区别是什么？"><a href="#2-2-continue、break、return的区别是什么？" class="headerlink" title="2.2 continue、break、return的区别是什么？"></a>2.2 continue、break、return的区别是什么？</h2><ul>
<li><code>continue</code>：继续下一次循环。</li>
<li><code>break</code>：跳出循环体，继续执行循环体之后的程序。</li>
<li><code>return</code>：结束方法的执行。</li>
</ul>
<h2 id="2-3-说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？"><a href="#2-3-说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="2.3 说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？"></a>2.3 说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？</h2><p>Java泛型是 JDK 5 引入的一个新特性，提供了编译时类型安全检测机制。</p>
<p>Java的泛型是伪泛型，类型擦除是指在编译期间，所有的泛型信息会被擦除。</p>
<p>常用通配符：</p>
<ul>
<li>? 表示 不确定的Java类型</li>
<li>T（Type）表示具体的一个Java类型</li>
<li>K V（Key Value）分别代表Java键值中的Key Value</li>
<li>E（Element）代表Element</li>
</ul>
<h2 id="2-4-和-equals-的区别？"><a href="#2-4-和-equals-的区别？" class="headerlink" title="2.4 == 和 equals 的区别？"></a>2.4 == 和 equals 的区别？</h2><ul>
<li>== ：如果是基本数据类型，==比较的是值是否相同；如果是引用数据类型，==比较的是内存地址是否相等。</li>
<li>equals()：所有对象的父类<code>Object</code>提供的方法，用于判断两个对象是否相等。分为两种情况：如果子类没有覆盖<code>equals</code>，效果等同于==。如果子类覆盖了equals()方法，通常用来比较两个对象的值是否相同。</li>
<li>String 中的 <code>equals</code> 方法被重写过，判断两个String对象相等的方法：<code>s1.equals(s2) == true或者s1.compareTo(s2) == 0</code></li>
</ul>
<h2 id="2-5-hashCode-与equals"><a href="#2-5-hashCode-与equals" class="headerlink" title="2.5 hashCode()与equals()"></a>2.5 hashCode()与equals()</h2><ul>
<li>说一说<code>hashCode()</code>？</li>
</ul>
<p><code>hashCode()</code> 定义在<code>Object</code>类中，Java1中的任何类都含有<code>hashCode()</code>方法。它的作用是获取哈希码，即一个int整数，用于确定该对象在哈希表中的索引位置。</p>
<ul>
<li>为什么要有<code>hashCode</code>？</li>
</ul>
<p>加快对象比较的速度，在插入Map时有很大的作用。如果两个对象的hashCode不同，则这两个对象一定不等，如果hashCode相等，可以再比较对象的值，大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<ul>
<li>为什么重写<code>equals</code>时必须要重写<code>hashCode</code>？</li>
</ul>
<p>equals方法内部会调用 <code>hashcode</code> 只是用来缩小查找成本，而<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等。</p>
<ul>
<li>为什么两个对象拥有相同的<code>hashcode</code>它们也不一定想等？</li>
</ul>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
<h2 id="2-6-自动装箱和自动拆箱"><a href="#2-6-自动装箱和自动拆箱" class="headerlink" title="2.6 自动装箱和自动拆箱"></a>2.6 自动装箱和自动拆箱</h2><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ul>
<h2 id="2-7-常量池"><a href="#2-7-常量池" class="headerlink" title="2.7 常量池"></a>2.7 常量池</h2><p>Java基本类型的包装类大部分（Byte、Short、Integer、Long、Character、Boolean）都实现了常量池，前面4种包装类创建了数值[-128,127]的缓存数据，Character创建了[0,127]范围内的缓存数据，Boolean直接返回True or False，如果超出范围仍然会创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i0 = <span class="number">127</span>;</span><br><span class="line">    Integer i1 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i0 == i1);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer i2 = <span class="number">128</span>;</span><br><span class="line">    Integer i3 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i2 == i3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer i4 = <span class="number">40</span>;</span><br><span class="line">    Integer i5 = <span class="number">10</span>;</span><br><span class="line">    Integer i6 = <span class="number">30</span>;</span><br><span class="line">    System.out.println(i4 == i5 + i6); <span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="number">40</span> == i5 + i6); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 语句 i4 == i5 + i6</span></span><br><span class="line">    <span class="comment">// 因为+这个操作符不适用于 Integer 对象</span></span><br><span class="line">    <span class="comment">// 首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40</span></span><br><span class="line">    <span class="comment">// 然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40</span></span><br><span class="line">    <span class="comment">// 最终这条语句转为 40 == 40 进行数值比较。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-8-重载和重写的区别？"><a href="#2-8-重载和重写的区别？" class="headerlink" title="2.8 重载和重写的区别？"></a>2.8 重载和重写的区别？</h2><ul>
<li><strong>重载：</strong>同样的一个方法能够根据输入数据的不同，做出不同的处理。</li>
<li><strong>重写：</strong>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要对父类方法进行覆盖，这个过程就叫重写。</li>
</ul>
<blockquote>
<p>以下方法无法被重写：</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="2-9-深拷贝和浅拷贝？"><a href="#2-9-深拷贝和浅拷贝？" class="headerlink" title="2.9 深拷贝和浅拷贝？"></a>2.9 深拷贝和浅拷贝？</h2><ul>
<li><strong>浅拷贝：</strong>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</li>
<li><strong>深拷贝：</strong>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</li>
</ul>
<p><img src="/2021/04/21/java-guide/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h2 id="2-10-构造器能被重写（override）吗？"><a href="#2-10-构造器能被重写（override）吗？" class="headerlink" title="2.10 构造器能被重写（override）吗？"></a>2.10 构造器能被重写（override）吗？</h2><p>构造器不能被重写，但可以被重载。</p>
<h1 id="3-Java面向对象"><a href="#3-Java面向对象" class="headerlink" title="3 Java面向对象"></a>3 Java面向对象</h1><h2 id="3-1-面向过程和面向对象的区别？"><a href="#3-1-面向过程和面向对象的区别？" class="headerlink" title="3.1 面向过程和面向对象的区别？"></a>3.1 面向过程和面向对象的区别？</h2><ul>
<li>面向过程：函数</li>
<li>面向对象：封装、继承、多态</li>
</ul>
<h2 id="3-2-成员变量和局部变量的区别？"><a href="#3-2-成员变量和局部变量的区别？" class="headerlink" title="3.2 成员变量和局部变量的区别？"></a>3.2 成员变量和局部变量的区别？</h2><p>成员变量属于对象，对象存在于堆内存，局部变量则存在于栈内存。特别地，被static修饰的成员变量属于类，位于方法区。</p>
<h2 id="3-3-面向对象的三大特性：封装、继承、多态"><a href="#3-3-面向对象的三大特性：封装、继承、多态" class="headerlink" title="3.3 面向对象的三大特性：封装、继承、多态"></a>3.3 面向对象的三大特性：封装、继承、多态</h2><ul>
<li>封装：将对象的一些属性或方法隐藏在内部，不允许外部对象直接访问对象信息，但可以给外部提供一些方法来操作属性。</li>
<li>继承：<ul>
<li>子类拥有父类的所有属性和方法，包括私有的，但私有的只是拥有，无法访问。</li>
<li>子类可以拓展父类，拥有自己的属性和方法。</li>
<li>子类可以重写父类方法进行覆盖。</li>
</ul>
</li>
<li>多态：父类指向子类的实例<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ul>
<h2 id="3-4-对象相等和它们的引用相等"><a href="#3-4-对象相等和它们的引用相等" class="headerlink" title="3.4 对象相等和它们的引用相等"></a>3.4 对象相等和它们的引用相等</h2><ul>
<li>对象相等：对象保存在内存中的数据相等</li>
<li>引用相等：对象的内存地址相等</li>
</ul>
<h2 id="3-5-StringBuffer和StringBuilder的区别和联系？"><a href="#3-5-StringBuffer和StringBuilder的区别和联系？" class="headerlink" title="3.5 StringBuffer和StringBuilder的区别和联系？"></a>3.5 <code>StringBuffer</code>和<code>StringBuilder</code>的区别和联系？</h2><ul>
<li>StringBuffer：线程安全，效率低</li>
<li>StringBuilder：线程不安全，效率高</li>
</ul>
<h2 id="3-6-类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？"><a href="#3-6-类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？" class="headerlink" title="3.6 类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？"></a>3.6 类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？</h2><ul>
<li>构造方法的作用是完成类对象的初始化工作</li>
<li>如果不显式编写构造方法，编译器会自动生成无参构造方法。</li>
</ul>
<h2 id="3-7-String为什么是不可变的？"><a href="#3-7-String为什么是不可变的？" class="headerlink" title="3.7 String为什么是不可变的？"></a>3.7 <code>String</code>为什么是不可变的？</h2><p><code>String</code>对象用<code>private final char value[]</code>保存字符串，因此不可变（JDK 9 之后采用<code>private final byte value[]</code>保存）</p>
<h2 id="3-8-构造方法的特点"><a href="#3-8-构造方法的特点" class="headerlink" title="3.8 构造方法的特点"></a>3.8 构造方法的特点</h2><ul>
<li>和类名相同</li>
<li>无返回值</li>
<li>可以被重载，不能被重写</li>
</ul>
<h1 id="4-反射"><a href="#4-反射" class="headerlink" title="4 反射"></a>4 反射</h1><h2 id="4-1-谈一谈反射？"><a href="#4-1-谈一谈反射？" class="headerlink" title="4.1 谈一谈反射？"></a>4.1 谈一谈反射？</h2><ul>
<li>反射：允许程序在执行期间借助于Refelction API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法<ul>
<li>正常方式：引入“包类”名称 → 通过new实例化 → 取得实例对象</li>
<li>反射方式：实例化对象 → getClass()方法 → 得到完整的“包类”名称</li>
</ul>
</li>
<li>优点：让代码更加灵活、为各种框架开箱即用的功能提供了便利</li>
<li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。</li>
</ul>
<h2 id="4-2-反射的应用场景"><a href="#4-2-反射的应用场景" class="headerlink" title="4.2 反射的应用场景"></a>4.2 反射的应用场景</h2><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。这些框架中也用到了动态代理，而动态代理的实现也依赖反射。</p>
<ul>
<li>通过反射创建类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    p.showName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射访问类属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Class clazz = Person.class;</span><br><span class="line">       Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">       Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">       System.out.println(p.toString());</span><br><span class="line">       Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">       age.set(p, <span class="number">10</span>);</span><br><span class="line">       System.out.println(p.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射调用类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    Method showName = clazz.getDeclaredMethod(<span class="string">&quot;showName&quot;</span>);</span><br><span class="line">    showName.invoke(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射访问私有属性、方法、构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 调用私有构造器</span></span><br><span class="line">    Constructor cons = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person p1 = (Person) cons.newInstance(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p1, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有方法</span></span><br><span class="line">    Method showAge = clazz.getDeclaredMethod(<span class="string">&quot;showAge&quot;</span>);</span><br><span class="line">    showAge.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    showAge.invoke(p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-注解和反射"><a href="#4-3-注解和反射" class="headerlink" title="4.3 注解和反射"></a>4.3 注解和反射</h2><p>基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。（基于注解编程的原理）</p>
<h1 id="5-异常"><a href="#5-异常" class="headerlink" title="5 异常"></a>5 异常</h1><img src="/2021/04/21/java-guide/Java异常类层次结构图2.png" alt="img" style="zoom: 40%;">





<h1 id="6-多线程"><a href="#6-多线程" class="headerlink" title="6 多线程"></a>6 多线程</h1><h2 id="6-1-程序、线程、进程？"><a href="#6-1-程序、线程、进程？" class="headerlink" title="6.1 程序、线程、进程？"></a>6.1 程序、线程、进程？</h2><ul>
<li>程序：含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</li>
<li>进程：正在运行的一个程序。是<strong>资源分配的单位</strong>。</li>
<li>线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。是<strong>调度和执行的单位</strong>。</li>
</ul>
<h2 id="6-2-程序的生命周期"><a href="#6-2-程序的生命周期" class="headerlink" title="6.2 程序的生命周期"></a>6.2 程序的生命周期</h2><p><img src="/2021/04/21/java-guide/lifecycle.png"></p>
<h1 id="7-I-O流"><a href="#7-I-O流" class="headerlink" title="7 I/O流"></a>7 I/O流</h1><h2 id="7-1-I-O流的分类？"><a href="#7-1-I-O流的分类？" class="headerlink" title="7.1 I/O流的分类？"></a>7.1 I/O流的分类？</h2><ul>
<li>按数据单位：字节流（8bit）、字符流（16bit）</li>
<li>按数据流向：输入流、输出流</li>
<li>按流的角色：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td align="center">Wrider</td>
</tr>
</tbody></table>
<h2 id="7-2-序列化和反序列化"><a href="#7-2-序列化和反序列化" class="headerlink" title="7.2 序列化和反序列化"></a>7.2 序列化和反序列化</h2><ul>
<li>利用序列化和反序列化机制，可以将Java对象持久化，或者在网络中传输。</li>
<li>序列化：将数据结构或Java对象转换为二进制字节流。</li>
<li>反序列化：将二进制字节流转换为数据结构或Java对象。</li>
</ul>
<p><img src="/2021/04/21/java-guide/se-deserialization.png" alt="img"></p>
<h2 id="7-3-不想序列化某些属性"><a href="#7-3-不想序列化某些属性" class="headerlink" title="7.3 不想序列化某些属性"></a>7.3 不想序列化某些属性</h2><ul>
<li><code>transient</code> : 只用于修饰变量，不用于修饰类和方法，被修饰的变量不会被序列化和反序列化。</li>
</ul>
<h2 id="7-4-获取键盘输入的两种方式"><a href="#7-4-获取键盘输入的两种方式" class="headerlink" title="7.4 获取键盘输入的两种方式"></a>7.4 获取键盘输入的两种方式</h2><ul>
<li>使用 <code>Scanner</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>



<ul>
<li>使用 <code>BufferedReader</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">String s = input.readLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>





<h2 id="7-5-BIO、NIO、AIO的区别？"><a href="#7-5-BIO、NIO、AIO的区别？" class="headerlink" title="7.5 BIO、NIO、AIO的区别？"></a>7.5 BIO、NIO、AIO的区别？</h2><ul>
<li>BIO (Blocking I/O)，即<strong>同步阻塞I/O</strong>，用户发起I/O请求会会一直阻塞，直到内核把数据拷贝到用户空间，不适合高并发场景。</li>
</ul>
<img src="/2021/04/21/java-guide/bio.png" alt="image-20210531214925715" style="zoom:50%;">



<ul>
<li><p>NIO (Non-blocking/New I/O)，即<strong>同步非阻塞 IO</strong></p>
<ul>
<li>应用程序会一直发起 read 调用，等待数据内核把数据拷贝到用户空间。</li>
<li>优点：相比于BIO，同步非阻塞 IO 通过轮询操作，<strong>避免了一直阻塞</strong>。</li>
</ul>
<ul>
<li>缺点：<strong>轮询过程消耗 CPU 资源</strong>。</li>
</ul>
</li>
</ul>
<img src="/2021/04/21/java-guide/nio.png" alt="image-20210531215133678" style="zoom:50%;">

<ul>
<li>NIO的<strong>I/O 多路复用模型</strong> <ul>
<li>线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。</li>
<li>优点：通过减少无效的系统调用，减少了对 CPU 资源的消耗。</li>
</ul>
</li>
</ul>
<img src="/2021/04/21/java-guide/nio1.png" alt="image-20210531215430672" style="zoom:50%;">

<ul>
<li>AIO (Asynchronous I/O)<ul>
<li>AIO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</li>
</ul>
<img src="/2021/04/21/java-guide/aio.png" alt="img" style="zoom: 67%;">

<ul>
<li>Summary</li>
</ul>
<img src="/2021/04/21/java-guide/iosummary.png" alt="img" style="zoom:50%;">]]></content>
      <tags>
        <tag>all</tag>
        <tag>java</tag>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>paper-summarizer</title>
    <url>/2021/08/18/paper-summarizer/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现代数据中心固态硬盘（SSD）集成了多个通用的嵌入式内核来管理灰度转换层、垃圾收集、磨损平衡等，以提高SSD的性能和可靠性。随着这些内核的性能稳步提高，有机会重新利用这些内核对存储的数据进行应用驱动的计算，目的是减少主机处理器和SSD之间的通信。减少主机-SSD的带宽需求可以减少I/O时间，而I/O时间是许多在大型数据集上运行的应用程序的瓶颈。然而，嵌入式内核的性能仍然比主机处理器低很多，因为一般来说，出于成本效益的考虑，在SSD中使用的嵌入式内核都很弱小。因此，在与近固态硬盘处理相关的计算开销和减少与主机系统的通信开销之间存在一个权衡。</p>
<p>在这项工作中，我们设计了一套应用程序编程接口（API），可以被主机应用程序用来将数据密集型任务加载到SSD处理器上。我们描述了如何通过简单修改主机和SSD处理器之间现有的非易失性内存快递（NVMe）命令接口来实现这些API。然后，我们利用两个重要领域的应用，即数据分析和数据整合，对近存储计算的计算与通信权衡进行量化。通过使用一个全功能的SSD评估平台，我们通过改变SSD处理器的带宽和计算能力，对我们提出的方法进行了设计空间探索。我们评估了在主机和SSD处理器之间分配工作的静态和动态方法，并表明我们的设计与只在主机处理器上处理相比，可以提高20%的性能，与只在SSD处理器上处理相比，可以提高6倍。</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>处理大量的数据是许多应用领域的支柱，如数据分析和数据整合。在这种情况下，将数据从存储空间传输到计算节点的成本开始主导整个应用程序的性能。应用程序可以花费超过一半的执行时间，将数据从存储空间带到CPU[38]。在磁性磁盘存储系统中，介质访问时间，如寻道和旋转延迟，主导着数据访问时间。然而，随着固态非易失性存储技术的迅速采用，性能瓶颈从介质访问时间转移到操作系统开销和互连带宽。因此，在固态存储的背景下，必须重新考虑普遍存在的计算模型，该模型假定存储介质访问延迟是不可避免的成本。特别是，计算模型必须适应主导存储访问的带宽和操作系统开销的现实情况。</p>
<p>由于用于数据中心的现代固态硬盘（SSD）集成了大型DRAM缓冲区以及多个通常未被充分利用的通用嵌入式内核，将计算移至数据存储附近变得可行。以前的工作证明了使用近数据处理模型将数据分析、SQL查询、操作系统功能、图形遍历、图像处理和MapReduce操作[4, 5, 8, 15, 16, 30, 32, 34, 36, 41]加载到数据存储设备的潜力。这些先前的工作中，很多都是假设在存储附近有一个商品通用处理器。然而，即使是高端数据中心的固态硬盘也配备了懦弱的嵌入式内核。除了成本和功耗方面的限制，只包含懦弱的嵌入式内核的一个原因是，它们已经提供了足够的计算能力来处理目前大多数的SSD操作，如协议管理、I/O调度、闪存转换和磨损平衡。例如，最近支持NVMe协议和高带宽PCIe互连的SSD控制器可能部分地只利用三个低端ARM Cortex R5内核来支持固件操作[23, 31]。即使在最坏的情况下，这些内核的利用率也高达30%。因此，虽然在利用嵌入式内核方面存在松懈，但将大型计算内核卸载到这些软弱的内核上是不现实的。</p>
<p>有了软弱无力的嵌入式内核，必须仔细管理计算和存储的选择。有时，将计算转移到嵌入式内核是有利的，可以通过减轻沉重的流量和带宽需求来减少主机和存储的通信延迟。另一方面，与主机处理器上的计算相比，使用软弱无力的嵌入式内核的存储计算需要更多的处理时间。因此，在懦弱的内核所带来的计算开销和向主机系统传输数据的通信延迟的减少之间存在着一种权衡#。在本文中，我们提出了Summarizer，一种近存储计算范式，只要对加载计算有好处，就会适时地使用弱小的近存储计算能力。Summarizer自动平衡通信延迟和近存储处理器的计算限制。</p>
<p>本文有以下贡献：</p>
<p>(1) 这项工作提出了 Summarizer——一种架构和计算模型，它允许应用程序利用 wimpy SSD 处理器“在将数据传输到主机之前对存储在 SSD 中的数据进行过滤和汇总。Summa rizer 减少了数据量 移至主机处理器，还允许主机处理器根据“过滤/汇总结果”进行计算，从而提高整体系统性能。</p>
<p>(2) 在定制构建的 !ash 存储系统上实现原型 Summarizer 系统，该系统类似于现有的 SSD 架构，但还支持存储处理器和主机之间的“negrain计算o$oading”。我们增强了标准 NVMe 接口命令以 在不改变NVMe兼容性的情况下实现Summarizer的功能。使用这个原型，我们展示了主机和板上嵌入式存储处理器之间协同计算的好处。</p>
<p>(3) 我们评估了通信中涉及的权衡与存储附近的计算。 考虑到内部 SSD 带宽和主机与 SSD 带宽的几个比率、主机计算能力和 SSD 计算能力的比率，我们进行了设计空间探索以说明权衡。</p>
<p>(4) Summarizer动态地监控SSD处理器的工作量，并在主机处理器和SSD处理器之间选择适当的工作分配策略。Summarizer的分工方法量化了主机处理器和SSD处理器协同使用的潜力，以获得更好的性能。</p>
<p>本文的其余部分组织如下。第2节描述了现代数据中心固态硬盘的架构，PCIe固态硬盘的NVMe的性能，并激励了近固态硬盘计算。第3节介绍了Summarizer的架构和实现。第4节描述了本文中使用的应用程序。第5节描述了我们的方法和实施细节。第6节介绍了实验设置和我们的结果。第7节提供了一个相关工作的总结，以便将这个项目放在背景中，第8节是本文的结论。</p>
<h1 id="2-背景和动机"><a href="#2-背景和动机" class="headerlink" title="2. 背景和动机"></a>2. 背景和动机</h1><p>Summarizer依赖于现代固态硬盘中嵌入的处理能力，以及主机用来与固态硬盘对接的NVMe（非易失性内存快递）命令。本节简要介绍了SSD架构、现代SSD附近的处理潜力，以及主机用来与SSD通信的NVMe协议。</p>
<h2 id="2-1-现代数据中心SSD的架构"><a href="#2-1-现代数据中心SSD的架构" class="headerlink" title="2.1 现代数据中心SSD的架构"></a>2.1 现代数据中心SSD的架构</h2><p>图1描述了通过PCI Express（PCIe）总线支持NVMe协议的现代SSD的硬件架构。大多数固态硬盘使用NAND！灰内存包作为主要的非易失性存储元素。每个固态硬盘可能包含几十个！灰烬芯片，被组织成多个通道。每个灰烬芯片可以被平行访问，所有共享一个通道的芯片可以在该通道上被复用。此外，多个通道可以被并行访问。芯片和通道级别的并行性为SSD提供了巨大的内部带宽。典型的高端数据中心固态硬盘可以通过多通道拓扑结构的！灰烬内存包和每个包的芯片堆叠制造来提供大规模的内部并行性[6]。例如，今天的商用NVMe固态硬盘可以支持32个通道的MLC NAND !ash内存包[26]，并实现高达4.5 GB/s的总内部带宽[25]。最近的3D NAND !ash技术的进步实现了每包更高的数据带宽，因此最近的SSD系统能够提供更高的内部带宽[24]。固态硬盘设计者没有增加内部带宽，而是使用更少的3D NAND封装来维持多代类似的内部带宽水平。在SSD平台上，将内部带宽提高到目前的水平并不是很有利，因为由于PCIe通道的带宽限制，即使是高端的NVMe SSD的外部带宽目前也饱和于4GB/s以下。</p>
<p>总而言之，我们注意到，尽管增加固态硬盘的内部带宽可以通过配备多个灰度内存通道和先进的制造工艺来实现，但扩展主机CPU和固态硬盘之间的外部带宽需要处理器提供额外的PCIe通道。事实上，最近数据中心从SATA固态硬盘转向NVMe固态硬盘，是由于固态硬盘的内部并行性远远超过了SATA支持的最大带宽，尽管NVMe接口比SATA昂贵得多[27]。</p>
<p>为了有效地管理通道并行性和内部带宽，现代的SSD集成了 ndwidth，现代的SSD集成了嵌入式多核处理器作为SSD控制器。这些处理器处理I/O请求调度，通过灰度转换层（FTL）进行数据映射，磨损均衡和垃圾回收。控制器通过通道连接到灰烬内存芯片，并发出灰烬内存命令，在每个通道中并行地执行I/O操作。固态硬盘还提供了一个DRAM控制器，与DRAM连接，作为灰烬数据的临时存储，也用来存储控制器的数据结构。除了嵌入式内核外，每个固态硬盘还可能包含几个硬件加速器，以提供有效的纠错代码（ECC）处理或数据加密。</p>
<p>NVMe固态硬盘通过一个标准的PCIe插槽或M.2插槽连接到主机系统的PCIe互连上。PCIe/NVMe接口从主机CPU获取I/O命令，如读和写操作，并在系统互连和SSD之间执行直接内存访问（DMA）操作。例如，主机CPU可以指定从SSD读取数据后，必须将数据放入的内存地址。然后，NVMe接口实现了从SSD控制器到主机内存的DMA传输。当前一代的NVMe固态硬盘支持几十个主机请求排在固态硬盘控制器的命令队列中。控制器可以安排这些请求，以便最大限度地利用可用的芯片和通道级别的并行性。</p>
<p>闪存的写入行为与磁存储技术明显不同。闪存中的每个页面在被写入一次后就变得不可改变。在包含该页的块被完全擦除之前，该页不能再次被更新。一个区块可以包含64到512个页面。每个区块在其生命周期内只能被擦除有限的次数，而且区块擦除操作比页面读写慢得多。为了解决这些限制并提供更长的使用寿命，固态硬盘在固态硬盘控制器中实施了闪存转换层（FTL）。SSD使用通用的嵌入式处理器来运行FTL操作的固件。基本上，FTL固件将主机应用要求的逻辑块地址（LBA）映射到闪存芯片的物理页地址（PPA）。这个LBA到PPA的映射表被缓存在SSD系统的DRAM中，以加快访问速度。为了保证整个闪存单元有更长的使用寿命，磨损平衡算法也被应用于映射表的管理过程。此外，FTL固件定期执行垃圾收集（GC），以回收无效页面的块的空间。有无效页的块中回收空间</p>
<h2 id="2-2-SSD内计算的潜力"><a href="#2-2-SSD内计算的潜力" class="headerlink" title="2.2 SSD内计算的潜力"></a>2.2 SSD内计算的潜力</h2><p>虽然固态硬盘提供了多个嵌入式处理器，以提高固态硬盘控制器功能的性能，如FTL管理和垃圾收集，但控制器中的许多计算能力仍然没有得到充分利用。这些未被充分利用的嵌入式内核提供了从应用中加载计算的机会。特别是，当我们展望未来时，即使是嵌入式内核的处理能力也会继续增长，尽管在主机处理器和每个SSD内的嵌入式内核的计算能力上可能会有很大差距。本节将分析使用这些嵌入式处理器来加速应用的潜力。</p>
<p>请注意，即使嵌入式内核未被充分利用，配置多个内核的主要理由仍然是性能。固件可以对代码进行分区，以实现并发执行不同的操作，如解析命令、查找地址、锁定正在访问的地址，以及与灰烬存储器芯片的接口。固件代码还使用几个内核在后台执行垃圾收集和损耗平衡。在我们的实验室评估中，在一个数据中心级别的SSD中同时执行4096个操作，这些SSD处理器的平均利用率总是低于30%，并且总是至少有一个处理器处于空闲状态。即使在执行垃圾收集或损耗均衡时，利用率不足的情况也是如此。虽然在FTL操作中存在大量的并发，但每个并发操作本身是相对简单的。因此，虽然多个内核对利用并发性是有用的，但在任何给定的操作中，每个内核的利用率仍然很低。这种低利用率揭示了在这些数据中心规模的SSD中使用现有硬件进行计算的潜力。例如，我们可以在 “灰烬 “数据访问管道中增加一个阶段，以执行低计算强度的操作，而不影响SSD控制器的性能。只要增加的阶段比当前的关键操作短，固态硬盘就不会因为吞吐量的下降而受到影响。</p>
<p>在闪存数据访问管道的各个步骤中，我们发现，最耗时的步骤是访问闪存介质。即使是最快的闪存操作–读操作，高性能的单级单元闪存芯片仍然需要超过20微秒的时间来完成操作[25]。对于多级闪存单元来说，这个延迟甚至更长。假设闪存接口可以同时访问b个闪存通道，并且访问的数据均匀地分布在所有通道上，如果每个读操作需要t秒完成，那么允许计算阶段完成而不损害吞吐量的 “松弛 “是bt。当使用多核处理器时，这种松弛会增长得更多。如果每个闪存页包含p字节的数据，每个嵌入式处理器每秒可以处理n条指令，我们可以在不影响吞吐量的情况下获得对le数据的每字节操作，当我们腾出一个核心用于存储内计算时，吞吐量将为bt⇥n。然而，如果固态硬盘配备了更多的内核，或者并行操作的数量没有达到峰值性能，我们可能会期待比这个一阶估计大得多的松弛。例如，如果我们可以腾出m个内核用于计算，并完美地将计算并行化，我们可以在不影响吞吐量的情况下对每个字节进行的操作可以接近 对于三星SSD的MEX SSD控制器（如t⇥bn⇥⇥pm .</p>
<p>对于三星SSD（如EVO系列）通常使用的MEX SSD控制器，每个处理器核心每秒可以执行4⇥108条指令。如果我们在具有32个库和8KB灰页的SSD中使用这种处理器，我们 “发现每字节的操作必须限制在每字节只执行1条指令，或者每4字节的字有4个操作。</p>
<h2 id="2-3-NVMe"><a href="#2-3-NVMe" class="headerlink" title="2.3 NVMe"></a>2.3 NVMe</h2><p>NVM Express（NVMe）是一种连接到PCIe总线或M.2接口的SSD协议[2]。NVMe避免了以磁盘为中心的SATA和SCSI接口的传统，利用PCIe提供可扩展的带宽。例如，数据中心NVMe固态硬盘使用的4通道第三代PCIe支持高达3.9GB/秒的全双工数据传输，而SATA通常只能达到600MB/秒。NVMe还支持比SATA或SCSI更多的并发IO请求，它维护一个软件命令队列，每个处理器核心可容纳多达64K个条目，其命令集包括具有失序完成的分散收集数据传输操作，进一步提高性能。</p>
<p>NVMe具有高度的可扩展性，能够并行地满足多个I/O请求。这使得NVMe成为现代数据处理的良好候选者，在这种情况下，应用程序需要从二级存储中提取大量的数据，并将其送入高度并行的计算设备，如GPU。</p>
<p>NVMe支持一套精简而强大的命令，可以启动和完成I/O操作。每条命令的长度为64字节，包含的信息包括命令标识、逻辑块地址和请求数据的长度。一个NVMe命令还可以包含一个物理区域页（PRP）条目列表，它可以在SSD和其他设备之间进行分散的数据传输。PRP条目可以指定主机内存中的一对基本地址和o#set，对应于设备可以不按顺序执行的多个子传输的列表。</p>
<h1 id="3-SUMMARIZER"><a href="#3-SUMMARIZER" class="headerlink" title="3. SUMMARIZER"></a>3. SUMMARIZER</h1><p>正如上一节所详述的，固态硬盘控制器内有足够的计算能力，可以在存储附近进行适度的计算。随着固态硬盘集成了更强大的计算资源，近存储计算的复杂性也可以扩展。在这一节中，我们描述了Summarizer，这是我们提出的近存储计算范式，可以自动扩展近存储计算能力，而不需要为每一个新一代的SSD重写应用软件。我们首先描述了系统架构，然后介绍了我们为近存储计算范式提供的扩展NVMe命令支持。</p>
<h2 id="3-1-SSD控制器架构"><a href="#3-1-SSD控制器架构" class="headerlink" title="3.1 SSD控制器架构"></a>3.1 SSD控制器架构</h2><p>图2说明了NVMe SSD控制器的整体架构，还强调了为启用Summarizer而引入的额外组件（将在下一小节详细描述）。主机应用程序通过主机端驱动程序和运行在SSD嵌入式处理器上的SSD控制器固件与NVMe设备互动。主机驱动程序和NVMe SSD设备上的控制器固件通过PCIe总线通信。由NVMe主机驱动程序发出的NVMe命令被注册在主机DRAM空间内的提交队列（SQ）中，与请求的命令相对应的门铃信号被发送到SSD控制器，以通知主机的新命令请求。</p>
<p>SSD控制器的主要功能是I/O控制和闪存转换层（FTL）处理。SSD控制器通过从SQ的头部读取注册的请求来接收来自主机的请求命令。只要SQ中存在注册请求，SSD控制器就可以获取主机请求命令。在获取NVMe命令后，它被解码成单个或多个页级块I/O命令。每个页级请求都有一个逻辑块地址（LBA），它被FTL处理转化为物理页号（PPN）。灰烬内存控制器通过页级命令访问灰烬内存芯片。</p>
<p>对于NVMe读取命令，要求的页面数据通过一系列的物理页面读取从闪存芯片中获取，获取的数据被储存在SSD设备的DRAM中。<br>然后，页面数据通过直接内存访问（DMA）机制被传输到主机内存。在NVMe命令处理完成后，SSD控制器通过在主机内存的完成队列（CQ）中注册NVMe命令及其返回代码来通知之前提交的命令完成。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819164648786.png" alt="image-20210819164648786"></p>
<h2 id="3-2-Summarizer的结构和操作"><a href="#3-2-Summarizer的结构和操作" class="headerlink" title="3.2 Summarizer的结构和操作"></a>3.2 Summarizer的结构和操作</h2><p>在这一节中，我们描述了对上述SSD控制器架构进行必要的硬件和软件修改，以启用Summarizer。总结器可以通过对NVMe命令解释器的一些小修改和添加到SSD控制器的软件模块来实现。我们设想大部分的总结器功能将在SSD控制器和闪存控制器之间的接口中实现。总结器有三个核心组件。(1)一个任务队列结构，(2)一个任务控制器模块和(3)用户功能栈，如图2所示。任务队列（TQ）是一个循环队列，它存储了一个指向适当的用户函数的指针，当主机要求对一个给定的I/O请求进行in-SSD处理时，必须调用该函数。任务控制器决定是否对获取的页面数据进行SSD内处理。如果控制器决定执行存储内计算，目标函数将从用户函数堆栈中执行。在某些情况下，即使主机要求进行这样的处理，任务控制器也可能不执行SSD内处理。我们探讨了控制器如何做出这样的决定的两个不同的选项，这两个选项将在后面描述。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819165041854.png" alt="image-20210819165041854"></p>
<p>支持总结器的固态硬盘允许主机将用户指定的特定功能与每个数据访问请求在固态硬盘控制器上执行。为了实现这样的关联，我们使用新的NVMe命令来指定初始化、计算和归零操作。表1中列出了触发这三个步骤的扩展NVMe命令。在列表中，TSK后面的n代表任务TSK的标识符。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819165206295.png" alt="image-20210819165206295"></p>
<p>INIT_TSKn。当主机NVMe驱动发出INIT_TSKn命令时，SSD控制器调用TSKn的初始化功能。这个命令本质上是通知Summarizer的任务控制器，主机打算在存储附近执行一个用户制定的任务n。在初始化步骤中，任务的局部变量或任何可能被该任务使用的临时数据被初始化。</p>
<p>READ_PROC_TSKn。READ_PROC_TSKn命令类似于传统的NVMe READ命令，只是该命令携带了关于所需任务的信息，一旦从闪存中读取页面，就可以在SSD控制器上执行。请注意，现有的NVMe READ命令有多个保留字节，不用于任何处理。我们使用这些未使用的字节来指定</p>
<p>READ_PROC_TSKn命令中的任务ID。与传统的NVMe READ命令一样，SSD控制器向闪存控制器发出读取请求以获取页面数据。此外，固态硬盘控制器还认识到，主机正在请求对该数据请求进行固态硬盘内的处理，处理任务在NVMe命令本身的任务标识字段（TSKn）中被指定。这一信息被标记在请求中。为此，请求队列条目携带两个额外的elds，一个1位的SSD内计算ag，和任务id eld。这些elds是由SSD控制器在执行READ_PROC_TSKn命令时设置的。此外，SSD控制器将请求添加到汇总器的任务队列中。闪存控制器通过访问适当的通道和芯片ID来处理读取请求。获取的数据首先被存入SSD的DRAM中，完成信号被发送到响应队列中，就像在任何常规SSD中一样。在Summarizer中，闪存控制器也将两个额外的固态硬盘内的计算域转移到响应队列中。</p>
<p>响应队列数据通常由SSD控制器通过DMA送回主机。然而，对于Summarizer，SSD控制器会检查SSD内计算的ag位。如果该位被设置，那么就表明主机要求对这个页面进行SSD内计算。在这种情况下，任务控制器决定是否对获取的页面数据进行SSD内的处理。如果控制器决定进行SSD内处理，那么在TQ条目中注册的用户函数指针所指向的计算任务被调用。所获取的页面数据被用作计算内核的输入。计算内核产生的中间输出数据更新了由初始化步骤启动的变量或临时数据集。然后，特殊状态代码被返回给主机，以表明对相应的页面数据进行了SSD内计算，而不是将整个页面数据传输到主机的主存储器。Summarizer中的任务控制器可以在静态或动态模式下执行。在静态模式下，只要设置了in-SSD计算ag，那么无论嵌入式处理器的处理延迟如何，该计算都会在获取的数据上完成。在静态模式下，由于TQ已经满了，所以当ISD内计算请求不可能实现时，返回过程就会简单地停滞。当Summarizer在动态模式下运行时，如果SSD控制器中的SSD内计算由于缺乏计算资源而被延迟，即使主机发出了READ_PROC_TASKn，缓冲的页面数据也被传输到主机。这种情况发生在嵌入式处理器的服务速率（执行时间）比SSD内计算请求的传入速率慢的时候。如果在获取的页面数据上积极地应用近似的数据处理，这种拥堵在非常懦弱的SSD核心的存在下经常发生。</p>
<p>READ_FILT_TSKn。READ_FILT_TSKn的操作与READ_PROC_TSKn的操作类似，只是进行了ltering，并将ltered数据传输给主机。一个ltering请求也是一个计算任务，但在本文中，如果主机处理器只将部分计算任务传输给SSD处理器，并保留部分计算任务在主机上执行，我们就将该请求视为一个ltering任务。例如，一个ltering任务可以在一个页面内对特定的数据字段使用简单的比较操作来删除一些在主机上不需要的数据。在初始化步骤中，通过INIT_TSKn命令预先设定了ltering条件。在NVMe命令中，被清除的数据大小被记录在保留的8字节区域中，并在清除执行完成后被登记在CQ中。</p>
<p>FINAL_TSKn。主机可以使用FINAL_TSKn命令收集任务n的计算内核的输出结果。当该命令发出后，存储在SSD的DRAM中的结果被传输到主机内存。传输数据的大小也被记录在NVMe响应命令的保留的8字节中。</p>
<h2 id="3-3-组成Summarizer的应用"><a href="#3-3-组成Summarizer的应用" class="headerlink" title="3.3 组成Summarizer的应用"></a>3.3 组成Summarizer的应用</h2><p>如第3.1节所述，Summarizer在将处理过的数据返回给主机之前，利用页级闪存的读取操作来执行用户制定的功能。因此，在数据布局和计算方面有一些必须遵循的基本限制。例如，汇总器的输入数据应该在页面粒度（4 KB - 16 KB）上对齐。如果数据在页面边界上重叠，就需要一个更复杂的Summarizer数据管理策略。在这项工作中，我们反而向程序员提供了数据布局和计算API，以满足基于页面粒度的计算限制。特别是，我们提供了以下Summarizer方法，作为包装器，允许传统的用户程序使用提议的Summarizer NVMe命令。</p>
<p>STORE。为了利用Summarizer，有必要在一个页面大小的内存空间中对齐数据集。为了支持页级对齐，Summarizer API的STORE基元首先在4 KB或16 KB数据空间中分配用户数据集，然后直接向主机NVMe驱动程序发出存储块I/O命令。如果有效数据少于一页，那么该页元数据就会存储有效的数据大小。</p>
<p>READ：应用程序员可以使用READ API来指定要计算的数据集和要在数据集上应用的预期计算（即SSD函数）。由于数据集在页粒度上是对齐的，READ API将被翻译成页粒度的READ _PROC_TSKn或READ_FILT_TSKn NVMe命令。如果SSD不支持Summarizer功能，READ命令将映射到默认的NVMe读取命令，从而保持与所有SSD的兼容性。注意，我们假设READ命令被程序员明确地映射到READ_PROC_TSKn或READ_FILT_TSKn。</p>
<p>COMPUTE：回顾一下，SSD控制器可以选择执行用户功能或将整个页面数据返回给主机。因此，动态任务控制器方法需要在主机端代码上花费更多的精力，根据从SSD控制器收到的响应，确定一个页面是否需要在主机上处理。因此，应用程序员使用COMPUTE函数作为包装器来处理调用READ函数的不同返回值。COMPUTE封装器简单地将所有的主机函数调用封装在一个条件语句下，在启动主机端执行页面之前，检查来自SSD控制器的返回代码。</p>
<p>GATHER：由于计算分布在主机CPU和SSD设备上，有必要收集SSD设备上执行的内核计算的输出。因此，应用程序中的GATHER包装函数发出了nalization NVMe命令，以收集来自SSD设备的处理输出。然后，收集的输出与程序员从CPU计算的输出合并。</p>
<p>程序员可以使用C和C++等指令性编程语言编写存储内的Summarizer程序。使用总结器的API，很容易将只在主机系统上执行的程序扩展到也在SSD附近的处理器上执行功能。对于我们在后面第4节中描述的应用程序，每个应用程序平均花了3 10个人小时（注意，一旦完成第一个应用程序的转换，工作量就会减少）。由于Summarizer继承了命令式编程模型，Summarizer利用现有的ARM编程工具链来生成在SSD控制器上运行的机器代码。</p>
<h1 id="4-案例研究"><a href="#4-案例研究" class="headerlink" title="4. 案例研究"></a>4. 案例研究</h1><p>Summarizer可以为广泛的应用提供益处。为了评估所提出的模型，我们提出了几个适合Summarizer执行的案例研究，从数据库到数据集成领域，并展示了Summarizer如何帮助避免多余的数据传输和提高应用性能。</p>
<p>决策支持系统（DSS）是一类数据分析，用户在数据库上进行复杂的查询，以了解其业务状况。DSS查询通常是探索性的，并倾向于早期反馈以帮助识别有趣的区域。许多DSS查询执行大量的数据库ltering，并且只使用数据库记录的一个子集来执行复杂的计算。在这些应用中，每字节的数据传输的计算量是相当低的。使用Summarizer来实现数据ltering或甚至在SSD附近执行整个查询，有助于减少对主机的数据带宽需求。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819165701511.png" alt="image-20210819165701511"></p>
<h2 id="4-1-数据分析"><a href="#4-1-数据分析" class="headerlink" title="4.1 数据分析"></a>4.1 数据分析</h2><p>我们运行TPC-H基准来测试数据分析的性能。TPC-H是一个著名的数据仓库基准测试。它由一套面向业务的临时查询组成。我们选择了TPC-H查询1、6和14，这些查询需要一些操作，如where条件、连接、group by和order by。这些操作在许多其他的TPC-H查询中也会进行。TPC-H查询1、6和14分别显示在算法1、2和3中。在我们的实验中，我们在TPC-H数据库上评估了这些查询，其规模系数为0.1（⇠100MB）。请注意，这个比例系数只是我们的原型板（在下一节中描述）由于容量有限而产生的限制，而不是Summarizer的限制。</p>
<h2 id="4-2-数据整合"><a href="#4-2-数据整合" class="headerlink" title="4.2 数据整合"></a>4.2 数据整合</h2><p>数据整合是将不同来源和/或不同格式的数据结合起来的问题。这个问题对于维护不同类型数据库的大型企业来说至关重要，对于拥有各自数据源的政府机构之间更好的合作来说至关重要，对于管理互联网上各种网页的搜索引擎来说也是如此。<br>相似性连接是数据整合过程中的一个重要步骤。虽然SQL提供了支持（如join）来结合来自不同来源的互补数据，但如果由于拼写错误或其他结构问题，潜在匹配的属性值不完全相等，则会失败。相似性连接是一种有效的方法，通过比较属性值的相似性来克服这一限制，而不是完全匹配相应的值。<br>相似性连接问题可以表示为：给定一个记录集合，一个相似性函数，一个查询记录q，找出所有的记录对，sim()，一个相似性阈值&lt; q,x &gt;，并且它们的相似性值至少高于给定的阈值tde，即ned为：sim(q,Ox()q,xt) 。我们采用重叠相似度，它可以是min|q(|qx|,|x|)。我们使用DBLP数据集，它是DBLP网站上书目记录的一个快照。它由近90万条记录组成。每条记录由作者名单和出版物的标题组成。该数据集经过预处理，使用空白和标点符号对每条记录进行标记。每条记录中的标记都根据其在整个数据集中的频率进行排序。然后根据记录的长度（标记的数量）对其进行排序。我们实现的基于prex ltering的相似性连接算法显示在算法4、5中。首先，我们使用prex ltering原则[42]将每个与q相似的记录x从数据集中剔除。prex ltering原则如下。让一个记录x的p-prex是(x.)的前p个标记。Ifthat pass the pre|x| dO(tq.,|xx|)e+ 1t), then the (xofxltering stage are verishare at least one token. 只有记录|q| dt.|q|e+ed检查它们是否满足1)-prex of q和重叠相似度阈值。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819165953841.png" alt="image-20210819165953841"></p>
<h1 id="5-方案和实现细节"><a href="#5-方案和实现细节" class="headerlink" title="5. 方案和实现细节"></a>5. 方案和实现细节</h1><p>总结器本质上是以减少到主机的带宽来换取接近存储的计算。我们评估了四种不同的策略来研究这种权衡。</p>
<p>(1) 第一种策略是我们的基线，整个计算是在主机处理器上完成的，就像今天的情况一样。在这个基线中，主机处理器将从SSD中接收所有计算所需的数据。(2) 在另一个极端，人们可以考虑在靠近SSD的懦弱的处理器上进行所有的计算，这只涉及到与主机处理器的查询相关的输出值和输入值的交流。所有计算所需的数据都在SSD内获取和处理。(3) 由于靠近SSD的内核的处理能力相对较低，协同使用主机和wimpy SSD处理器可能更好。为了评估这一策略，我们使用了两种不同的方法。一种方法是对工作负载进行自定义手工编码。对于手工编码方法，我们分析了应用程序，并根据处理器的优势将计算映射到处理器上。直观地说，那些有助于减少与主机处理器的大量数据通信的计算应被映射到靠近SSD的处理器上。程序中具有高计算强度的部分应被映射到主机处理器上。虽然任何功能的计算强度可以根据简单的指标如总指令数自动量化，但在本文中，我们将DSS查询和数据集成代码手工分类为数据密集型或计算密集型的功能。(4) 我们评估的最后一种方法是一种自动方法，动态地选择哪些页面在嵌入式核心上计算，哪些页面在主机上处理。在分配计算任务时，自动方法对整个工作负载是不可知的。对于这种模式，当向SSD设备发出块请求时，主机CPU将所有页面设置为SSD内计算。一旦页面数据被从NAND闪存中获取，SSD控制器就会检查TQ中的空槽。回顾一下，TQ是Summarizer架构中的一个队列，一个页面在这里被注册，以考虑在SSD附近进行处理。如果有空槽，页面就会被登记在TQ中，页面数据就会在SSD中计算。否则，所有的页面数据将被转移到主机CPU而不进行处理。</p>
<p>显然，在主机或SSD控制器上执行整个工作负载是很简单的。这里唯一的挑战是将工作负载编译到两个不同的ISA上运行：在我们的实施中，主机处理器是基于X86的，而SSD控制器的核心是基于ARM的。然而，在两个处理器上协同执行需要分配工作负载。对于手工编码的版本，我们对每个工作负载使用了以下的分工，如下面的列表所示。请注意，这个手编版本有几个变体可以实现（事实上我们也评估了其中的一些变体），但是正如我们在后面的结果部分所显示的那样，手编优化虽然比基线要好，但总体上要比动态工作负载分配方法更出色。动态方法在实践中更容易采用。程序员不必担心工作负载分配，系统会根据动态系统状态自动决定在哪里执行代码。</p>
<ul>
<li>TPC-H查询1,6：对于静态工作负载分配，我们在SSD附近的处理器实现where条件，然后只传输需要做group by和aggregation操作的记录项。</li>
<li>TPC-H查询14：我们实现了哈希连接算法，在行项和零件表之间进行等价连接操作。 在这个算法中，首先是建立阶段，在这个阶段，使用零件表建立一个哈希表，表的键被用于散列，进一步处理所需的项目作为哈希表的值。在下一个迭代中，即探测阶段，我们遍历行项表并检查关键项是否存在于哈希表中。对于两个处理器的处理策略，我们检查SSD附近的处理器的情况，只传输需要散列的记录项，然后进行聚合。</li>
</ul>
<h1 id="6-评测"><a href="#6-评测" class="headerlink" title="6. 评测"></a>6. 评测</h1><h2 id="6-1-评估平台"><a href="#6-1-评估平台" class="headerlink" title="6.1 评估平台"></a>6.1 评估平台</h2><p>我们使用一个工业级的基于闪存的SSD参考平台评估了Summarizer的性能。图4显示了SSD开发板的结构。该板配备了一个多核ARM处理器，执行固态硬盘控制器固件程序（包括FTL管理、磨损平整、垃圾收集、NVMe命令解析和与主机的通信），以及一个FPGA，其中闪存纠错逻辑和NAND闪存控制器逻辑被实现。</p>
<p>ARM处理器通过PCIeGen.3⇥4总线与主机处理器进行通信。另外，ARM处理器和FPGA上的NANDash访问指令控制器逻辑通过SSD开发板上的PCIe总线传输NAND和数据。FPGA上的NAND闪存控制器访问两个NAND闪存DIMM，每个DIMM配备4个NAND闪存芯片。原型板设计忠实地执行了商业SSD的所有功能。与商业固态硬盘设备不同，我们开发板上的原型NAND闪存接口具有较低的内部数据带宽，因为NAND闪存DIMM的NAND闪存堆较少，通道较少。此外，由于纠错逻辑实现的限制，FPGA上的NAND闪存控制器以较低的时钟频率运行。这些限制纯粹是由于在设计我们的电路板时的成本考虑。因此，在我们的电路板上观察到的内部SSD带宽明显低于商业SSD。为了适应较低的内部带宽限制，主机-SSD的带宽也被设定为相应地较低。在商用三星固态硬盘中，外部带宽通常比内部峰值带宽低2-4⇥。因此，与内部FPGA-ARM核心带宽相比，主机-SSD带宽在我们的电路板上被设置为低2⇥。</p>
<p>我们的板子和商业固态硬盘之间的另一个实施差异是，我们的板子配备了比商业固态硬盘上通常看到的更强大的嵌入式内核。与商业NVMe SSD控制器的报告时钟频率（400或500 MHz）相比，我们开发平台上的ARM处理器以更快的峰值时钟频率（1.6 GHz）运行。因此，主机-嵌入式性能比有利于更多的嵌入式核心计算。为了模仿商业固态硬盘，我们节制了ARM核心频率。在下一小节中，我们将描述我们如何选择节流频率。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819170642682.png" alt="image-20210819170642682"></p>
<h2 id="6-2-基于工作量测量的校准"><a href="#6-2-基于工作量测量的校准" class="headerlink" title="6.2 基于工作量测量的校准"></a>6.2 基于工作量测量的校准</h2><p>在这项研究中，我们在英特尔NVMe SSD平台上测试了第4节介绍的几个数据库应用。首先，我们测量了应用程序的I/O时间与计算时间的比例，以节流主机CPU以及SSD的嵌入式核心性能，以满足SSD开发平台上测量的I/O和计算时间比例。表2显示了在真正的NVMe SSD平台上测得的计算时间与I/O时间的比率，该平台配备了英特尔i5-6500（4个核心，运行频率为3.2 GHz），配有8GB DRAM和英特尔NVMe SSD。英特尔NVMe固态硬盘是一款750系列固态硬盘，采用PCI-Express 3.0和20纳米多级单元技术。然后，我们在我们的平台上运行相同的工作负载，以创建一个相等的处理和I/O比率。基于这个比率，我们将ARM内核的频率设定为200MHz。请注意，频率的一些降低也是由于我们平台上的内部带宽较小造成的。</p>
<p><img src="/2021/08/18/paper-summarizer/image-20210819170747252.png" alt="image-20210819170747252"></p>
<h2 id="6-3-Summarizer性能"><a href="#6-3-Summarizer性能" class="headerlink" title="6.3 Summarizer性能"></a>6.3 Summarizer性能</h2><p>如方法论部分所述，我们考虑在主机处理器和SSD附近的嵌入式处理器之间进行页级粒度的工作负载划分。图5显示了SSD内处理程度的性能变化。X轴表示用Summarizer在SSD内处理的页面数量与在主机处理器上处理的页面数量的比率。Y轴是归一化为基线的执行时间，即所有数据都在主机CPU上处理。在这项研究中，我们调整了在主机应用中被标记为SSD内计算的页面的比例，并比较了性能变化。因此，X轴上的零意味着所有的数据都由主机CPU处理，即这是一个基线。如果比率为1，这意味着所有的数据都是在SSD中计算的，而主机CPU只收到最终的结果。X轴上显示的0和1之间的具体数字对应于第3节中描述的Summarizer的静态模式操作。标有DYN的条形图表示使用Summarizer的动态模式得到的结果。在动态模式下，所有来自主机CPU的页面获取请求都是使用READ_PROC_TSKn命令发出的。总结器动态地决定所请求页面的SSD内计算。HD意味着手工编码的任务，用于SSD内的计算。简单的任务（例如，数据库的eld ltering功能）在SSD上执行，以减少数据的跟踪。READ_FILT_TSKn NVMe命令被利用来执行HD模式下的ltering操作。我们测试了手工编码版本在Summarizer静态模式下的性能。也就是说，无论嵌入式处理器的可用资源如何，ltering任务都在SSD中执行。每个执行时间条被分成两部分：在主机端花费的时间（在条中标记为主机时间），以及在SSD端花费的时间（标记为SSD时间）。当使用基线（X轴标签为0）时，花费在SSD侧的时间纯粹是用来读取NAND闪存页面并将其传输到主机上。但是对于其他的条形图来说，花费在SSD方面的时间包括读取和处理SSD上的一部分页面的时间。显然，只在SSD上进行处理（X轴标记为1）会导致明显的性能下降，因为数据计算在软弱的SSD控制器核心上需要更长的时间。手工编码的版本（标记为HD）对所有或大部分页面提供了比静态页级SSD计算更好的性能，但一般来说，手工编码是一种静态的方法，不能适应变化的系统状态。由于固态硬盘上的小核过载，即使过滤任务不需要大量的计算资源，我们的结果显示静态固态硬盘加载方法是无效的，因为I/O请求率超过了小核的服务率。图5的结果也表明，将所有计算放在主机处理器或固态硬盘处理器上并不能提供最佳性能。因此，每个应用程序都有一个甜蜜点，在这个甜蜜点上，SSD和主机之间的协作计算可以提供最好的性能。但这个甜蜜点因工作负载而异，甚至可能因输入数据而异。在动态模式下，Summarizer通过观察SSD中的嵌入式处理器的可用性，动态地决定用户应用功能的执行位置。这种动态方法可以减少程序员在决定SSD内计算的划分时的负担，以达到更好的性能，同时利用SSD内的计算资源。</p>
<p>对于查询6、1和14，使用DYN的TPC-H查询处理性能分别提高了16.4%、10.3%和20.3%。平均而言，我们目前的总结器原型可以将TPC-H的性能提高15.7%。对于相似性连接，性能提高了6.9%。我们观察到的改进百分比与我们需要在每页数据上执行的计算量直接相关。对于TPC-H查询6和14，由于大多数记录都被where条件所限制，我们在每一页上所做的工作量较少，改进也较多。对于TPC-H查询1，大多数记录都通过了where条件，与TPC-H查询6和14相比，每一页的工作量都更大。此外，我们观察到，在相似性连接中，每一页的工作量甚至更高，随之而来的改进也更低。需要注意的是，图中几乎所有的条形图都使用了主机和SSD处理器之间的协作计算（除了0和1）。然而，由DYN实现的性能改进并不仅仅是由于有额外的软弱的CPU资源。正如图中所示，大部分收益来自于减少的I/O处理时间，而不是在SSD上增加一个软弱的内核。我们还必须强调，在该图中看到的性能改进在一定程度上受到评估平台的限制，该平台的内部带宽比商业SSD严重受限。因此，我们认为，这些结果只是展示了Summarizer的潜力，而不是绝对的性能提升。</p>
<h2 id="6-4-设计空间探索：内部-外部带宽比"><a href="#6-4-设计空间探索：内部-外部带宽比" class="headerlink" title="6.4 设计空间探索：内部/外部带宽比"></a>6.4 设计空间探索：内部/外部带宽比</h2><p><img src="/2021/08/18/paper-summarizer/image-20210819170850102.png" alt="image-20210819170850102"></p>
<p>图6显示了性能变化与SSD控制器和NAND闪存芯片之间的内部数据带宽以及主机处理器和SSD之间的PCIe外部带宽比例的关系。如前所述，即使SSD的内部带宽更容易增加，目前的SSD设计者没有动力增加内部带宽，因为外部带宽决定了系统的性能。Summarizer为内部和外部带宽的增长脱钩提供了一个令人信服的理由。如结果所示，如果内部带宽高于外部带宽，SSD内的计算会更有利。</p>
<h2 id="6-5-设计空间探索：SSD内的计算能力"><a href="#6-5-设计空间探索：SSD内的计算能力" class="headerlink" title="6.5 设计空间探索：SSD内的计算能力"></a>6.5 设计空间探索：SSD内的计算能力</h2><p>由于Summarizer利用了SSD控制器处理器未被充分利用的计算能力，预计SSD内计算的性能将随着SSD内更强大的嵌入式处理器而得到改善。为了探索强大的嵌入式处理器对SSD内计算的性能影响，我们通过改变嵌入式处理器的计算能力来测量整个系统的性能变化。如上一节所述，我们节制了嵌入式内核的时钟频率，以模仿商业固态硬盘的运行。我们利用节流能力将嵌入式内核的频率提高到1.6GHz，以获得8⇥的计算能力，或者增加内核的数量来进行SSD内的计算（2个内核运行在1.6GHz，以获得16⇥的计算能力）。虽然频次指标不是衡量性能的唯一标准，但我们在本研究中把它作为一个指标。</p>
<p>图7显示了当Summarizer在动态模式下运行时，性能变化与SSD控制器的改进计算能力的关系。我们的实验结果表明，当嵌入式控制器内核的性能提高16⇥时，TPC-H查询1的整体性能可提高120%，而SSD内计算的平均性能可提高94.5%。由于Summarizer使用懦弱的内核来实现上述结果，Summarizer为在未来的SSD平台中加入更强大的嵌入式内核提供了一个令人信服的理由。</p>
<h2 id="6-6-成本效益"><a href="#6-6-成本效益" class="headerlink" title="6.6 成本效益"></a>6.6 成本效益</h2><p>xxx</p>
<h1 id="7-相关工作"><a href="#7-相关工作" class="headerlink" title="7. 相关工作"></a>7. 相关工作</h1><p>几十年前，包括ActiveDisks、IDISKS、SearchProcessor和RAP等项目[1, 3, 17, 19, 20, 33]已经探索了将计算推到磁存储设备上的想法。然而，由于磁片延迟时间长，输入/输出尺寸相对较小，成本效益有限。</p>
<p>随着数据集规模的增长，数据移动成为执行应用程序时越来越重要的开销[11, 21, 43]。随着非易失性存储器技术的改进，使数据存储设备内部的带宽更加丰富，最近的研究项目，包括Summarizer，开始重新审视将计算推到存储附近的想法。</p>
<p>与Summarizer类似，Active Flash[4, 35, 36]、SmartSSD[8, 16]、Active Disks Meets Flash[7]和Biscuit[12]也试图利用现代SSD中的嵌入式内核来减少冗余的数据移动，以释放主机CPU和主内存。例如，Active Flash[35]提出了一个分析模型来评估SSD内计算的潜力。但是没有介绍实施和操作细节。Summarizer提出了对SSD加载框架的应用开发的详细描述。SmartSSD[8]专注于如何利用SSD内计算来改善特定的数据库操作，比如聚合。Biscuit[12]指出，该方法基于基于ow的编程模型。因此，在Biscuit上运行的应用程序类似于带有数据管道的任务图，以实现任务间通信。Summarizer提出了一套通用的NVMe命令和编程模型，可以在不同的应用领域中使用，以展示SSD内计算的全部潜力。Summarizer提出了一种自动方法，以确定何时为用命令式语言编写的应用程序加载计算，而不对代码结构进行任何限制。</p>
<p>Summarizer的雇员是基于ARM的通用内核，在SSD控制器中很受欢迎。因此，系统设计可以通过更新固件来实现Summarizer需要的大多数架构支持。另一方面，Active Disks Meets Flash[7]、Ibex[41]或BlueDBM[15]利用可重合的硬件或专门的处理器架构来实现同样的目标，限制了应用的灵活性，但增加了设备的成本。</p>
<p>为了向应用展示SSD的隐藏处理能力，Summarizer、Biscuit[12]、Morpheus[39]、SmartSSD[8]和KAML[14]都为应用扩展了标准的NVMe或SATA协议来描述所需的计算。与KAML或SmartSSD不同的是，Summarizer的NVMe命令集为数据库相关的工作负载专门扩展了协议，在使用SSD处理器方面提供了更大的灵活性。</p>
<p>在编程模型方面，Summarizer利用ARM平台中成熟的开发工具来编写和生成在存储设备上运行的代码，而不需要应用设计者处理非常低级的硬件细节或对现有代码进行明显的修改。Biscuit的数据流启发的编程模型[12]或Morpheus[39]中有限的API支持更适合于特定的应用场景。</p>
<p>Summarizer利用了基于闪存的固态硬盘内现有的处理器，这些处理器原本是用于FTL，但大部分时间也是闲置的，因此将额外的硬件成本降到最低。内存处理器[11]、计算RAM[9, 18, 22, 29, 37]、Moneta[5]和Willow[34]需要在相应的数据存储单元中增加处理器，降低了拟议设计的成本效益。</p>
<h1 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h1><p>大数据分析因存储设备上访问数据的有限带宽和长时延而受到阻碍。随着固态硬盘的出现，有新的机会使用固态硬盘中的嵌入式处理器来实现近存储处理。然而，这些处理器的计算能力有限，因此在近存储处理所节省的带宽和计算延迟之间存在权衡。在本文中，我们提出了Summarizer这个近存储处理架构，它为应用程序员提供了一套API，将数据密集型计算加载到SSD处理器。SSD处理器解释这些API调用，并动态地确定一个特定的计算是否可以在近存储处执行。我们在一个功能齐全的SSD评估平台上实施了Summarizer，并评估了几个数据分析应用程序的性能。即使在一个严重受限的SSD平台上，我们也表明，与在主机处理器上执行所有计算的基线相比，Summarizer对TPC-H查询的性能提高了20%。当在固态硬盘中使用更强大的内核时，我们表明这种性能可以得到明显的提升，从而为更高的近固态硬盘计算能力提供了一个令人信服的论据。</p>
]]></content>
      <tags>
        <tag>paper</tag>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computational Storage-Where Are We Today?》 阅读笔记</title>
    <url>/2021/07/08/paper-computational-storage-where-are-we-today/</url>
    <content><![CDATA[<img src="/2021/07/08/paper-computational-storage-where-are-we-today/image-20210711130257276.png" alt="image-20210711130257276" style="zoom: 50%;">

<a id="more"></a>

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><strong>计算存储设备（CSD）是包括通用、特殊用途和/或可重新配置的处理单元的存储设备</strong>，现在正从不同的供应商那里获得商业化服务。CSD能够运行通常在主机CPU上运行的软件，但在数据所在的存储设备上。因此，带有一个或多个CSD的服务器可以改善处理大量数据的软件的整体性能和能源消耗。<br>为了促进CSD的研究和采用，本立场文件认为，商业上可用的CSD仍然缺少丰富的功能，应该仔细考虑将其广泛部署在生产数据中心。事实上，现有的CSD忽略了（异质）资源管理问题，没有充分考虑安全性，也没有考虑多用户，也没有考虑数据一致性，更没有考虑可用性。在这里，我们讨论了一些开放性的研究问题，以及几个众所周知的编程模型在多大程度上可以帮助解决这些问题–同时考虑硬件和软件接口的设计。</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>计算存储（CS）是一种接近数据处理[16]的架构，它使数据在存储设备内得到处理，而不是被传送到主机中央处理单元（CPU）[12]。图1概括了SNIA[11]研究的几种CS架构。</p>
<p>CS架构引入了许多优点。a) 卸载主机CPU–因此，可以安装更便宜的CPU，或者CPU可以运行其他任务；b) 减少数据传输，提高性能–只有必要的数据需要从存储设备传输到CPU，CS设备上的通用或特殊用途的处理元件或可重新配置的单元可以代替CPU处理数据，甚至并行处理。c) 降低能耗–PCIe上的存储设备的总功耗不能超过25W[41]，因此计算存储设备（CSD）上的处理单元只消耗其中的一小部分，而服务器级主机CPU的功耗则在100W左右； d) 保留数据中心的基础设施支出–即。 e., d) 保留数据中心基础设施的开支–即在不需要投资更快的网络的情况下扩展数据中心的性能。</p>
<p>虽然对HDD[12, 34]和SSD[37, 31, 29, 42]的存储内处理的研究分别从20世纪90年代和2010年开始进行，但直到最近CS平台才成为商业上可行的，一些公司已经在销售具有CS功能的SSD–例如三星[9]、NGD[6]和ScaleFlux[10]。尽管CSD在市场上出现，但这些设备的编程和推理都很麻烦，这可能会阻碍它们的广泛采用。事实上，在CSD中没有软件或硬件支持异质资源管理，也没有安全、一致性和一般可用性的考虑。<br>基于作者最近几年在几个学术界和工业界的CS原型上的工作经验，本文试图回顾最先进的技术，列出CSD最紧迫的开放性研究问题，并分析不同的编程模型在回答这些问题上的适用性–同时不忘仍未准备好的CSD的硬件/软件接口。这项工作的重点是单个直接连接的CSD，存储和计算单元驻留在同一设备上。然而，我们相信同样的发现会广泛适用，比如说智能磁盘阵列控制器。此外，这项工作普遍关注带有通用CPU、专用CPU的CSD，以及带有可重新配置硬件（FPGA）的CSD。因此，在本文的其余部分，我们把所有这些都称为 “处理单元”。</p>
<p>简而言之，我们的结论是，CSD的硬件和软件还没有准备好，在硬件和软件层面上还需要做更多的工作，以充分利用该技术的规模。</p>
<h1 id="2-背景和动机"><a href="#2-背景和动机" class="headerlink" title="2. 背景和动机"></a>2. 背景和动机</h1><p>计算存储通过减轻必须在存储和计算平面之间传输的数据量，减少了输入和输出的交易互连负荷。因此，它可以更好地服务于现代工作负载，如大批量的大数据分析或人工智能任务，具有更快的性能[27]，以提高数据中心基础设施的利用率[29]，同时还有许多其他好处。我们在下面讨论几个问题。</p>
<p>计算型存储的一个主要好处是更快、更节能的数据处理。计算存储架构将通常由主机计算元素–CPU和最终的加速器–处理的工作卸载到存储设备上。如果没有CS，例如在数据分析的背景下，主机计算元素提出的请求需要将所有的数据从一个存储设备转移到它那里。然后，主机计算元素必须在执行其指定的任务之前减少数据的数量。在CS方法中，存储设备在将数据转移到主计算层进行处理之前，会根据主机请求的相关性对数据进行初步限定。因此，可能会减少需要由主机移动和处理的数据量。每个工作负载的主机计算指令的减少意味着主机CPU和最终的加速器有更多的处理能力可用于支持其他工作负载。</p>
<p><img src="/2021/07/08/paper-computational-storage-where-are-we-today/image-20210710185558355.png" alt="image-20210710185558355"></p>
<p>计算型存储的另一个好处是，它使共享存储环境更有利于对性能要求最高的工作负载。通常情况下，直接连接的存储方法被用来为这些工作负载服务，以避免存储网络延迟，而且还可以通过将数据分散到许多设备上来提高吞吐量。然而，这往往会导致资源利用不足，而且由于需要在多个设备上搜索相关数据，也会带来进一步的延迟。相比之下，CS允许应用程序同时在每个存储设备上执行。这就提供了一个平行处理的水平，以实现类似于微服务的方法，在所有单独的设备上运行这些应用程序。这种同时处理数据的能力大大减少了查找数据的时间，并为主机提供了所需的结果。</p>
<p>计算存储还可以帮助利用现有的网络基础设施更长时间，以及真正扩展下一代网络。因为计算能力使存储首先在更大的数据集上工作，它利用了现代固态硬盘更高的I/O能力，避免了性能受到网络的限制。因此，网络互连对于计算型存储来说就不那么重要了。因此，计算型存储通过使多个应用程序的性能在同一基础设施上得到加速，同时优化整个堆栈的基础设施资源的利用，来增加价值。</p>
<h2 id="2-1-硬件和软件的状况"><a href="#2-1-硬件和软件的状况" class="headerlink" title="2.1 硬件和软件的状况"></a>2.1 硬件和软件的状况</h2><p>大多数固态硬盘都有专用的处理和存储元件–即嵌入式多核CPU或FPGA，以及除闪存外的DRAM。这些都是用来执行用户数据的读、写和擦除命令，以及闪存管理功能。由于SSD上有可用的计算资源，一些项目[31, 42, 29, 12, 38, 25, 35, 14, 28, 46, 36, 39, 45, 44, 24, 35, 13, 23]探索了在SSD设备本身运行用户定义的数据密集型计算任务的机会，如数据库操作。虽然观察到了性能的提高和能源的节约，但一些挑战阻碍了计算型固态硬盘的广泛使用和采用。首先，可用的处理能力受到设计的限制：低性能的嵌入式处理器，或资源有限的FPGA，以及高延迟的存储DRAM，需要额外的仔细编程来运行用户定义的代码以避免性能限制。其次，一个灵活和通用的接口和编程模型从未被定义过，以方便在SSD上执行用高级编程语言（如C/C++）编写的用户定义的代码。</p>
<p>此外，编程模型还需要支持多线程的各种存储应用程序的并发执行，使其成为复杂用户应用程序的有效平台。尽管如此，必须在主机和CSD上定义不同层次的硬件和软件的接口，以使平台真正可用。第三，没有人考虑如何处理多个用户。</p>
<p>在许多不同的硬件和软件上已经进行了大量的工作。据我们所知，到今天为止，只有两块CSD开发板可以公开使用：汉阳大学的OpenSSD[1]（实现了图1.b的架构），以及由DellEMC和NXP合作开发的DFC[26]（实现了图1.c的架构）。两者都有一个多核ARM通用处理器、加速器和可重新配置的硬件，除了一种闪存介质和DRAM之外。尽管是开源的，但它们都是基于旧的标准，不再被支持。另一方面，存储供应商使用他们自己的SSD原型[31, 38, 15]，FPGA板已经被用于研究[42, 46]。来自学术界的模拟环境也存在[30, 8, 15]，但缺乏支持。最近，市场上出现了CSD，包括具有多个64位ARM内核的NGD原位处理固态硬盘[6]、ScaleFlux CSD[10]和基于FPGA的三星SmartSSD[9]（实现图1.b中的架构）。</p>
<p>其他产品，如Eideticom NoLoad计算存储处理器[5]，在不同的PCIe板上实现存储和计算，如图1.c所示，由p2p DMA和NVMe的CMB[21]启用。这些产品触发了SNIA为CSD扩展NVMe协议的提议[11]–目前该提议正在进行中。因此，我们认为，为了使计算存储设备对大众更有吸引力，应该尽快做一些事情。值得注意的是，主要由于公司的知识产权问题，目前的CSD产品提供了非常有限的可定制性，因此，不能轻易用于研究目的，如接口或编程模型探索。</p>
<h1 id="3-开放式研究问题"><a href="#3-开放式研究问题" class="headerlink" title="3. 开放式研究问题"></a>3. 开放式研究问题</h1><p>我们认为，仅仅展示性能的提高和能源的减少还不足以说服CSD的广泛采用。因此，在这里我们提出了在现有的CS技术中发现的各种开放性研究问题，涉及a）资源管理，b）安全性，c）数据一致性，以及d）可用性。</p>
<h2 id="3-1-资源管理"><a href="#3-1-资源管理" class="headerlink" title="3.1 资源管理"></a>3.1 资源管理</h2><p>一个有一个或多个CSD的服务器本身就是一个单一的系统。但从软件的角度来看，由于主板上或任何CSD上的每一个（一组相同的）处理单元都运行自己的软件栈，这样的服务器看起来就像一个分布式系统。</p>
<p>单一系统和分布式系统中的资源管理是提供高效和公平使用硬件资源的基础，包括处理单元、内存和存储。例如，这意味着在任何给定的时间，没有任何单一的资源是过载的，也没有应用程序对资源感到饥饿。同样地，一个用户不应该垄断所有资源的使用。资源管理政策可能需要在计算资源之间平衡工作负荷，以满足性能和功率目标。然而，这在新兴的CS架构和相关工作中是缺乏的。</p>
<p>问题： a) 在哪里进行资源管理决策？b) 当CSD之间存在复制时，哪个复制体映射某个计算？ c) 如何在主机和CSD的可用处理单元之间保持工作负载和能源消耗信息？过载的CSD应该通知主机或其他CSD，然后呢？ e) 如何在不同的用户之间提供资源的公平性（如CPU周期、FPGA的真实空间、内存/闪存空间和闪存通道流量）？ f) 如何将数据映射到多个CSD，和/或CSD内部的不同闪存通道？ g) 对于使用单个CSD的应用程序，在主机CPU上运行和CSD上运行之间的平衡点是什么？这是否取决于工作负载？</p>
<h2 id="3-2-安全问题"><a href="#3-2-安全问题" class="headerlink" title="3.2 安全问题"></a>3.2 安全问题</h2><p>当一个固态硬盘存储不同用户的数据时，最基本的是拒绝用户访问对方的数据。对于今天的固态硬盘，有两种不同的方法来控制数据访问。第一种是使用文件系统–每个文件都有一个所有者，等等。第二种是使用硬件虚拟化（SRIOV）或NVMe命名空间[7]，以便将存储的不同部分分配给不同的所有者。尽管存在保护机制，但运行在CSD的处理单元（CPU、加速器、FPGA）上的代码有可能访问存储在闪存芯片上的所有数据。当使用文件系统进行访问控制时，定义安全机制和技术以保持在CSD中运行的软件和在主机CPU上运行的软件具有相同的用户概念是很重要的。<br>这是由于存储设备和运行在主机CPU上的软件之间存在语义上的差距–主机CPU知道文件系统和用户，但对于存储设备来说，这并不总是真的。值得注意的是，用户的知识可以是不对称的，也就是说，在大多数情况下，CSD不需要像主机CPU那样知道所有用户的细节。运行在CSD上的代码应该只访问它被允许访问的内容。<br>另一个问题是信任CSD本身的可重新配置的硬件、软件和固件的身份和完整性。假设存在一种只安装适当的固件和系统软件的方法，那么最根本的是，除此之外，只有且只有用户提交的代码在CSD上运行。此外，用户提交的代码不应改变CSD上的固件和系统软件的完整性。</p>
<p>问题。 a) 如何在CSD上将多个应用程序相互隔离？ b) 如何使它们免受侧信道攻击、拒绝服务等？ c) 不同的编程模型需要不同的隔离技术。例如，硬件虚拟化可以用来隔离不同的软件堆栈。d) 软件隔离的成本是多少？这个成本是否盖过了好处？ e) 如何确保CSD上运行的代码是合法的？不仅仅是在启动时，而且在运行时也是如此？</p>
<h2 id="3-3-数据一致性"><a href="#3-3-数据一致性" class="headerlink" title="3.3 数据一致性"></a>3.3 数据一致性</h2><p>当数据被多方读取和写入时，可能会出现一致性问题。例如，同一个数据块可以被主机和CSD的CPU同时读取，而运行在这两者之一的应用程序修改了该块的内容。在这种单方面的修改之后，每个CPU将在不同的数据上运行–同时假设数据是相同的。事实上，在一个CPU修改数据后，它应该立即通知另一个。同样的问题不仅适用于文件内容，也适用于文件系统元内容。例如，当运行在主机CPU或CSD的CPU上的软件创建一个新文件时，必须通知另一个CPU创建。这也延伸到了几乎所有的文件系统操作。<br>显然，个人电脑的经典文件系统并没有解决这些问题。此外，常见的磁盘接口（如SATA、SAS、NVMe）也没有准备好管理这种情况–接口的建立是假设磁盘控制器严格执行主机CPU的命令。同样，数据可能在几个磁盘之间被复制或分片。为了保证一致性，对复制或分片数据的修改应该是平行进行的–这也适用于擦除码或奇偶校验块[13]。<br>最后，单个CSD在任何操作中都可能失败，包括存储中的数据处理。复制、分片和奇偶校验/擦除编码肯定可以用来容忍故障，而不是提高性能。这样的技术很可能在CSD之上实现。然而，为了支持这一点，CSD可能需要实现额外的功能 ，例如，向主机CPU或其他CSD通报故障。<br>a) 如何在主机和CSD上一致地使用相同的文件系统？ b) 文件系统的变化如何处理？<br>如何更新主机上关于CSD上文件修改的软件？ c) 是否需要一个新的文件系统？经典的文件系统可以被扩展来支持吗？分布式文件系统是否已经解决了这个问题？如果是的话，性能如何？ d) 如何扩展当前的存储接口以提供进入CSD的数据变化通知？是否需要通知？ e) 显式事务管理如何？<br>f) 硬件和软件故障怎么办？ g) 如果有复制，增加了一个新文件，如何处理？h) CSD之间如何为复制或任何其他需要在多个驱动器上协调操作的操作进行通信？ i) 通信需要通过主机CPU还是应该直接进行（例如，通过P2P DMA/RDMA）–哪一个更好？</p>
<h2 id="3-4-可用性"><a href="#3-4-可用性" class="headerlink" title="3.4 可用性"></a>3.4 可用性</h2><p>为了扩大采用范围，可用性无疑是最重要的。CSD应该在任何级别的软件（用户级或内核级）上都能简单而快速地进行编程、部署和调试。<br>调试在主机和CSD的CPU之间运行的应用程序不应该是一场噩梦。例如，开发一个分布式软件后最复杂的步骤之一就是调试–这正是因为在这些环境中，程序员最终会有多个调试器，或者来自不同系统的日志记录，这些记录必须同步才能发挥作用并确定问题的来源。分布式系统的调试可以提供一些提示。<br>一个重要的问题是，CSD应该被看作是一个完全独立的计算机节点，还是作为计算机节点的一部分？我们认为这在很大程度上取决于CSD上可用的硬件资源–如果计算和内存资源与主机上的资源相当，用户就可以在主机和CSD上运行相同的工作负载。然而，如果资源不一样，CSD应该被认为是存储端加速器–因此，一个完整的工作负载应该只在主机CPU上执行。在此基础上，关于在CSD上运行什么工作负载的决定可以由运行在主机CPU上的软件或数据中心调度器做出。然而，在后一种情况下，CSD应该可以通过网络到达，这就要求CSD要有一个网络接口硬件，而且要有额外的成本。<br>问题： a) 除了可编程性，如何在CSD上轻松部署应用？c) 应用程序的资源管理器需要哪些信息来做出最佳的放置决定？ d) 如何设计一个易于使用的API，使应用程序的修改最小化？<br>类似POSIX的API是否容易被采用？</p>
<h1 id="4-编程模型"><a href="#4-编程模型" class="headerlink" title="4. 编程模型"></a>4. 编程模型</h1><p>显然，对于希望在主机和CSD处理单元之间运行他/她的应用程序的程序员来说，可用的编程模型在很大程度上影响了第3节中问题的回答方式。我们认为，没有一个 “万能 “的编程模型适用于所有类型的应用，因此，我们希望对每个模型进行定量和定性的分析。在这一节中，我们将讨论一些编程模型，并描述我们对每个模型的设想，即如何回答上述研究问题，这在表1中进行了总结。</p>
<p><img src="/2021/07/08/paper-computational-storage-where-are-we-today/image-20210710191834187.png" alt="image-20210710191834187"></p>
<h2 id="4-1-数据流"><a href="#4-1-数据流" class="headerlink" title="4.1 数据流"></a>4.1 数据流</h2><p>在数据流模型中（例如，[31，32]），为每个传输中的数据块定义了一个转换操作序列。一个转换操作接收输入的数据块，并输出转换后的数据块。一般来说，”传输中的数据 “是指在不同的硬件和软件层之间传输的数据块，不仅包括从闪存芯片传输到CSD/主机CPU的数据块，还包括流经不同内核和应用程序软件层的数据块。</p>
<p>当与CSD一起使用时。将数据流编程模型映射到CSD环境中是很简单的：对于每个存储命令（即磁盘块读或写），关联一个或一组转换操作，类似于[19, 13, 40]。主机和CSD的处理单元之间的通信可以通过扩展标准接口（例如，SATA、SAS、NVMe）来处理。扩展包括下载转换操作的新命令或对现有命令的修改，以便在主机和CSD的CPU之间交换每个会话或全球数据。<br>数据流模型很好地处理了第3节中列出的四个关注点中的大部分。这种编程模型的优点是，操作可以被定义为细粒度，并在任何地方（主机CPU或CSD的处理单元）执行，简化了资源管理。操作可以移回主机进行负载平衡，如果数据被复制，也可以透明地进行复制。此外，多个操作可以被合并、拆分以及并行化。当并行化时，对每个会话或全局数据的访问必须得到保护，以保证一致性。<br>为了安全起见，必须引入一种将数据与用户关联的方法。最后，数据流程序可以用任何语言来定义，尽管提供某种正式属性的语言是首选，如终止和内存安全。<br>不幸的是，只有一堆应用程序是在这种编程模型中实现的，当一个应用程序是在客户-服务器或共享内存模型中编写的，这就需要重写程序。因此，寻求研究能自动将应用程序转换为数据流的编译器工具。</p>
<h2 id="4-2-客户端-服务器"><a href="#4-2-客户端-服务器" class="headerlink" title="4.2 客户端-服务器"></a>4.2 客户端-服务器</h2><p>这包括在集群内开发和部署的应用程序，如基于消息传递接口（MPI）、远程过程调用（RPC）、MapReduce等。这些应用的唯一要求是在多个计算节点之间建立网络连接–TCP/IP、UDP或RDMA是最常见的。这类应用被严格划分为多个程序，每个程序在不同的处理节点上运行。<br>当与CSD一起使用时。用这种编程模型开发的应用程序可以直接映射到CSD设置中，而不需要做任何修改–假设该应用程序可以在CSD提供的软件环境中运行。这可以通过在主机和CSD CPU之间和/或CSD CPU之间建立网络通道来实现[6]。然而，本地编译的应用程序可能需要重新编译为目标CSD的CPU（如ARM）的指令集架构（ISA）。<br>虽然不是不可能，但这个过程可能非常复杂。<br>事实上，它可能需要整个工具链，并重新编译程序所需的所有库–这是因为并非所有库都可用于所有的ISA。此外，许多这样的分布式应用是基于一个非常大的软件基础，涉及到几个不同的库。这在运行时通常会消耗大量的内存（除存储外），限制了可以同时在CSD上运行的实际应用数量，因此导致性能下降。<br>在客户-服务器模式下，资源管理的粒度是在程序层面上的–这是因为只有程序可以在CPU之间移动（假设同一程序可用于系统中存在的所有CPU ISA）。算法被嵌入到构建应用程序的不同程序中；因此，资源管理器/调度器不能以更精细的粒度行事，阻碍了自动优化。<br>安全性是在应用层面提供的，应用最终可以嵌入到容器中（操作系统层面的虚拟化）。标准的操作系统技术可以被用来使CSD的应用程序只访问属于特定用户的数据。</p>
<h2 id="4-3-共享内存"><a href="#4-3-共享内存" class="headerlink" title="4.3 共享内存"></a>4.3 共享内存</h2><p>共享内存编程模型在多核处理器上被广泛采用。它要求处理单元之间有一种（一致的）共享内存的形式。当硬件共享内存不可用时，可以使用软件共享内存，或分布式（虚拟）共享内存（DSM） [20, 33] 。共享内存编程模型的另一个假设是，所有的CPU都是相同的，或者至少是实现了相同的ISA。<br>当与CSD一起使用时。主机和CSD的CPU可能没有相同的ISA。事实上，许多现有的部署的特点是，主机上的x86 CPU和CSD的ARM CPU。学术项目，如Popcorn Linux[22, 18]和H-Container[17]，使为共享内存多核开发的应用程序能够透明地在异构ISA核上运行–无需修改任何应用程序。这包括在主机CPU上启动一个应用程序，然后将其所有线程迁移到CSD上。<br>在这种模式下，资源管理有可能在汇编指令的最细粒度上完成。这样一来，计算可以随时在主机CSD的CPU之间摆动，例如，基于计算密集度和数据的位置。<br>这种编程模型的问题是，当硬件共享内存不可用时，它应该由软件提供，这可能是昂贵的。然而，未来PCIe的发展可能会在PCIe上的设备CPU和主机CPU之间提供一致的共享内存[2, 3, 4]。此外，共享内存编程模型也需要注意一致性问题，这种模型中的计算不能通过外部资源管理器进行并行化或优化。最后，安全性可以通过经典操作系统中的方法来实现（如使用文件系统或第3.2节中描述的硬件虚拟化/NVMe命名空间），但要进一步研究</p>
<h1 id="5-存储接口"><a href="#5-存储接口" class="headerlink" title="5. 存储接口"></a>5. 存储接口</h1><p>在这一节中，我们回顾了每种编程模型的硬件和软件接口含义。目前有不同类型的存储接口被工业界和研究界广泛采用（例如，基于块、基于文件和基于对象的接口），但我们相信我们的发现适用于任何这些接口</p>
<h2 id="5-1-硬件接口"><a href="#5-1-硬件接口" class="headerlink" title="5.1 硬件接口"></a>5.1 硬件接口</h2><p>数据流编程模型需要有限的存储接口修改。正如第4.1节所讨论的，一个转换操作应该只是分配给一个数据流，对于数据流的每个数据块都要调用该操作。因此，对今天的存储接口，如NVMe，最小的要求是提供额外的命令来。1）下载程序；2）将程序附加/分离到数据流中；3）定义数据流；4）调试/记录。所有这些命令都可以通过简单地扩展现有的NVMe协议/接口来实现，作为支持传统的软件。请注意，有了这个接口，开发者不需要关心CSD的CPU上运行的是哪个软件栈，例如，它可以是Linux，也可以是一个固件。<br>服务器-客户端编程模型也可能需要有限的存储接口修改。如第4.2节所述，只需要一个消息传递通道来模拟网络通信–这可以用发送和接收队列来实现（类似于RDMA、NVMe等）。这种变化可以通过向NVMe协议/接口添加新的命令集来扩展它，其中不仅包括用于消息通信的命令，还包括用于下载、运行和监控存储中的程序。<br>共享内存编程模型（第4.3节）本身就是在需要一个高性能的实现时，要求对当前的存储接口进行更多的改变，即没有软件DSM开销。如果不需要，则要求对客户端-服务器编程模型所要求的接口进行同样的修改。这样的修改足以实现软件DSM。相反，当需要一个高性能的实现时，在主机CPU和CSD的CPU之间应该有一种硬件共享内存，例如，由新的相干外围总线互连[2, 3, 4]提供。硬件共享内存不一定是一致的–一致性可以通过软件提供。</p>
<h2 id="5-2-软件接口"><a href="#5-2-软件接口" class="headerlink" title="5.2 软件接口"></a>5.2 软件接口</h2><p>在数据流编程模型内编写的应用程序不需要任何特定的软件接口–事实上，程序会声明输入源以及输出源，即来自或流向存储介质的数据流。一个应用程序的开发者不会直接接触到任何CSD特定的硬件接口，而运行时系统则将程序员从这些技术性问题中屏蔽掉。<br>当一个应用程序是在服务器-客户端或共享内存编程模型内编写的，当在CSD上执行时，它被期望直接与闪存阵列接口。请注意，这对性能是必要的。因此，应该定义一个软件接口来访问闪存阵列。一个幼稚的解决方案是用UNIX设备来抽象每个不同的闪存阵列的通道。因此，每个用户可以被分配一个不同的通道。尽管这是一个实用的解决方案，它与底层硬件有很好的映射关系，并且可以用于保护/隔离，但由于性能的原因，不同的用户被分配到不同的NAND通道是非常不可能的–这是因为并行地写入和读取几个通道可以带来高性能。<br>此外，用户通过文件访问存储的数据。文件是一个文件系统的抽象，通常由主机操作系统提供，在SSD上没有必要知道。因此，需要一个更细粒度的解决方案来保护/隔离不同用户的数据，这就需要为程序员提供另一个抽象概念。流的概念，如（非连续的）闪存块的列表可能是一个解决方案，但现有的硬件并没有提供任何相关的机制。<br>在主机方面，同样的CS硬件接口应该可以被用户和内核级别的软件使用。这是为了支持内核空间的传统文件系统和用户空间的现代存储软件（例如SPDK）。需要一个 “对称的 “内核/用户接口。<br>最后，为了支持代码不能被移到CSD的情况，因此它应该在主机操作系统上运行，一个对称的软件接口应该可以在主机和CSD上实现。</p>
<h1 id="6-结论性意见"><a href="#6-结论性意见" class="headerlink" title="6. 结论性意见"></a>6. 结论性意见</h1><p>在本文中，我们简要地调查了计算存储的技术现状，并提出了几个可能需要考虑的公开挑战，以促进计算存储技术在研究和工业界的应用–现有的计算存储硬件和软件还没有准备好在生产中大规模使用。然后，我们讨论了最广泛使用的具有硬件/软件接口的编程模型如何帮助解决这些挑战。我们相信，我们在本文中的讨论和教训可以为计算存储技术的大规模应用提供更高的清晰度，即可能需要什么.</p>
<h1 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h1><p>[1] The OpenSSD Project. <a href="http://www.openssd-project.org/">http://www.openssd-project.org/</a>, 2016. </p>
<p>[2] Cache Coherent Interconnect for Accelerators (CCIX). <a href="http://www.ccixconsortium.com/">http://www.ccixconsortium.com/</a>, 2017. </p>
<p>[3] Gen-Z Consortium. <a href="http://genzconsortium.org/">http://genzconsortium.org/</a>, 2017. </p>
<p>[4] OpenCAPI Consortium. <a href="http://opencapi.org/">http://opencapi.org/</a>, 2017.</p>
<p>[5] Eideticom. NoLoad Computational Storage Processor. <a href="https://www/">https://www</a>. eideticom.com/uploads/images/NoLoad Product Spec.pdf, 2020. </p>
<p>[6] NGD Systems. <a href="https://www.ngdsystems.com/">https://www.ngdsystems.com/</a>, 2020. </p>
<p>[7] NVMe Specifications. <a href="https://nvmexpress.org/specifications/">https://nvmexpress.org/specifications/</a>, 2020. </p>
<p>[8] OX: Computational Storage SSD Controller. <a href="https://github.com/DFC-OpenSource/ox-ctrl">https://github.com/DFC-OpenSource/ox-ctrl</a>, 2020. </p>
<p>[9] Samsung. <a href="https://samsungsemiconductor-us.com/smartssd">https://samsungsemiconductor-us.com/smartssd</a>, 2020. </p>
<p>[10] ScaleFlux. <a href="https://scaleflux.com/">https://scaleflux.com/</a>, 2020. </p>
<p>[11] SNIA. Computational Storage. <a href="https://www.snia.org/computational">https://www.snia.org/computational</a>, 2020. </p>
<p>[12] A. Acharya, M. Uysal, and J. Saltz. Active disks: Programming model, algorithms and evaluation. ACM SIGOPS Operating Systems Review, 32(5):81–91, 1998. </p>
<p>[13] I. F. Adams, J. Keys, and M. P. Mesnier. Respecting the block interface–computational storage using virtual objects. In 11th USENIX Workshop on Hot Topics in Storage and File Systems (HotStorage 19), 2019. </p>
<p>[14] D.-H. Bae, J.-H. Kim, S.-W. Kim, H. Oh, and C. Park. Intelligent ssd: a turbo for big data mining. In Proceedings of the 22nd ACM international conference on Information &amp; Knowledge Management, pages 1573–1576, 2013. </p>
<p>[15] A. Barbalace, M. Decky, J. Picorel, and P. Bhatotia. BlockNDP: Block-storage Near Data Processing. ACM/IFIP Middleware ’20, New York, NY, USA, 2020. [16] A. Barbalace, A. Iliopoulos, H. Rauchfuss, and G. Brasche. It’s time to think about an operating system for near data processing architectures. In Proceedings of the 16th Workshop on Hot Topics in Operating Systems, pages 56–61, 2017. </p>
<p>[17] A. Barbalace, M. L. Karaoui, W. Wang, T. Xing, P. Olivier, and B. Ravindran. Edge computing: the case for heterogeneous-isa container migration. In Proceedings of the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments, pages 73–87, 2020. </p>
<p>[18] A. Barbalace, R. Lyerly, C. Jelesnianski, A. Carno, H.-r. Chuang, and B. Ravindran. Breaking the boundaries in heterogeneous-isa datacenters. In Proceedings of the 22th International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS ’17, 2017. </p>
<p>[19] A. Barbalace, J. Picorel, and P. Bhatotia. Extos: Data-centric extensible os. In Proceedings of the 10th ACM SIGOPS Asia-Pacific Workshop on Systems, APSys ’19, page 31–39, New York, NY, USA, 2019. Association for Computing Machinery. </p>
<p>[20] A. Barbalace, B. Ravindran, and D. Katz. Popcorn: a replicatedkernel os based on linux. In Proceedings of the Linux Symposium, Ottawa, Canada, 2014. </p>
<p>[21] S. Bates and O. Duer. Enabling the NVMe CMB and PMR ecosystem. <a href="https://nvmexpress.org/wp-content/uploads/Session%022-Enabling-the-NVMe-CMB-and-PMR-Ecosystem-Eideticom-and%02Mell....pdf">https://nvmexpress.org/wp-content/uploads/Session2-Enabling-the-NVMe-CMB-and-PMR-Ecosystem-Eideticom-andMell....pdf</a>, 2018. </p>
<p>[22] S. K. Bhat, A. Saya, H. K. Rawat, A. Barbalace, and B. Ravindran. Harnessing energy efficiency of heterogeneous-isa platforms. SIGOPS Oper. Syst. Rev., 49(2):65–69, Jan. 2016. </p>
<p>[23] W. Cao, Y. Liu, Z. Cheng, N. Zheng, W. Li, W. Wu, L. Ouyang, P. Wang, Y. Wang, R. Kuan, et al. Polardb meets computational storage: Efficiently support analytical workloads in cloud-native relational database. In 18th USENIX Conference on File and Storage Technologies (FAST 20), pages 29–41, 2020. </p>
<p>[24] S. Cho, C. Park, H. Oh, S. Kim, Y. Yi, and G. R. Ganger. Active disk meets flash: A case for intelligent ssds. In Proceedings of the 27th international ACM conference on International conference on supercomputing, pages 91–102, 2013. </p>
<p>[25] A. De, M. Gokhale, R. Gupta, and S. Swanson. Minerva: Accelerating data analysis in next-generation ssds. In 2013 IEEE 21st Annual International Symposium on Field-Programmable Custom Computing Machines, pages 9–16. IEEE, 2013. </p>
<p>[26] J. Do. Softflash: Programmable storage in future data centers. <a href="https://www.snia.org/sites/default/files/SDC/2017/presentations/">https://www.snia.org/sites/default/files/SDC/2017/presentations/</a> Storage Architecture/Do Jae Young SoftFlash Programmable Storage in Future Data Centers.pdf, 2017. </p>
<p>[27] J. Do, V. C. Ferreira, H. Bobarshad, M. Torabzadehkashi, S. Rezaei, A. Heydarigorji, D. Souza, B. F. Goldstein, L. Santiago, M. S. Kim, et al. Cost-effective, energy-efficient, and scalable storage computing for large-scale ai applications. ACM Transactions on Storage (TOS), 16(4):1–37, 2020. </p>
<p>[28] J. Do, Y.-S. Kee, J. M. Patel, C. Park, K. Park, and D. J. DeWitt. Query processing on smart ssds: opportunities and challenges. In Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data, pages 1221–1230, 2013. </p>
<p>[29] J. Do, S. Sengupta, and S. Swanson. Programmable solid-state storage in future cloud datacenters. Communications of the ACM, 62(6):54–62, 2019. [30] D. Gouk, M. Kwon, J. Zhang, S. Koh, W. Choi, N. S. Kim, M. Kandemir, and M. Jung. Amber: Enabling precise fullsystem simulation with detailed modeling of all ssd resources. In 2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), pages 469–481. IEEE, 2018. </p>
<p>[31] B. Gu, A. S. Yoon, D. Bae, I. Jo, J. Lee, J. Yoon, J. Kang, M. Kwon, C. Yoon, S. Cho, J. Jeong, and D. Chang. Biscuit: A framework for near-data processing of big data workloads. In 2016 ACM/IEEE 43rd Annual International Symposium on Computer Architecture (ISCA), pages 153–165, 2016. </p>
<p>[32] I. Jo, D.-H. Bae, A. S. Yoon, J.-U. Kang, S. Cho, D. D. Lee, and J. Jeong. YourSQL: a high-performance database system leveraging in-storage computing. Proceedings of the VLDB Endowment, 9(12):924–935, 2016. </p>
<p>[33] D. Katz, A. Barbalace, S. Ansary, A. Ravichandran, and B. Ravindran. Thread migration in a replicated-kernel os. In 2015 IEEE 35th International Conference on Distributed Computing Systems, pages 278–287. IEEE, 2015. </p>
<p>[34] K. Keeton, D. A. Patterson, and J. M. Hellerstein. A case for intelligent disks (idisks). Acm Sigmod Record, 27(3):42–52, 1998. </p>
<p>[35] G. Koo, K. K. Matam, I. Te, H. K. G. Narra, J. Li, H.-W. Tseng, S. Swanson, and M. Annavaram. Summarizer: trading communication with computing near storage. In 2017 50th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), pages 219–231. IEEE, 2017. </p>
<p>[36] Y.-S. Lee, L. C. Quero, Y. Lee, J.-S. Kim, and S. Maeng. Accelerating external sorting via on-the-fly data merge in active ssds. In 6th USENIX Workshop on Hot Topics in Storage and File Systems (HotStorage 14), 2014. </p>
<p>[37] H. Li, M. Hao, S. Novakovic, V. Gogte, S. Govindan, D. R. Ports, I. Zhang, R. Bianchini, H. S. Gunawi, and A. Badam. Leapio: Efficient and portable virtual nvme storage on arm socs. In Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, pages 591–605, 2020. </p>
<p>[38] S. Pei, J. Yang, and Q. Yang. Registor: A platform for unstructured data processing inside ssd storage. ACM Transactions on Storage (TOS), 15(1):1–24, 2019. </p>
<p>[39] L. C. Quero, Y.-S. Lee, and J.-S. Kim. Self-sorting ssd: Producing sorted data inside active ssds. In 2015 31st Symposium on Mass Storage Systems and Technologies (MSST), pages 1–7. IEEE, 2015. </p>
<p>[40] R. Schmid, M. Plauth, L. Wenzel, F. Eberhardt, and A. Polze. Accessible near-storage computing with fpgas. In Proceedings of the Fifteenth European Conference on Computer Systems, EuroSys ’20, New York, NY, USA, 2020. Association for Computing Machinery. </p>
<p>[41] Z. Schoenborn. Board Design Guidelines for PCI Express Architecture. <a href="https://web.archive.org/web/20160327185412/http://e2e">https://web.archive.org/web/20160327185412/http://e2e</a>. ti.com/cfs-file/ key/communityserver-discussions-components-, 2004. </p>
<p>[42] S. Seshadri, M. Gahagan, S. Bhaskaran, T. Bunker, A. De, Y. Jin, Y. Liu, and S. Swanson. Willow: A user-programmable ssd. In 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI 14), pages 67–80, 2014. </p>
<p>[43] S. Shadley and N. Adams. What happens when compute meets storage, 2019. </p>
<p>[44] J. Wang, E. Lo, M. L. Yiu, J. Tong, G. Wang, and X. Liu. Cache design of ssd-based search engine architectures: An experimental study. ACM Transactions on Information Systems (TOIS), 32(4):1–26, 2014. </p>
<p>[45] J. Wang, D. Park, Y.-S. Kee, Y. Papakonstantinou, and S. Swanson. Ssd in-storage computing for list intersection. In Proceedings of the 12th International Workshop on Data Management on New Hardware, pages 1–7, 2016. </p>
<p>[46] L. Woods, Z. Istv´an, and G. Alonso. Ibex: An intelligent storage engine with support for advanced sql offloading. Proceedings of the VLDB Endowment, 7(11):963–974, 2014</p>
]]></content>
      <tags>
        <tag>paper</tag>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>Java知识点全面梳理(完善中)</title>
    <url>/2021/08/12/java-all-in-one/</url>
    <content><![CDATA[<img src="/2021/08/12/java-all-in-one/v2-d3a93b1e693540fc3e0c09cf17ceaa12_r.jpg" alt="查看源图像" style="zoom:33%;">

<a id="more"></a>

<h1 id="一-Java基础-集合-多线程-JVM"><a href="#一-Java基础-集合-多线程-JVM" class="headerlink" title="一 Java基础+集合+多线程+JVM"></a>一 Java基础+集合+多线程+JVM</h1><h2 id="1-1-Java基础"><a href="#1-1-Java基础" class="headerlink" title="1.1 Java基础"></a>1.1 Java基础</h2><h3 id="1-1-1-Java基础知识"><a href="#1-1-1-Java基础知识" class="headerlink" title="1.1.1 Java基础知识"></a>1.1.1 Java基础知识</h3><h4 id="（1）Java的特点？"><a href="#（1）Java的特点？" class="headerlink" title="（1）Java的特点？"></a>（1）Java的特点？</h4><ul>
<li>面向对象（封装、继承、多态）</li>
<li>Java和平台无关，一次编译，多地运行</li>
<li>编译和解释并存：Java源码→（javac编译）→.class字节码→（JVM解释）→机器码<ul>
<li>为了加速解释过程，引入运行时编译，即JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</li>
</ul>
</li>
<li>支持网络编程和多线程，能很方便地编写出多线程程序和网络程序。</li>
<li>自动内存管理，无需像C++一样要手动管理内存。</li>
</ul>
<h4 id="（2）-面向过程和面向对象？"><a href="#（2）-面向过程和面向对象？" class="headerlink" title="（2） 面向过程和面向对象？"></a>（2） 面向过程和面向对象？</h4><p><strong>面向过程：</strong>分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展。</p>
<p><strong>面向对象：</strong>把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。<br>缺点：性能比面向过程低。</p>
<h4 id="（3）-JVM、JDK、JRE的区别和联系？"><a href="#（3）-JVM、JDK、JRE的区别和联系？" class="headerlink" title="（3） JVM、JDK、JRE的区别和联系？"></a>（3） JVM、JDK、JRE的区别和联系？</h4><ul>
<li>JVM，Java Virtual Machine：运行Java字节码的虚拟机，在不同平台上有不同的实现（win、linux、macos），是Java语言跨平台的基础。</li>
<li>JRE，Java Runtime Environment：Java运行时环境，是运行已编译Java程序所需要内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他一些基础组件，但是它不能创建新程序。</li>
<li>JDK，Java Development Kit：它是JRE的超集，还包括编译器javac、工具如javadoc、jdb等，能够创建、编译和调试Java程序。</li>
</ul>
<h4 id="（4）-Java和C-的区别和联系"><a href="#（4）-Java和C-的区别和联系" class="headerlink" title="（4） Java和C++的区别和联系"></a>（4） Java和C++的区别和联系</h4><ul>
<li>Java是面向对象的语言，C++既可以面向对象，也可以面向过程。</li>
<li>Java不能操作指针，更加安全，C++可以操作指针，更加灵活。</li>
<li>Java有自动内存管理机制，无需程序员手动释放内存，而C++需要。</li>
<li>Java的类只支持单继承，C++类支持多继承，Java接口可以多继承。</li>
<li>C/C++的字符串以’\0’表示结束，但Java中没有这一概念。原因：Java中一切都是对象，字符串对象本身会记录自己的长度，无需浪费额外的空间存储’\0’。</li>
</ul>
<h4 id="（5）为什么说Java编译和解释并存？"><a href="#（5）为什么说Java编译和解释并存？" class="headerlink" title="（5）为什么说Java编译和解释并存？"></a>（5）为什么说Java编译和解释并存？</h4><p>Java编写的程序首先需要进行编译，生成字节码文件*.class，这种文件必须由Java解释器来解释执行，同时为了加快解释速度，引入运行时编译JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<p>![Java程序运行过程](java-all-in-one/Java 程序运行过程.png)</p>
<h4 id="（6）字符型常量和字符串常量的区别？"><a href="#（6）字符型常量和字符串常量的区别？" class="headerlink" title="（6）字符型常量和字符串常量的区别？"></a>（6）字符型常量和字符串常量的区别？</h4><ul>
<li>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的0个或多个字符。</li>
<li>含义上：字符常量相当于一个整型值，可以参与表达式运算；字符串常量代表字符串在内存中存放的位置。</li>
<li>占内存大小：字符常量占用2字节；字符串常量占用若干字节。</li>
</ul>
<h4 id="（7）重载和重写的区别？"><a href="#（7）重载和重写的区别？" class="headerlink" title="（7）重载和重写的区别？"></a>（7）重载和重写的区别？</h4><ul>
<li><strong>重载：</strong>同样的一个方法能够根据输入数据的不同，做出不同的处理。</li>
<li><strong>重写：</strong>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要对父类方法进行覆盖，这个过程就叫重写。</li>
</ul>
<blockquote>
<p>以下方法无法被重写：</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h4 id="（8）-和-equals-的区别？⭐"><a href="#（8）-和-equals-的区别？⭐" class="headerlink" title="（8）== 和 equals 的区别？⭐"></a>（8）== 和 equals 的区别？⭐</h4><ul>
<li>== ：如果是基本数据类型，==比较的是值是否相同；如果是引用数据类型，==比较的是内存地址是否相等。</li>
<li>equals()：所有对象的父类<code>Object</code>提供的方法，用于判断两个对象是否相等。分为两种情况：如果子类没有重写<code>equals</code>，效果等同于==。如果子类覆盖了equals()方法，通常用来比较两个对象的值是否相同。</li>
<li>String 中的 <code>equals</code> 方法被重写过，判断两个String对象相等的方法：<code>s1.equals(s2) == true或者s1.compareTo(s2) == 0</code></li>
</ul>
<p><img src="/2021/08/12/java-all-in-one/image-20210721162325057.png" alt="image-20210721162325057"></p>
<h4 id="（9）hashCode-与equals-⭐"><a href="#（9）hashCode-与equals-⭐" class="headerlink" title="（9）hashCode()与equals()⭐"></a>（9）hashCode()与equals()⭐</h4><ul>
<li>说一说<code>hashCode()</code>？</li>
</ul>
<p><code>hashCode()</code> 定义在<code>Object</code>类中，Java中的任何类都含有<code>hashCode()</code>方法。它的作用是获取哈希码，即一个int整数，用于确定该对象在哈希表中的索引位置。</p>
<ul>
<li>为什么要有<code>hashCode</code>？</li>
</ul>
<p>加快对象比较的速度，在插入Map时有很大的作用。如果两个对象的hashCode不同，则这两个对象一定不等，如果hashCode相等，可以再比较对象的值，大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<ul>
<li>为什么重写<code>equals</code>时必须要重写<code>hashCode</code>？</li>
</ul>
<p>equals方法内部会调用 <code>hashcode</code> 只是用来缩小查找成本，而<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等。</p>
<ul>
<li>为什么两个对象拥有相同的<code>hashcode</code>它们也不一定想等？</li>
</ul>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
<h4 id="（10）自动装箱和自动拆箱"><a href="#（10）自动装箱和自动拆箱" class="headerlink" title="（10）自动装箱和自动拆箱"></a>（10）自动装箱和自动拆箱</h4><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ul>
<h4 id="（11）常量池"><a href="#（11）常量池" class="headerlink" title="（11）常量池"></a>（11）常量池</h4><p>Java基本类型的包装类大部分（Byte、Short、Integer、Long、Character、Boolean）都实现了常量池，前面4种包装类创建了数值[-128,127]的缓存数据，Character创建了[0,127]范围内的缓存数据，Boolean直接返回True or False，如果超出范围仍然会创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i0 = <span class="number">127</span>;</span><br><span class="line">    Integer i1 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i0 == i1);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer i2 = <span class="number">128</span>;</span><br><span class="line">    Integer i3 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i2 == i3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer i4 = <span class="number">40</span>;</span><br><span class="line">    Integer i5 = <span class="number">10</span>;</span><br><span class="line">    Integer i6 = <span class="number">30</span>;</span><br><span class="line">    System.out.println(i4 == i5 + i6); <span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="number">40</span> == i5 + i6); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 语句 i4 == i5 + i6</span></span><br><span class="line">    <span class="comment">// 因为+这个操作符不适用于 Integer 对象</span></span><br><span class="line">    <span class="comment">// 首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40</span></span><br><span class="line">    <span class="comment">// 然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40</span></span><br><span class="line">    <span class="comment">// 最终这条语句转为 40 == 40 进行数值比较。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（12）深拷贝和浅拷贝"><a href="#（12）深拷贝和浅拷贝" class="headerlink" title="（12）深拷贝和浅拷贝"></a>（12）深拷贝和浅拷贝</h4><ul>
<li><strong>浅拷贝：</strong>对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝</li>
<li><strong>深拷贝：</strong>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</li>
</ul>
<p><img src="/2021/08/12/java-all-in-one/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h4 id="（13）StringBuffer和StringBuilder的区别和联系？"><a href="#（13）StringBuffer和StringBuilder的区别和联系？" class="headerlink" title="（13）StringBuffer和StringBuilder的区别和联系？"></a>（13）<code>StringBuffer</code>和<code>StringBuilder</code>的区别和联系？</h4><p>底层采用char[]保存数据，具有公共父类AbstractStringBuilder</p>
<ul>
<li>StringBuffer：线程安全，效率低</li>
<li>StringBuilder：线程不安全，效率高</li>
</ul>
<h4 id="（14）String为什么是不可变的？"><a href="#（14）String为什么是不可变的？" class="headerlink" title="（14）String为什么是不可变的？"></a>（14）<code>String</code>为什么是不可变的？</h4><p><code>String</code>对象用<code>private final char value[]</code>保存字符串，因此不可变（JDK 9 之后采用<code>private final byte value[]</code>保存）</p>
<p>jdk9之前采用utf-16保存，一个char占用2字节，因此ascii码字符有一个字节填充0，浪费空间；jdk9之后采用编码节省空间，部分字符仅占用1字节。</p>
<h4 id="（15）一个char占用多少字节？"><a href="#（15）一个char占用多少字节？" class="headerlink" title="（15）一个char占用多少字节？"></a>（15）一个char占用多少字节？</h4><p><strong>java中的一个char占用2个字节</strong>。java采用unicode，2个字节来表示一个字符。 一个数字或英文或汉字都是一个字符，只不过数字和英文时，存储的2个字节的第一个字节都为0，就是浪费了点空间。存汉字就占满了2个字节。</p>
<h3 id="1-1-2-面向对象"><a href="#1-1-2-面向对象" class="headerlink" title="1.1.2 面向对象"></a>1.1.2 面向对象</h3><h4 id="（1）面向对象的三大特性：封装、继承、多态"><a href="#（1）面向对象的三大特性：封装、继承、多态" class="headerlink" title="（1）面向对象的三大特性：封装、继承、多态"></a>（1）面向对象的三大特性：封装、继承、多态</h4><ul>
<li>封装：将对象的一些属性或方法隐藏在内部，不允许外部对象直接访问对象信息，但可以给外部提供一些方法来操作属性。</li>
<li>继承：<ul>
<li>子类拥有父类的所有属性和方法，包括私有的，但私有的只是拥有，无法访问。</li>
<li>子类可以拓展父类，拥有自己的属性和方法。</li>
<li>子类可以重写父类方法进行覆盖。</li>
</ul>
</li>
<li>多态：父类指向子类的实例<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ul>
<h4 id="（2）成员变量和局部变量的区别？"><a href="#（2）成员变量和局部变量的区别？" class="headerlink" title="（2）成员变量和局部变量的区别？"></a>（2）成员变量和局部变量的区别？</h4><p>成员变量属于对象，对象存在于堆内存，局部变量则存在于栈内存。特别地，被static修饰的成员变量属于类，位于方法区。</p>
<h4 id="（3）对象相等和它们的引用相等"><a href="#（3）对象相等和它们的引用相等" class="headerlink" title="（3）对象相等和它们的引用相等"></a>（3）对象相等和它们的引用相等</h4><ul>
<li>对象相等：对象保存在内存中的数据相等</li>
<li>引用相等：对象的内存地址相等</li>
</ul>
<h4 id="（4）final关键字"><a href="#（4）final关键字" class="headerlink" title="（4）final关键字"></a>（4）final关键字</h4><p>修饰变量：变量数值在初始化后不能被更改（可以利用反射机制修改）</p>
<p>修饰方法：不能被子类重写覆盖（可以利用动态代理机制修改）</p>
<p>修饰类：类不能被继承，类中所有成员方法会被隐式地指定为final方法</p>
<h4 id="（5）一个空字符串占用多少字节"><a href="#（5）一个空字符串占用多少字节" class="headerlink" title="（5）一个空字符串占用多少字节"></a>（5）一个空字符串占用多少字节</h4><p>空字符串是一个对象，一个对象包含：对象头、实例数据、对齐填充</p>
<p>对象头：8字节（32位系统下）、16字节（64位系统下）、12字节（64位系统下开启指针压缩）</p>
<p>实例数据：（32位系统下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>char[]的引用：4字节</p>
<p>hash：4字节</p>
<p>long的引用：4字节</p>
<p>总共是8+12=20字节，考虑对齐填充需要为8的倍数，总共占用24字节</p>
<p><img src="/2021/08/12/java-all-in-one/webp" alt="img"></p>
<h4 id="（6）String-Pool的底层结构"><a href="#（6）String-Pool的底层结构" class="headerlink" title="（6）String Pool的底层结构"></a>（6）String Pool的底层结构</h4><p>String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。</p>
<h3 id="1-1-3-异常"><a href="#1-1-3-异常" class="headerlink" title="1.1.3 异常"></a>1.1.3 异常</h3><h4 id="（1）异常的分类"><a href="#（1）异常的分类" class="headerlink" title="（1）异常的分类"></a>（1）异常的分类</h4><p>在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。Throwable： 有两个 重要的⼦类：Exception（异常） 和 Error（错误）</p>
<p>Error：程序无法处理，例如虚拟机运行错误，错误发生时JVM一般会选择线程终止</p>
<p>Exception：程序可以处理，使用catch捕获</p>
<h4 id="（2）异常处理"><a href="#（2）异常处理" class="headerlink" title="（2）异常处理"></a>（2）异常处理</h4><p>try：⽤于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟 ⼀个 finally 块</p>
<p>catch：⽤于处理 try 捕获到的异常</p>
<p>finally：⽆论是否捕获或处理异常， finally 块⾥的语句都会被执⾏。当在 try 块或 catch 块中遇到 return 语句时， finally 语句块将在⽅法返回之前被执⾏</p>
<p><strong>不执行finally的情形：</strong></p>
<ul>
<li>使用System.exit()退出程序</li>
<li>程序所在线程死亡</li>
<li>关闭CPU</li>
</ul>
<h3 id="1-1-4-Java-IO"><a href="#1-1-4-Java-IO" class="headerlink" title="1.1.4 Java IO"></a>1.1.4 Java IO</h3><h4 id="（1）IO流分类"><a href="#（1）IO流分类" class="headerlink" title="（1）IO流分类"></a>（1）IO流分类</h4><ul>
<li>按数据单位：字节流（8bit）、字符流（16bit）</li>
<li>按数据流向：输入流、输出流</li>
<li>按流的角色：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td align="center">Wrider</td>
</tr>
</tbody></table>
<h4 id="（2）BIO、NIO、AIO地区别"><a href="#（2）BIO、NIO、AIO地区别" class="headerlink" title="（2）BIO、NIO、AIO地区别"></a>（2）BIO、NIO、AIO地区别</h4><p>BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写⼊必须阻塞在⼀个线程内等待其完 成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐较不错的，可以让每 ⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。线 程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当⾯对⼗万甚 ⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼效的 I/O 处理 模型来应对更⾼的并发量。 </p>
<p>NIO (Non-blocking/New I/O): NIO 是⼀种同步⾮阻塞的 I/O 模型，在 Java 1.4 中引⼊了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可 以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I/O 操作⽅法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模 式。阻塞模式使⽤就像传统中的⽀持⼀样，⽐较简单，但是性能和可靠性都不好；⾮阻塞模式正 好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I/O 来提升开发速率和更好 的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发 </p>
<p>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是 异步⾮阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。AIO 是异 步 IO 的缩写，虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程⾃ ⾏进⾏ IO 操作，IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还 不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</p>
<ul>
<li>BIO (Blocking I/O)，即<strong>同步阻塞I/O</strong>，用户发起I/O请求会会一直阻塞，直到内核把数据拷贝到用户空间，不适合高并发场景。</li>
</ul>
<img src="/2021/08/12/java-all-in-one/bio.png" alt="image-20210531214925715" style="zoom:50%;">



<ul>
<li><p>NIO (Non-blocking/New I/O)，即<strong>同步非阻塞 IO</strong></p>
<ul>
<li>应用程序会一直发起 read 调用，等待数据内核把数据拷贝到用户空间。</li>
<li>优点：相比于BIO，同步非阻塞 IO 通过轮询操作，<strong>避免了一直阻塞</strong>。</li>
</ul>
<ul>
<li>缺点：<strong>轮询过程消耗 CPU 资源</strong>。</li>
</ul>
</li>
</ul>
<img src="/2021/08/12/java-all-in-one/nio.png" alt="image-20210531215133678" style="zoom:50%;">

<ul>
<li>NIO的<strong>I/O 多路复用模型</strong> <ul>
<li>线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。</li>
<li>优点：通过减少无效的系统调用，减少了对 CPU 资源的消耗。</li>
</ul>
</li>
</ul>
<img src="/2021/08/12/java-all-in-one/nio1.png" alt="image-20210531215430672" style="zoom:50%;">

<ul>
<li>AIO (Asynchronous I/O)<ul>
<li>AIO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</li>
</ul>
<img src="/2021/08/12/java-all-in-one/aio.png" alt="img" style="zoom: 67%;">

<ul>
<li>Summary</li>
</ul>
<img src="/2021/08/12/java-all-in-one/iosummary.png" alt="img" style="zoom:50%;">



<h3 id="1-1-5-程序、进程和线程"><a href="#1-1-5-程序、进程和线程" class="headerlink" title="1.1.5 程序、进程和线程"></a>1.1.5 程序、进程和线程</h3><h4 id="（1）程序、进程、线程的定义"><a href="#（1）程序、进程、线程的定义" class="headerlink" title="（1）程序、进程、线程的定义"></a>（1）程序、进程、线程的定义</h4><ul>
<li>程序：含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</li>
<li>进程：正在运行的一个程序。是<strong>资源分配的单位</strong>。</li>
<li>线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。是<strong>调度和执行的单位</strong>。</li>
</ul>
<h3 id="1-1-6-String类和常量池"><a href="#1-1-6-String类和常量池" class="headerlink" title="1.1.6 String类和常量池"></a>1.1.6 String类和常量池</h3><h4 id="（1）String"><a href="#（1）String" class="headerlink" title="（1）String"></a>（1）String</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abcd&quot;</span>;<span class="comment">//如果字符串常量池中没有&quot;abcd&quot;，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;；</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str4 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;cd&quot;</span>).toString();<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str5 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;cd&quot;</span>).toString();<span class="comment">//堆中创建一个新对象</span></span><br><span class="line">        String str6 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;cd&quot;</span>).toString().intern();<span class="comment">//常量池中有&quot;abcd&quot;，因此str6指向它</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str1:&quot;</span> + System.identityHashCode(str1));</span><br><span class="line">        System.out.println(<span class="string">&quot;str2:&quot;</span> + System.identityHashCode(str2));</span><br><span class="line">        System.out.println(<span class="string">&quot;str3:&quot;</span> + System.identityHashCode(str3));</span><br><span class="line">        System.out.println(<span class="string">&quot;str4:&quot;</span> + System.identityHashCode(str4));</span><br><span class="line">        System.out.println(<span class="string">&quot;str5:&quot;</span> + System.identityHashCode(str5));</span><br><span class="line">        System.out.println(<span class="string">&quot;str6:&quot;</span> + System.identityHashCode(str6));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str1:711327356</span></span><br><span class="line"><span class="comment">str2:1297978429</span></span><br><span class="line"><span class="comment">str3:915349526</span></span><br><span class="line"><span class="comment">str4:1280851663</span></span><br><span class="line"><span class="comment">str5:1764696127</span></span><br><span class="line"><span class="comment">str6:711327356</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
</blockquote>
<ul>
<li>intern()方法：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.6及之前的处理方式是<strong>在常量池中创建</strong>与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7及之后的处理方式是<strong>在常量池中记录</strong>此字符串的引用，并返回该引用。</li>
</ul>
<h4 id="（2）String-s-new-String-“xyz”-会创建几个对象"><a href="#（2）String-s-new-String-“xyz”-会创建几个对象" class="headerlink" title="（2）String s=new String(“xyz”)会创建几个对象"></a>（2）String s=new String(“xyz”)会创建几个对象</h4><p>1个或2个。首先去找字符串常量池找，看能不能找到“xyz”字符串对应对象的引用。</p>
<p>如果字符串常量池中找不到：</p>
<ul>
<li>在常量池创建一个String对象和char数组对象，并将String对象放到字符串常量池中</li>
</ul>
<blockquote>
<p>字符串常量池：将创建的String对象封装成HashtableEntry，作为StringTable的value进行存储，本是上是一个HashTable</p>
</blockquote>
<ul>
<li>new String(“xyz”)会在堆区又创建一个String对象，char数组直接指向创建好的char数组对象</li>
</ul>
<p>如果字符串常量池中能找到：</p>
<p>new String(“xyz”)会在堆区创建一个对象，char数组直接指向已经存在的char数组对象</p>
<p><strong>同时在栈区还会有一个对new出来的String实例的引用s。</strong></p>
<p>String s1 = new String(“xyz”); </p>
<p>String s2 = “xyz”;</p>
<img src="/2021/08/12/java-all-in-one/e0469fdcb72a4633b5d10ee7bf3776d0~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210123155156910" style="zoom: 50%;">



<h2 id="1-2-集合"><a href="#1-2-集合" class="headerlink" title="1.2 集合"></a>1.2 集合</h2><h3 id="1-2-1-常见容器的比较"><a href="#1-2-1-常见容器的比较" class="headerlink" title="1.2.1 常见容器的比较"></a>1.2.1 常见容器的比较</h3><h4 id="（1）List、Set、Map的比较"><a href="#（1）List、Set、Map的比较" class="headerlink" title="（1）List、Set、Map的比较"></a>（1）List、Set、Map的比较</h4><ul>
<li><code>List</code>：保存的元素是可重复、有序的。</li>
<li><code>Set</code>：保存的元素是不可重复、无序的。</li>
<li><code>Map</code>：使用Key-Value存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h4 id="（2）ArrayList和Vector的区别"><a href="#（2）ArrayList和Vector的区别" class="headerlink" title="（2）ArrayList和Vector的区别"></a>（2）ArrayList和Vector的区别</h4><ul>
<li><code>ArrayList</code>是<code>List</code>的主要实现类，底层采用<code>Object[]</code>存储，线程不安全，效率高。</li>
<li><code>Vector</code>是<code>List</code>的古老实现类，底层采用<code>Object[]</code>存储，线程安全，效率低。</li>
</ul>
<h4 id="（3）ArrayList和LinkedList区别"><a href="#（3）ArrayList和LinkedList区别" class="headerlink" title="（3）ArrayList和LinkedList区别"></a>（3）ArrayList和LinkedList区别</h4><ul>
<li>线程安全性：都是线程不安全的.</li>
<li>底层数据结构：<code>ArrayList</code>底层采用**<code>Object[]</code><strong>，<code>LinkedList</code>底层采用</strong>双向链表**.</li>
<li>插入或删除元素<ul>
<li><code>ArrayList</code>采用数组存储，在非尾部插入元素会产生数据移动，时间复杂度<code>O(n)</code>。</li>
<li><code>LinkedList</code>采用链表存储，插入元素时不会产生数据移动，时间复杂度<code>O(n)</code>。</li>
</ul>
</li>
<li>快速随机访问<ul>
<li><code>ArrayList</code>支持，<code>LinkedList</code>不支持。</li>
</ul>
</li>
<li>内存空间占用<ul>
<li><code>ArrayList</code>会预留一定的空间保存新的元素，<code>LinkedList</code>的每一个元素需要更多的空间保存（前继和后继）</li>
</ul>
</li>
</ul>
<h4 id="（4）HashMap和HashTable的区别"><a href="#（4）HashMap和HashTable的区别" class="headerlink" title="（4）HashMap和HashTable的区别"></a>（4）HashMap和HashTable的区别</h4><ul>
<li>线程安全性：<code>HashMap</code>线程不安全，<code>HashTable</code>线程安全（因为其内部的方法都通过<code>synchronized</code>修饰）。</li>
<li>效率：<code>HashMap</code>效率高，<code>HashTable</code>因锁的原因效率低。</li>
<li>对<code>null</code>的支持：<code>HashMap</code>可以存储值为<code>null</code>的<code>key</code>和<code>value</code>，<code>HashTable</code>不允许。</li>
<li>初始容量大小和扩容机制：<code>HashTable</code>默认大小为11，扩容为2n+1；<code>HashMap</code>初始大小为16，扩容为2n。</li>
<li>底层数据结构：数据+链表；JDK1.8之后，<code>HashMap</code>发生了变化：当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ul>
<h4 id="（5）HashSet、LinkedHashSet、TreeSet的异同"><a href="#（5）HashSet、LinkedHashSet、TreeSet的异同" class="headerlink" title="（5）HashSet、LinkedHashSet、TreeSet的异同"></a>（5）HashSet、LinkedHashSet、TreeSet的异同</h4><p>HashSet是Set的主要实现类，HashSet的底层是HashMap，线程不安全，可存储null值</p>
<p>LinkedHashSet是HashSet的子类，能够按照元素添加的顺序遍历</p>
<p>TreeSet底层使用红黑树，能够按照添加元素的顺序遍历，排序的方式有自然排序和定制排序</p>
<h4 id="（6）无序性和不可重复性的含义是什么？"><a href="#（6）无序性和不可重复性的含义是什么？" class="headerlink" title="（6）无序性和不可重复性的含义是什么？"></a>（6）无序性和不可重复性的含义是什么？</h4><ul>
<li>无序性：存储对象在底层数据结构中的位置不是由对象插入的顺序决定的，而是根据对象的哈希值决定的。</li>
<li>不可重复性：不重复的对象指使用<code>equals()</code>比较时返回<code>false</code>。</li>
</ul>
<h4 id="（7）Comparable和Comparator的区别"><a href="#（7）Comparable和Comparator的区别" class="headerlink" title="（7）Comparable和Comparator的区别"></a>（7）Comparable和Comparator的区别</h4><ul>
<li><code>Comparable</code>接口位于<code>java.lang</code>包，它有一个<code>compareTo(Object obj)</code>方法来排序，是一个内比较器。</li>
<li><code>Comparator</code>接口位于<code>java.util</code>包，它有一个<code>compare(Object obj1, Object obj2)</code>方法来排序，是一个外比较器。</li>
<li>集合自定义排序：重写<code>compareTo()</code>方法或<code>compare()</code>方法。</li>
</ul>
<h3 id="1-2-2-容器结构的底层实现"><a href="#1-2-2-容器结构的底层实现" class="headerlink" title="1.2.2 容器结构的底层实现"></a>1.2.2 容器结构的底层实现</h3><h4 id="（1）-List、Set、Map"><a href="#（1）-List、Set、Map" class="headerlink" title="（1） List、Set、Map"></a>（1） List、Set、Map</h4><ul>
<li><p><code>List</code></p>
<ul>
<li><code>ArrayList</code>：**Object[]**，<code>List</code>的常见实现类，线程不安全。</li>
<li><code>Vector</code>：**Object[]**，<code>List</code>的古老实现类，线程安全。</li>
<li><code>LinkedList</code>：<strong>双向链表</strong>，JDK7之前采用双向循环链表</li>
</ul>
</li>
<li><p><code>Set</code></p>
<ul>
<li><code>HashSet</code>：基于<code>HashMap</code>实现。</li>
<li><code>LinkedHashSet</code>：基于<code>LinkedHashMap</code>实现。</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 及以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成<strong>红黑树</strong>前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。是Map的常见实现类，线程</li>
<li><code>HashTable</code>：<strong>数组+链表</strong>，<code>Map</code>的古老实现类，线程安全。</li>
<li><code>LinkedHashMap</code>：在<code>HashMap</code>的基础上增加了一个<strong>双向链表</strong>，用来记录键值对的插入顺序，通过链表实现了访问顺序的相关逻辑</li>
<li><code>TreeMap</code>：<strong>红黑树</strong>。</li>
</ul>
</li>
</ul>
<h4 id="（2）ArrayList的扩容机制"><a href="#（2）ArrayList的扩容机制" class="headerlink" title="（2）ArrayList的扩容机制"></a>（2）ArrayList的扩容机制</h4><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90</a></p>
<h4 id="（3）HashMap的底层实现"><a href="#（3）HashMap的底层实现" class="headerlink" title="（3）HashMap的底层实现"></a>（3）HashMap的底层实现</h4><ul>
<li>JDK1.8之前： <strong>数组和链表</strong> 结合在一起，即 <strong>链表散列</strong>，使用拉链法解决哈希冲突。</li>
</ul>
<img src="/2021/08/12/java-all-in-one/jdk1.8之前的内部结构-HashMap.png" alt="jdk1.8之前的内部结构-HashMap" style="zoom: 33%;">

<ul>
<li>JDK1.8及之后：当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
<img src="/2021/08/12/java-all-in-one/jdk1.8之后的内部结构-HashMap.png" alt="jdk1.8之后的内部结构-HashMap" style="zoom: 25%;">



<h4 id="（4）HashSet如何检查重复"><a href="#（4）HashSet如何检查重复" class="headerlink" title="（4）HashSet如何检查重复"></a>（4）HashSet如何检查重复</h4><p>会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h4 id="（5）HashMap-的⻓度为什么是2的幂次⽅"><a href="#（5）HashMap-的⻓度为什么是2的幂次⽅" class="headerlink" title="（5）HashMap 的⻓度为什么是2的幂次⽅"></a>（5）HashMap 的⻓度为什么是2的幂次⽅</h4><p>为了能让 HashMap 存取⾼效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上⾯也讲到了过 了，Hash 值的范围值-2147483648到2147483647，前后加起来⼤概40亿的映射空间，只要哈希函数映射 得⽐较均匀松散，⼀般应⽤是很难出现碰撞的。但问题是⼀个40亿⻓度的数组，内存是放不下的。所以 这个散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放 的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) &amp; hash ”。（n代表数组⻓ 度）。这也就解释了 HashMap 的⻓度为什么是2的幂次⽅。<br>这个算法应该如何设计呢？<br>我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则 等价于与其除数减⼀的与(&amp;)操作（也就是说 hash%lengthdehash&amp;(length-1)的前提是 length 是2的 n 次⽅；）。” 并且 采⽤⼆进制位操作 &amp;，相对于%能够提⾼运算效率，这就解释了 HashMap 的⻓度 为什么是2的幂次⽅。</p>
<h3 id="1-2-3-ConcurrentHashmap"><a href="#1-2-3-ConcurrentHashmap" class="headerlink" title="1.2.3 ConcurrentHashmap"></a>1.2.3 ConcurrentHashmap</h3><h4 id="（1）ConcurrentHashMap-和-Hashtable-的区别"><a href="#（1）ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="（1）ConcurrentHashMap 和 Hashtable 的区别"></a>（1）ConcurrentHashMap 和 Hashtable 的区别</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<ul>
<li>HashTable</li>
</ul>
<img src="/2021/08/12/java-all-in-one/HashTable全表锁.png" alt="HashTable全表锁" style="zoom: 50%;">

<ul>
<li>ConcurrentHashMap（JDK1.7）：<strong>Segment 数组 + HashEntry 数组 + 链表</strong></li>
</ul>
<img src="/2021/08/12/java-all-in-one/ConcurrentHashMap分段锁.jpg" alt="JDK1.7的ConcurrentHashMap" style="zoom:50%;">

<ul>
<li>ConcurrentHashMap（JDK1.8）：<strong>Node 数组 + 链表 / 红黑树</strong>，冲突链表达到一定长度时，链表会转换成红黑树。</li>
</ul>
<img src="/2021/08/12/java-all-in-one/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）" style="zoom:50%;">

<h4 id="（2）ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#（2）ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="（2）ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>（2）ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h4><p><strong>JDK1.7（上面有示意图）</strong></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</span></span><br><span class="line"><span class="comment">//Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p>
<p><strong>JDK1.8 （上面有示意图）</strong></p>
<p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h4 id="（3）ConcurrentHashMap读写过程（JDK1-7）"><a href="#（3）ConcurrentHashMap读写过程（JDK1-7）" class="headerlink" title="（3）ConcurrentHashMap读写过程（JDK1.7）"></a>（3）ConcurrentHashMap读写过程（JDK1.7）</h4><p><strong>Get方法：</strong></p>
<p>1.为输入的Key做Hash运算，得到hash值。</p>
<p>2.通过hash值，定位到对应的Segment对象。</p>
<p>3.再次通过hash值，定位到Segment当中数组的具体位置。</p>
<p><strong>Put方法：</strong></p>
<p>1.为输入的Key做Hash运算，得到hash值。</p>
<p>2.通过hash值，定位到对应的Segment对象。</p>
<p>3.获取可重入锁。</p>
<p>4.再次通过hash值，定位到Segment当中数组的具体位置。</p>
<p>5.插入或覆盖HashEntry对象。</p>
<p>6.释放锁。</p>
<p><strong>size方法：</strong></p>
<p>1.遍历所有的Segment。</p>
<p>2.把Segment的元素数量累加起来。</p>
<p>3.把Segment的修改次数累加起来。</p>
<p>4.判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</p>
<p>5.如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。</p>
<p>6.再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经全部加锁，统计过程中肯定没有修改，统计的一定是正确的结果。</p>
<p>7.释放锁，统计结束。</p>
<h2 id="1-3-多线程"><a href="#1-3-多线程" class="headerlink" title="1.3 多线程"></a>1.3 多线程</h2><h3 id="1-3-1-基本概念"><a href="#1-3-1-基本概念" class="headerlink" title="1.3.1 基本概念"></a>1.3.1 基本概念</h3><h4 id="（1）什么是进程"><a href="#（1）什么是进程" class="headerlink" title="（1）什么是进程"></a>（1）什么是进程</h4><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位。</p>
<h4 id="（2）什么是线程"><a href="#（2）什么是线程" class="headerlink" title="（2）什么是线程"></a>（2）什么是线程</h4><p>线程是程序的一条执行路径，是现代操作系统调度的基本单位。</p>
<p>在Java中，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<p><img src="/2021/08/12/java-all-in-one/82539cb6fc7b45bd94c4a6e3ad858bf2-1626858434356.png" alt="img"></p>
<h4 id="（3）什么是协程"><a href="#（3）什么是协程" class="headerlink" title="（3）什么是协程"></a>（3）什么是协程</h4><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<img src="/2021/08/12/java-all-in-one/6765e36cc4604fba897976638af03524.jpeg" alt="img" style="zoom: 67%;">



<h4 id="（4）进程和线程的关系"><a href="#（4）进程和线程的关系" class="headerlink" title="（4）进程和线程的关系"></a>（4）进程和线程的关系</h4><p>进程是系统运行程序和<strong>资源分配</strong>的基本单位，线程是<strong>系统调度</strong>的基本单位。</p>
<ul>
<li><p>进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动</p>
</li>
<li><p>区别：</p>
<ul>
<li>程序是指令的有序集合，是一个静态概念</li>
<li>进程是一个能独立运行的单位，能与其他进程并行地活动</li>
<li>线程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。</li>
</ul>
</li>
</ul>
<img src="/2021/08/12/java-all-in-one/image-20210721170532276.png" alt="image-20210721170532276" style="zoom: 50%;">

<h4 id="（5）线程的上下文切换"><a href="#（5）线程的上下文切换" class="headerlink" title="（5）线程的上下文切换"></a>（5）线程的上下文切换</h4><p>当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次 再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换</p>
<h4 id="（6）并发和并行的区别"><a href="#（6）并发和并行的区别" class="headerlink" title="（6）并发和并行的区别"></a>（6）并发和并行的区别</h4><p>并发：同一时间段内，多个任务都执行了（例如时间片法）</p>
<p>并行：同一时刻，执行多个任务（例如多核）</p>
<h4 id="（7）为什么使用多线程？"><a href="#（7）为什么使用多线程？" class="headerlink" title="（7）为什么使用多线程？"></a>（7）为什么使用多线程？</h4><p>从计算机底层来说： 计算机有多任务调度的需求，最早是基于进程实现的多任务调度，但是进程切换成本较高，由此诞生了更加轻量的线程，满足多任务调度需求。</p>
<p>从互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
<h4 id="（8）使用多线程带来的问题"><a href="#（8）使用多线程带来的问题" class="headerlink" title="（8）使用多线程带来的问题"></a>（8）使用多线程带来的问题</h4><p>内存泄漏</p>
<p>一致性问题（线程同步）</p>
<p>死锁</p>
<h4 id="（9）-内核线程实现"><a href="#（9）-内核线程实现" class="headerlink" title="（9） 内核线程实现"></a>（9） 内核线程实现</h4><p>使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核 （Multi-Threads Kernel）。</p>
<p>内核线程（Kernel-Level Thread，KLT）</p>
<p>轻量级进程（Light Weight Process，LWP）</p>
<p>一个进程（P）拥有多个线程（LWP），每一个LWP被映射为KLT，由线程调度器调度到物理CPU上执行。</p>
<img src="/2021/08/12/java-all-in-one/image-20210720195629494.png" alt="image-20210720195629494" style="zoom:67%;">

<h4 id="（10）-用户线程实现"><a href="#（10）-用户线程实现" class="headerlink" title="（10） 用户线程实现"></a>（10） 用户线程实现</h4><p>即协程</p>
<h4 id="（11）上下文切换"><a href="#（11）上下文切换" class="headerlink" title="（11）上下文切换"></a>（11）上下文切换</h4><p>当线程发生中断，或者用完当前时间片，就会触发上下文切换，操作系统会将CPU的使用权分配给其他线程。</p>
<p>保护现场、恢复现场。</p>
<h3 id="1-3-2-Java的多线程"><a href="#1-3-2-Java的多线程" class="headerlink" title="1.3.2 Java的多线程"></a>1.3.2 Java的多线程</h3><h4 id="（1）程序计数器为什么是私有的？"><a href="#（1）程序计数器为什么是私有的？" class="headerlink" title="（1）程序计数器为什么是私有的？"></a>（1）程序计数器为什么是私有的？</h4><p>每个线程拥有不同的执行路径，因此需要程序计数器来记录当前执行到的位置，保证线程切换后能恢复到正确的执行位置。</p>
<h4 id="（2）虚拟机栈和本地方法栈为什么是私有的？"><a href="#（2）虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="（2）虚拟机栈和本地方法栈为什么是私有的？"></a>（2）虚拟机栈和本地方法栈为什么是私有的？</h4><p>每个线程的方法拥有自己独立的栈帧，以保证线程中的局部变量不被别的线程访问到。</p>
<h4 id="（3）堆和方法区"><a href="#（3）堆和方法区" class="headerlink" title="（3）堆和方法区"></a>（3）堆和方法区</h4><p>堆和方法区为进程所有，由线程共享。</p>
<p>堆主要用于存放新创建的对象；方法区主要用去存放编译后的代码等信息（例如已被加载的类信息、常量、静态变量）</p>
<h4 id="（4）线程的生命周期和状态"><a href="#（4）线程的生命周期和状态" class="headerlink" title="（4）线程的生命周期和状态"></a>（4）线程的生命周期和状态</h4><p><img src="/2021/08/12/java-all-in-one/lifecycle.png"></p>
<h4 id="（5）sleep-和-wait"><a href="#（5）sleep-和-wait" class="headerlink" title="（5）sleep() 和 wait()"></a>（5）sleep() 和 wait()</h4><ul>
<li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li>
<li>两者都可以暂停线程的执行。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h4 id="（6）start-和-run"><a href="#（6）start-和-run" class="headerlink" title="（6）start() 和 run()"></a>（6）start() 和 run()</h4><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="1-3-3-synchronized"><a href="#1-3-3-synchronized" class="headerlink" title="1.3.3 synchronized"></a>1.3.3 synchronized</h3><h4 id="（1）synchronized关键字"><a href="#（1）synchronized关键字" class="headerlink" title="（1）synchronized关键字"></a>（1）synchronized关键字</h4><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰 的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依 赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如 果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户 态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期 的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized 较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销</p>
<h4 id="（2）synchronized的三种使用方式"><a href="#（2）synchronized的三种使用方式" class="headerlink" title="（2）synchronized的三种使用方式"></a>（2）synchronized的三种使用方式</h4><p>修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁 </p>
<p>修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀ 个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有 ⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤ 这个实例对象所属类的静态synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前 实例对象锁。</p>
<p>修饰代码块: 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p>
<p>总结： synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤ synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
<h4 id="（3）synchronized底层原理"><a href="#（3）synchronized底层原理" class="headerlink" title="（3）synchronized底层原理"></a>（3）synchronized底层原理</h4><h4 id="（4）JDK1-6之后对synchronized做的优化"><a href="#（4）JDK1-6之后对synchronized做的优化" class="headerlink" title="（4）JDK1.6之后对synchronized做的优化"></a>（4）JDK1.6之后对synchronized做的优化</h4><p>JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗 化等技术来减少锁操作的开销。<br>锁主要存在四种状态，依次是：⽆锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞 争的激烈⽽逐渐升级。注意锁可以升级不可降级，这种策略是为了提⾼获得锁和释放锁的效率。</p>
<h4 id="（5）synchronized和ReentrantLock的区别"><a href="#（5）synchronized和ReentrantLock的区别" class="headerlink" title="（5）synchronized和ReentrantLock的区别"></a>（5）synchronized和ReentrantLock的区别</h4><p>① 两者都是可重⼊锁<br>两者都是可重⼊锁。“可重⼊锁”概念是：⾃⼰可以再次获取⾃⼰的内部锁。⽐如⼀个线程获得了某个对 象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不 可锁重⼊的话，就会造成死锁。同⼀个线程每次获取锁，锁的计数器都⾃增1，所以要等到锁的计数器 下降为0时才能释放锁。</p>
<p>② synchronized 依赖于 JVM ⽽ ReentrantLock 依赖于 API<br>synchronized 是依赖于 JVM 实现的，前⾯我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关 键字进⾏了很多优化，但是这些优化都是在虚拟机层⾯实现的，并没有直接暴露给我们。 ReentrantLock 是 JDK 层⾯实现的（也就是 API 层⾯，需要 lock() 和 unlock() ⽅法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p>③ ReentrantLock ⽐ synchronized 增加了⼀些⾼级功能</p>
<p>相⽐synchronized，ReentrantLock增加了⼀些⾼级功能。主要来说主要有三点：①等待可中断；②可 实现公平锁；③可实现选择性通知（锁可以绑定多个条件） </p>
<p>ReentrantLock提供了⼀种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 </p>
<p>ReentrantLock可以指定是公平锁还是⾮公平锁。⽽synchronized只能是⾮公平锁。所谓的公平 锁就是先等待的线程先获得锁。 ReentrantLock默认情况是⾮公平的，可以通过 ReentrantLock 类的ReentrantLock(boolean fair)构造⽅法来制定是否是公平的。 </p>
<p>synchronized关键字与wait()和notify()/notifyAll()⽅法相结合可以实现等待/通知机制， ReentrantLock类当然也可以实现，但是需要借助于Condition接⼝与newCondition() ⽅法。 Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀ 个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的 Condition中，从⽽可以有选择性的进⾏线程通知，在调度线程上更加灵活。 在使⽤ notify()/notifyAll()⽅法进⾏通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结 合Condition实例可以实现“选择性通知” ，这个功能⾮常重要，⽽且是Condition接⼝默认提供 的。⽽synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注 册在它⼀个身上。如果执⾏notifyAll()⽅法的话就会通知所有处于等待状态的线程这样会造成 很⼤的效率问题，⽽Condition实例的signalAll()⽅法 只会唤醒注册在该Condition实例中的所 有等待线程。</p>
<h4 id="（6）volatile关键字和Java内存模型"><a href="#（6）volatile关键字和Java内存模型" class="headerlink" title="（6）volatile关键字和Java内存模型"></a>（6）volatile关键字和Java内存模型</h4><p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意 的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直 接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使 ⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致。<br>要解决这个问题，就需要把变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的， 每次使⽤它都到主存中进⾏读取。 所以， volatile 关键字 除了防⽌ JVM 的指令重排，还有⼀个重要的作⽤就是保证变量的可见性</p>
<p><img src="/2021/08/12/java-all-in-one/image-20210726153735728.png" alt="image-20210726153735728"></p>
<p><img src="/2021/08/12/java-all-in-one/image-20210726153749258.png" alt="image-20210726153749258"></p>
<h4 id="（7）并发编程的三个重要特性"><a href="#（7）并发编程的三个重要特性" class="headerlink" title="（7）并发编程的三个重要特性"></a>（7）并发编程的三个重要特性</h4><p>原⼦性 : ⼀个的操作或者多次操作，要么所有的操作全部都得到执⾏并且不会收到任何因素的 ⼲扰⽽中断，要么所有的操作都执⾏，要么都不执⾏。synchronized 可以保证代码⽚段的原 ⼦性。</p>
<p>可⻅性 ：当⼀个变量对共享变量进⾏了修改，那么另外的线程都是⽴即可以看到修改后的最新 值。volatile 关键字可以保证共享变量的可⻅性。</p>
<p>有序性 ：代码在执⾏的过程中的先后顺序，Java 在编译器以及运⾏期间的优化，代码的执⾏顺 序未必就是编写代码时候的顺序。volatile 关键字可以禁⽌指令进⾏重排序优化。</p>
<h4 id="（8）说说-synchronized-关键字和-volatile-关键字的区别"><a href="#（8）说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="（8）说说 synchronized 关键字和 volatile 关键字的区别"></a>（8）说说 synchronized 关键字和 volatile 关键字的区别</h4><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。 但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。 </p>
<p>volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。synchronized关键字两者都能保证。</p>
<p>volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是 多个线程之间访问资源的同步性。</p>
<h3 id="1-3-4-ThreadLocal"><a href="#1-3-4-ThreadLocal" class="headerlink" title="1.3.4 ThreadLocal"></a>1.3.4 ThreadLocal</h3><h3 id="1-3-5-线程池"><a href="#1-3-5-线程池" class="headerlink" title="1.3.5 线程池"></a>1.3.5 线程池</h3><h4 id="（1）为什么要使用线程池？"><a href="#（1）为什么要使用线程池？" class="headerlink" title="（1）为什么要使用线程池？"></a>（1）为什么要使用线程池？</h4><p>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</p>
<p>提高响应速度：当任务到达时，不需要等待线程创建完毕就能立即执行</p>
<p>提高线程的可管理性：利用线程池可以进行线程的统一分配、调优和监控</p>
<h2 id="1-4-JVM"><a href="#1-4-JVM" class="headerlink" title="1.4 JVM"></a>1.4 JVM</h2><h3 id="1-4-1-Java内存管理"><a href="#1-4-1-Java内存管理" class="headerlink" title="1.4.1 Java内存管理"></a>1.4.1 Java内存管理</h3><h4 id="（1）Java内存区域"><a href="#（1）Java内存区域" class="headerlink" title="（1）Java内存区域"></a>（1）Java内存区域</h4><p>JDK1.7及之前：</p>
<p><img src="/2021/08/12/java-all-in-one/image-20210721174244306.png" alt="image-20210721174244306"></p>
<p>JDK1.8：</p>
<p><img src="/2021/08/12/java-all-in-one/image-20210721174238079.png" alt="image-20210721174238079"></p>
<p>线程私有的：</p>
<ul>
<li>程序计数器：一块较小的内存空间，用于记录当前线程所执行的字节码的行号指示器。</li>
<li>虚拟机栈：Java虚拟机栈是线程私有的，生命周期与线程相同。每一个方法被执行时，Java虚拟机都会创建一个<strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>本地方法栈：为虚拟机使用到的本地方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>线程共享的：</p>
<ul>
<li>堆：Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，<strong>唯一</strong>目的是用于存放对象实例。Java堆同时是垃圾收集器管理的内存区域，因此又称“GC堆”（Garbage Collected Heap）。</li>
<li>方法区：存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li>
<li>直接内存：基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。</li>
</ul>
<h4 id="（2）为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#（2）为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="（2）为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?"></a>（2）为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?</h4><p>整个永久代有⼀个 JVM 本身设置固定⼤⼩上限，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机可⽤内存的限制，虽然元空间仍旧可能溢出，但是⽐原来出现的⼏率会更⼩</p>
<p>元空间⾥⾯存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, ⽽由系统的实际可⽤空间来控制，这样能加载的类就更多了。 </p>
<p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有⼀个叫永久代的东⻄, 合并之后就没有必要额外的设置这么⼀个永久代的地⽅了</p>
<h4 id="（3）Java对象的创建过程"><a href="#（3）Java对象的创建过程" class="headerlink" title="（3）Java对象的创建过程"></a>（3）Java对象的创建过程</h4><ul>
<li><strong>对象的创建</strong></li>
</ul>
<p>（1）<strong>类加载检查：</strong>当Java虚拟机遇到一条字节码new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，需要先执行相应的类加载过程</p>
<p>（2）<strong>分配内存：</strong>类加载检查通过后，虚拟机将为新生对象分配内存，分配方式有“指针碰撞“和”空闲列表“两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整由垃圾收集器是否带有压缩整理功能决定。</p>
<blockquote>
<p> <strong>内存分配的方法：</strong>①指针碰撞：空闲空间和使用空间位于分界线两侧，把指向空闲空间的指针向下移动一个对象的大小 ②：空闲列表：由虚拟机维护一张列表，用于记录哪些内存块可用，在分配的时候从列表中找到一块足够大的空间分配给对象实例。</p>
</blockquote>
<blockquote>
<p><strong>内存分配时的并发问题：</strong>①对分配动作进行同步处理（加锁） ②本地线程分配缓冲：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，当本地缓冲用完时，分配新的缓冲区才需要同步锁定，减少了同步的开销。</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 和失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
</blockquote>
<p>（3）<strong>初始化零值：</strong>内存分配完毕后，虚拟机会将内存区域置零。</p>
<p>（4）<strong>设置对象头：</strong>接下来，虚拟机会对对象进行设置，包括标识对象属于哪个类、类的元数据信息的位置、对象的GC分代年龄、哈希码，这些信息会被记录到对象头中。</p>
<p>（5）<strong>执行init方法：</strong>new指令执行完毕后会接着执行<init>()方法，对对象进行初始化。</init></p>
<h4 id="（4）对象位置的定位"><a href="#（4）对象位置的定位" class="headerlink" title="（4）对象位置的定位"></a>（4）对象位置的定位</h4><p><strong>通过句柄访问对象</strong></p>
<p>优点：reference中存储的是句柄地址，在对象被移动时（例如整理内存碎片）无需改变reference本身</p>
<p>缺点：存在两次寻址开销</p>
<img src="/2021/08/12/java-all-in-one/obj-handler-ref.png" alt="image-20210416203400581" style="zoom: 67%;">

<p><strong>通过直接指针访问对象</strong></p>
<p>优点：reference中存储的是对象地址，访问速度快，节省了一次寻址开销（HotSpot采用的方式）</p>
<img src="/2021/08/12/java-all-in-one/obj-pointer-ref.png" alt="image-20210416203836898" style="zoom:67%;">

<h4 id="（5）堆内存中对象分配的基本策略"><a href="#（5）堆内存中对象分配的基本策略" class="headerlink" title="（5）堆内存中对象分配的基本策略"></a>（5）堆内存中对象分配的基本策略</h4><p>堆的基本结构：</p>
<p><img src="/2021/08/12/java-all-in-one/image-20210722175723036.png" alt="image-20210722175723036"></p>
<p>上图所示的 eden区、s0区、s1区都属于新⽣代，tentired 区属于⽼年代。⼤部分情况，对象都会⾸先 在 Eden 区域分配，在⼀次新⽣代垃圾回收后，如果对象还存活，则会进⼊ s0 或者 s1，并且对象的 年龄还会加 1(Eden区i&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到⼀定程度（默认为15 岁），就会被晋升到⽼年代中。</p>
<p>堆常见分配策略：</p>
<ul>
<li>对象优先在eden区分配</li>
<li>大对象直接进入老年代（通过-XX:MaxTenuringThreshold设置）</li>
<li>长期存活对象进入老年代</li>
</ul>
<h3 id="1-4-2-Java对象内存空间占用"><a href="#1-4-2-Java对象内存空间占用" class="headerlink" title="1.4.2 Java对象内存空间占用"></a>1.4.2 Java对象内存空间占用</h3><p>java对象在内存中占用的空间分为3类：</p>
<ol>
<li>对象头（Header）；</li>
<li>实例数据（Instance Data）;</li>
<li>对齐填充（Padding）。</li>
</ol>
<p>我们常说的基础数据类型大小，如byte占1字节、int占4字节、long占8字节等，主要是指第二类实例数据。下图是Java对象内存占用的示意图。</p>
<p><img src="/2021/08/12/java-all-in-one/webp" alt="img"></p>
<h4 id="（1）对象头"><a href="#（1）对象头" class="headerlink" title="（1）对象头"></a>（1）对象头</h4><p>HotSpot虚拟机的对象头包括两部分信息：markword和klass 。</p>
<p><strong>对象头组成介绍</strong></p>
<p>第一部分markword，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br> 另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br> 如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度，也就是一个int类型的对象，占4字节。</p>
<p><strong>对象头占用空间</strong></p>
<p>在32位系统下，存放Class指针的空间大小是4字节，MarkWord是4字节，对象头为8字节。<br> 在64位系统下，存放Class指针的空间大小是8字节，MarkWord是8字节，对象头为16字节。<br> 在64位开启指针压缩的情况下（默认开启）<code>-XX:+UseCompressedOops</code>，存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节。<br> 如果对象是数组，那么额外增加4个字节，这块儿用来记录数组的长度。</p>
<h4 id="（2）实例数据"><a href="#（2）实例数据" class="headerlink" title="（2）实例数据"></a>（2）实例数据</h4><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。<br> 这部分空间的占用，就等于对象各个成员变量的空间占用加和。</p>
<h4 id="（3）对齐填充"><a href="#（3）对齐填充" class="headerlink" title="（3）对齐填充"></a>（3）对齐填充</h4><p>对齐填充空间并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。这是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。<br> 很多其它编程语言在内存管理时，也有对齐填充的概念。</p>
<h3 id="1-4-2-Java垃圾回收"><a href="#1-4-2-Java垃圾回收" class="headerlink" title="1.4.2 Java垃圾回收"></a>1.4.2 Java垃圾回收</h3><h4 id="（1）Minor-Gc和Full-Gc有什么不同？"><a href="#（1）Minor-Gc和Full-Gc有什么不同？" class="headerlink" title="（1）Minor Gc和Full Gc有什么不同？"></a>（1）Minor Gc和Full Gc有什么不同？</h4><p>⼤多数情况下，对象在新⽣代中 eden 区分配。当 eden 区没有⾜够空间进⾏分配时，虚拟机将发起⼀ 次Minor GC。</p>
<ul>
<li>新⽣代GC（Minor GC）:指发⽣新⽣代的的垃圾收集动作，Minor GC⾮常频繁，回收速度⼀般也 ⽐较快。 </li>
<li>⽼年代GC（Major GC/Full GC）:指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的 Minor GC（并⾮绝对），Major GC的速度⼀般会⽐Minor GC的慢10倍以上。</li>
</ul>
<p>进行GC的分类：</p>
<ul>
<li>部分收集 (Partial GC)：<ul>
<li>新⽣代收集（Minor GC / Young GC）：只对新⽣代进⾏垃圾收集； </li>
<li>⽼年代收集（Major GC / Old GC）：只对⽼年代进⾏垃圾收集。需要注意的是 Major GC 在有的语境中也⽤于指代整堆收集； </li>
<li>混合收集（Mixed GC）：对整个新⽣代和部分⽼年代进⾏垃圾收集。</li>
</ul>
</li>
<li>整堆收集 (Full GC)：收集整个 Java 堆和⽅法区。</li>
</ul>
<h4 id="（2）判断对象是否死亡"><a href="#（2）判断对象是否死亡" class="headerlink" title="（2）判断对象是否死亡"></a>（2）判断对象是否死亡</h4><p><strong>引用计数法：</strong></p>
<p>给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。</p>
<p>适合大多数场景，但是存在例外情况（例如循环引用），需要大量的额外处理才能解决内存泄漏。</p>
<p><strong>可达性分析法：</strong></p>
<p>这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索， 节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不 可⽤的。</p>
<h4 id="（3）强引用、软引用、弱引用、虚引用"><a href="#（3）强引用、软引用、弱引用、虚引用" class="headerlink" title="（3）强引用、软引用、弱引用、虚引用"></a>（3）强引用、软引用、弱引用、虚引用</h4><ul>
<li>强引用：形如 <code>Object obj = new Object()</code> 及 <code>obj1.friends = obj2</code> 的形式，垃圾收集器永远不会回收存在强引用的对象。</li>
<li>软引用：一些还有用、但非必须的对象，在内存发生溢出前被回收。使用 <code>SoftReference</code> 类来实现软引用。</li>
<li>弱引用：非必须对象，强度弱于软引用，在下一次垃圾收集时回收。使用 <code>WeakReference</code> 类来实现弱引用。</li>
<li>虚引用：最弱的一种引用关系，只是为了能在对象被回收时收到一个系统通知。使用 <code>PhantomReference</code> 来实现虚引用。</li>
</ul>
<h4 id="（4）如何判断一个常量是废弃常量"><a href="#（4）如何判断一个常量是废弃常量" class="headerlink" title="（4）如何判断一个常量是废弃常量"></a>（4）如何判断一个常量是废弃常量</h4><p>运⾏时常量池主要回收的是废弃的常量。那么，我们如何判断⼀个常量是废弃常量呢？</p>
<p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引⽤该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发⽣内存回收的话⽽且有必要的话，”abc” 就会被系统清理出常量池。</p>
<h4 id="（5）如何判断一个类是无用类"><a href="#（5）如何判断一个类是无用类" class="headerlink" title="（5）如何判断一个类是无用类"></a>（5）如何判断一个类是无用类</h4><p>⽅法区主要回收的是⽆⽤的类，那么如何判断⼀个类是⽆⽤的类的呢？<br>判定⼀个常量是否是“废弃常量”⽐较简单，⽽要判定⼀个类是否是“⽆⽤的类”的条件则相对苛刻许多。 类</p>
<p>需要同时满⾜下⾯3个条件才能算是 “⽆⽤的类” ：</p>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
<p> 加载该类的 ClassLoader 已经被回收。</p>
<p>该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类 的⽅法。虚拟机可以对满⾜上述3个条件的⽆⽤类进⾏回收，这⾥说的仅仅是“可以”，⽽并不是和对象⼀样不使 ⽤了就会必然被回收。</p>
<h4 id="（6）回收方法区的考量"><a href="#（6）回收方法区的考量" class="headerlink" title="（6）回收方法区的考量"></a>（6）回收方法区的考量</h4><ul>
<li>回收方法区的收益低</li>
</ul>
<p>垃圾收集通常可以回收70%-90%的空间，相比之下，方法区回收囿于苛刻的判定条件，回收效果远低于此。</p>
<ul>
<li>方法区的垃圾收集的内容<ul>
<li><strong>废弃的常量</strong><ul>
<li>回收行为和Java堆很类似。</li>
<li>例如：一个字符串 “java” 曾进入常量池，但程序中没有任何字符串对象引用“Java”常量，且虚拟机也没有其他地方引用这个字面量，此时如果发生内存回收，且垃圾收集器判断有必要时，该常量将被清理出常量池。常量池中的其他类、方法、字段的符号同理。</li>
</ul>
</li>
<li><strong>不再使用的类型</strong><ul>
<li>判定条件苛刻<ul>
<li>该类的所有实例被回收</li>
<li>类加载器被回收</li>
<li>类的 <code>java.lang.Class</code> 对象没有在任何地方被应用，无法通过反射创建该类的方法</li>
</ul>
</li>
<li>通过参数 <code>-Xnoclassgc</code> 参数进行控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（7）分代收集理论"><a href="#（7）分代收集理论" class="headerlink" title="（7）分代收集理论"></a>（7）分代收集理论</h4><ul>
<li><p><strong>弱</strong>分代假说：绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p><strong>强</strong>分代解说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</li>
<li><p>跨代引用假说：跨代引用相较于同代引用来说仅占极少数。</p>
</li>
</ul>
<hr>
<p>垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同区域之中存储。</p>
<ul>
<li>新生代：存活时间短的对象</li>
<li>老生代：存活时间长的对象</li>
</ul>
<h4 id="（8）标记-清除算法"><a href="#（8）标记-清除算法" class="headerlink" title="（8）标记-清除算法"></a>（8）标记-清除算法</h4><ul>
<li>标记</li>
</ul>
<p>标记出所有需要回收的对象</p>
<ul>
<li>清除</li>
</ul>
<p>标记完成过后统一回收所有被标记的对象</p>
<ul>
<li>缺点</li>
</ul>
<p>① 执行效率不稳定，尤其是当Java堆中存在大量需要被回收的对象时。</p>
<p>② 内存碎片化。</p>
<img src="/2021/08/12/java-all-in-one/mark-clear.png" alt="image-20210418184448479" style="zoom:67%;">



<h4 id="（9）标记-复制算法"><a href="#（9）标记-复制算法" class="headerlink" title="（9）标记-复制算法"></a>（9）标记-复制算法</h4><ul>
<li>半区复制</li>
</ul>
<p>将一块内存分为两块，当一块的内存用完后，将还存活的对象复制到另一块，然后将已使用过的内存空间一次清理掉。</p>
<ul>
<li>缺点</li>
</ul>
<p>浪费空间，可用空间只有原空间的1/2。</p>
<ul>
<li>应用</li>
</ul>
<p>现在的商用Java虚拟机采用该算法回收新生代，但由于新生代的大多数对象的存活时间很短，因此可以修改内存分配比例，例如HotSpot的将划分比例设置为为8：1（Eden：Survivor）。</p>
<img src="/2021/08/12/java-all-in-one/mark-copy.png" alt="image-20210418184801176" style="zoom: 67%;">



<h4 id="（10）标记-整理算法"><a href="#（10）标记-整理算法" class="headerlink" title="（10）标记-整理算法"></a>（10）标记-整理算法</h4><ul>
<li>标记</li>
</ul>
<p>标记出所有需要回收的对象</p>
<ul>
<li>整理</li>
</ul>
<p>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<img src="/2021/08/12/java-all-in-one/mark-category.png" alt="image-20210418185507506" style="zoom:67%;">

<h4 id="（11）分代收集算法"><a href="#（11）分代收集算法" class="headerlink" title="（11）分代收集算法"></a>（11）分代收集算法</h4><p>当前虚拟机的垃圾收集都采⽤分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不 同将内存分为⼏块。⼀般将java堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的特点选择合适 的垃圾收集算法。<br>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制 成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分 配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p>
<h4 id="（12）HotSpot为什么要分为新⽣代和⽼年代？"><a href="#（12）HotSpot为什么要分为新⽣代和⽼年代？" class="headerlink" title="（12）HotSpot为什么要分为新⽣代和⽼年代？"></a>（12）HotSpot为什么要分为新⽣代和⽼年代？</h4><p>主要是为了提升GC效率。上⾯提到的分代收集算法已经很好的解释了这个问题。</p>
<h3 id="1-4-3-常见垃圾回收器"><a href="#1-4-3-常见垃圾回收器" class="headerlink" title="1.4.3 常见垃圾回收器"></a>1.4.3 常见垃圾回收器</h3><img src="/2021/08/12/java-all-in-one/image-20210722203743221.png" alt="image-20210722203743221" style="zoom:67%;">

<p>没有适用全部场景的垃圾收集器，我们能做的就是根据具体应⽤场景选择适合⾃⼰的垃圾收集器</p>
<h4 id="（1）Serial收集器"><a href="#（1）Serial收集器" class="headerlink" title="（1）Serial收集器"></a>（1）Serial收集器</h4><h4 id="（2）ParNew收集器"><a href="#（2）ParNew收集器" class="headerlink" title="（2）ParNew收集器"></a>（2）ParNew收集器</h4><h4 id="（3）Parallel-Scavenge收集器"><a href="#（3）Parallel-Scavenge收集器" class="headerlink" title="（3）Parallel Scavenge收集器"></a>（3）Parallel Scavenge收集器</h4><h4 id="（4）Serial-Old收集器"><a href="#（4）Serial-Old收集器" class="headerlink" title="（4）Serial Old收集器"></a>（4）Serial Old收集器</h4><h4 id="（5）Parallel-Old收集器"><a href="#（5）Parallel-Old收集器" class="headerlink" title="（5）Parallel Old收集器"></a>（5）Parallel Old收集器</h4><h4 id="（6）CMS收集器"><a href="#（6）CMS收集器" class="headerlink" title="（6）CMS收集器"></a>（6）CMS收集器</h4><h4 id="（7）G1收集器"><a href="#（7）G1收集器" class="headerlink" title="（7）G1收集器"></a>（7）G1收集器</h4><h3 id="1-4-3-Java类文件"><a href="#1-4-3-Java类文件" class="headerlink" title="1.4.3 Java类文件"></a>1.4.3 Java类文件</h3><h4 id="（1）类文件结构"><a href="#（1）类文件结构" class="headerlink" title="（1）类文件结构"></a>（1）类文件结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/08/12/java-all-in-one/16d5ec47609818fc.jpeg" alt="img" style="zoom:33%;">

<ol>
<li>魔数: 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。 </li>
<li>Class ⽂件版本 ：Class ⽂件的版本号，保证编译正常执⾏。 </li>
<li>常量池 ：常量池主要存放两⼤常量：字⾯量和符号引⽤。 </li>
<li>访问标志 ：标志⽤于识别⼀些类或者接⼝层次的访问信息，包括：这个 Class 是类还是接⼝， 是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</li>
<li>当前类索引,⽗类索引 ：类索引⽤于确定这个类的全限定名，⽗类索引⽤于确定这个类的⽗类的 全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之 外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引 都不为 0。</li>
<li>接⼝索引集合 ：接⼝索引集合⽤来描述这个类实现了那些接⼝，这些被实现的接⼝将 按implents (如果这个类本身是接⼝的话则是extends ) 后的接⼝顺序从左到右排列在接⼝索引集合中。</li>
<li>字段表集合 ：描述接⼝或类中声明的变量。字段包括类级变量以及实例变量，但不包括在⽅法 内部声明的局部变量。</li>
<li>⽅法表集合 ：类中的⽅法。 </li>
<li>属性表集合 ： 在 Class ⽂件，字段表，⽅法表中都可以携带⾃⼰的属性表集合。</li>
</ol>
<h4 id="（2）类加载过程"><a href="#（2）类加载过程" class="headerlink" title="（2）类加载过程"></a>（2）类加载过程</h4><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">JavaGuide (gitee.io)</a></p>
<p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="/2021/08/12/java-all-in-one/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<h4 id="（3）加载步骤的流程"><a href="#（3）加载步骤的流程" class="headerlink" title="（3）加载步骤的流程"></a>（3）加载步骤的流程</h4><p>通过全类名获取类文件的二进制字节流</p>
<p>将字节流代表的静态存储结构转换为方法区的运行时数据结构</p>
<p>在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口</p>
<h4 id="（4）类加载器的分类"><a href="#（4）类加载器的分类" class="headerlink" title="（4）类加载器的分类"></a>（4）类加载器的分类</h4><p>VM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<p><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p>
<p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</p>
<p><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</p>
<h4 id="（5）双亲委派机制"><a href="#（5）双亲委派机制" class="headerlink" title="（5）双亲委派机制"></a>（5）双亲委派机制</h4><p>每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派 模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则 才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的 loadClass() 处理，因此所有的 请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当⽗类加载器⽆法处理 时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器 BootstrapClassLoader 作为 ⽗类加载器。</p>
<p><img src="/2021/08/12/java-all-in-one/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader"></p>
<h4 id="（6）双亲委派机制的好处"><a href="#（6）双亲委派机制的好处" class="headerlink" title="（6）双亲委派机制的好处"></a>（6）双亲委派机制的好处</h4><p>双亲委派模型保证了Java程序的稳定运⾏，可以避免类的重复加载（JVM 区分不同类的⽅式不仅仅根据 类名，相同的类⽂件被不同的类加载器加载产⽣的是两个不同的类），也保证了 Java 的核⼼ API 不 被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我 们编写⼀个称为 java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的 Object 类。</p>
<h4 id="（7）如果我们不想⽤双亲委派模型怎么办？"><a href="#（7）如果我们不想⽤双亲委派模型怎么办？" class="headerlink" title="（7）如果我们不想⽤双亲委派模型怎么办？"></a>（7）如果我们不想⽤双亲委派模型怎么办？</h4><p>继承 <code>ClassLoader</code> 实现自定义类加载器，并重写 <code>loadClass()</code> 方法</p>
<h4 id="（8）如何⾃定义类加载器"><a href="#（8）如何⾃定义类加载器" class="headerlink" title="（8）如何⾃定义类加载器?"></a>（8）如何⾃定义类加载器?</h4><p>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承⾃ java.lang.ClassLoader。如果我们要⾃定义⾃⼰的类加载器，很明显需要继承 ClassLoader。</p>
<h3 id="1-4-4"><a href="#1-4-4" class="headerlink" title="1.4.4"></a>1.4.4</h3><h1 id="二-计算机基础"><a href="#二-计算机基础" class="headerlink" title="二 计算机基础"></a>二 计算机基础</h1><h2 id="2-1-计算机网络"><a href="#2-1-计算机网络" class="headerlink" title="2.1 计算机网络"></a>2.1 计算机网络</h2><h3 id="2-1-1-基础知识"><a href="#2-1-1-基础知识" class="headerlink" title="2.1.1 基础知识"></a>2.1.1 基础知识</h3><h4 id="（1）五层协议"><a href="#（1）五层协议" class="headerlink" title="（1）五层协议"></a>（1）五层协议</h4><p>应用层：DNS、HTTP、SMTP；</p>
<p>运输层：TCP、UDP</p>
<p>网络层：IP、ICMP、ARP</p>
<p>数据链路层：Ethernet、IEEE802.3、PPP</p>
<p>物理层</p>
<h4 id="（2）TCP与UDP是啥，TCP与UDP的区别是啥？"><a href="#（2）TCP与UDP是啥，TCP与UDP的区别是啥？" class="headerlink" title="（2）TCP与UDP是啥，TCP与UDP的区别是啥？"></a>（2）TCP与UDP是啥，TCP与UDP的区别是啥？</h4><p>TCP：传输控制协议（<strong>Transmission Control Protocol</strong>）</p>
<p>UDP：用户数据报协议（<strong>User Datagram Protocol</strong>）</p>
<ul>
<li>TCP面向连接的，UDP是无连接的。</li>
<li>TCP提供可靠交付，UDP尽可能交付。</li>
<li>TCP面向字节流，UDP面向报文。</li>
<li>TCP提供流量控制，拥塞控制，UDP没有。</li>
<li>TCP是点对点的，UDP支持一对一，一对多，多对一，多对多。</li>
</ul>
<p>为了提供可靠的传输，TCP报文首部需要添加除了UDP具有的源端口号，目的端口号，报文长度，检验和意外的字段，比如：</p>
<ul>
<li>序号：报文编号，用于分段数据的正确重组</li>
<li>确认号：期望收到的下一个报文段的序号</li>
<li>ACK：确认应答有效</li>
<li>FIN：断开连接时候用</li>
<li>SYN：建立连接时候用</li>
<li>……</li>
</ul>
<p>TCP与UDP的编程区别：</p>
<p>通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。</p>
<p>而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。</p>
<p>基于上述不同，UDP和TCP编程步骤也有些不同，如下：<br>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt(); * 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、开启监听，用函数listen()；<br>　　5、接收客户端上来的连接，用函数accept()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；<br>　　8、关闭监听；</p>
<p>new socket—&gt;bing(ip,port)—&gt;listen—&gt;accept—&gt;read and write</p>
<p>TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p>
<p>new socket—&gt;connect(ip,port)—&gt;read and write.</p>
<p>与之对应的UDP编程步骤要简单许多，分别如下：<br>UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接；</p>
<p>new socket—&gt;bind()—&gt;recv.</p>
<p>UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p>
<p>new socket—&gt;bind—&gt;send.</p>
<h4 id="（2）TCP三次握手⭐"><a href="#（2）TCP三次握手⭐" class="headerlink" title="（2）TCP三次握手⭐"></a>（2）TCP三次握手⭐</h4><p><img src="/2021/08/12/java-all-in-one/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>一次握手：A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
<p>二次握手：B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
<p>三次握手：A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
<p>B 收到 A 的确认后，连接建立。</p>
<p><strong>为什么要三次握手？</strong></p>
<p>验证客户端与服务端是否具有对数据的收发能力。</p>
<p>第一次客户端发起，服务端收到确认客户端的发数据的能力。</p>
<p>第二次服务端发起，客户端收到确认服务端收发数据的能力。</p>
<p>第三次客户端发起，服务端收到确认客户端具有收数据的能力。</p>
<p>通过三次握手，客户端与服务端的收发数据的能力得以验证。</p>
<p>通过上述的方式确认客户端与服务端的数据收发能力，可以防止：</p>
<ul>
<li>服务器多次连接。由于数据传输的时延，客户机可能在等待一段时间之后，重新发起连接请求，如果不采取三次握手机制，那么服务器很可能存在多次连接的情况。只有正确经过三次握手的连接的才是正确的连接。</li>
<li>失效连接，让服务器打开错误的连接。</li>
</ul>
<h4 id="（3）第2次握手传回了ACK，为什么还要传回SYN？"><a href="#（3）第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="（3）第2次握手传回了ACK，为什么还要传回SYN？"></a>（3）第2次握手传回了ACK，为什么还要传回SYN？</h4><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
<h4 id="（4）TCP四次挥手⭐"><a href="#（4）TCP四次挥手⭐" class="headerlink" title="（4）TCP四次挥手⭐"></a>（4）TCP四次挥手⭐</h4><img src="/2021/08/12/java-all-in-one/TCP四次挥手.png" alt="TCP四次挥手" style="zoom:67%;">

<p><strong>四次挥手</strong></p>
<ul>
<li>客户端发送FIN，关闭客户端到服务器的数据传输</li>
<li>服务器收到FIN，并返回ACK确认收到客户端的FIN</li>
<li>服务器关闭和客户端的连接，发送FIN给客户端</li>
<li>客户端返回ACK确认收到服务器的FIN</li>
</ul>
<p><strong>为什么要四次挥手</strong></p>
<p>TCP连接是双向传输的对等模式，收发数据的成功与连接的建立与关闭都要告诉对方。</p>
<p>上层应用让客户端向服务端一个FIN请求，服务端收到应答，进入CLOSE_WAIT状态，继续发送还没发送完的报文。</p>
<p>当报文发送完毕之后，服务端主动发起FIN请求，客户端收到该请求并应答，此时客户端没有立即断开，而是进入TIME-WAIT。原因：</p>
<ul>
<li>确保最后一个报文收到，如果不回复ACK，服务端一段时候后重新发送该报文。</li>
</ul>
<h4 id="（5）TCP协议如何保证可靠数据传输？"><a href="#（5）TCP协议如何保证可靠数据传输？" class="headerlink" title="（5）TCP协议如何保证可靠数据传输？"></a>（5）TCP协议如何保证可靠数据传输？</h4><ul>
<li>有序性：TCP给每一个发送的包编号，接收方对数据包进行排序，把有序的数据传送给应用层</li>
<li>校验和：TCP保存它首部和数据块的校验和，如果收到数据的校验和有错，TCP将丢弃该报文</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只允许发送端发送接收端缓冲区能容纳的数据。（TCP利用滑动窗口实现流量控制）</li>
<li>拥塞控制：当网络拥塞时，减少数据的发送</li>
<li>ARQ协议：每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组</li>
<li>超时重传：当TCP发送报文后，启动一个定时器，若一段时间内未收到ACK确认，则重发该报文</li>
</ul>
<h4 id="（6）HTTP的长连接如何实现的？"><a href="#（6）HTTP的长连接如何实现的？" class="headerlink" title="（6）HTTP的长连接如何实现的？"></a>（6）HTTP的长连接如何实现的？</h4><p>HTTP短连接：客户端每进⾏⼀次HTTP操作，就同服务器建⽴⼀次连接，任务结束就中断连接。<br>HTTP长连接：响应头包含字段：<code>Connection:keep-alive</code>；⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的 TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。</p>
<p>HTTP协议的⻓连接和短连接实质上是TCP协议的⻓连接和短连接。</p>
<p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接、短连接究竟是什么？ - dai.sp - 博客园 (cnblogs.com)</a></p>
<h4 id="（7）ssh关闭连接后命令还会继续执行吗？"><a href="#（7）ssh关闭连接后命令还会继续执行吗？" class="headerlink" title="（7）ssh关闭连接后命令还会继续执行吗？"></a>（7）ssh关闭连接后命令还会继续执行吗？</h4><p>不会。</p>
<p>可以通过nohup命令实现关闭连接后继续执行命令。使用方式：<code>nohup Command [ Arg … ] [　&amp; ]</code></p>
<ul>
<li>&amp;：后台运行，忽略SIGINT信号（即ctrl+c）</li>
<li>nohup：忽略SIGHUP信号（即关闭shell）</li>
</ul>
<h4 id="（8）HTTP和HTTPS"><a href="#（8）HTTP和HTTPS" class="headerlink" title="（8）HTTP和HTTPS"></a>（8）HTTP和HTTPS</h4><ol>
<li>端⼝ ：HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默 认使⽤端⼝443。</li>
<li>安全性和资源消耗： HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务 器端都⽆法验证对⽅的身份。HTTPS是运⾏在SSL/TLS之上的HTTP协议，SSL/TLS 运⾏在 TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅ 的证书进⾏了⾮对称加密。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗 费更多服务器资源。<br>对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密 算法有DES、AES等；<br>⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥）， 加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称 加密速度较慢，典型的⾮对称加密算法有RSA、DSA等。</li>
</ol>
<h4 id="（9）为什么要有半关闭状态？"><a href="#（9）为什么要有半关闭状态？" class="headerlink" title="（9）为什么要有半关闭状态？"></a>（9）为什么要有半关闭状态？</h4><p>例如：在Unix中的rsh( 1 )命令，它将完成在另一个系统上执行一个命令。<br>命令 sun % rsh bsdi sort &lt; datafile<br>将在主机bsdi上执行sort排序命令，rsh命令的标准输入来自文件datafile。rsh将在它 与在另一主机上执行的程序间建立一个 TCP连接。 rsh的操作很简单：它将标准输入 （datafile）复制给TCP连接，并将结果从 TCP连接中复制给标准输出。（牢记TCP连接是全双工的）</p>
<p><img src="/2021/08/12/java-all-in-one/20190407172947752.png" alt="在这里插入图片描述"></p>
<p>sort程序只有读取到所有输入的数据后才能产生输出。而仅通过TCP来传输数据，会出现一些难以解决的问题，比如发送方数据已经发完后，没有数据可发，但是接收方无法知道数据已经发完，而会继续等待发送方发送数据，发送方只能通过发一下特定的东西来提示接收方数据已经发完，但又可能出现接收方并不认识发送方的提示，而将该提示也当作待处理的数据，这样两方就都会处于尴尬的阻塞，来等待对方的消息。现在半关闭就可以将此问题很简单的处理，发送方发现数据到达文件尾时，即没有数据发送了，这时发送方发送一个FIN来通知接收方我数据已经发送完了，接收方收到FIN后，向发送发回复一个ACK表示收到发送方的状态，此时发送方进入了半关闭的状态，但是还可以就收对方发送的数据，于是就等待对方对数据进行操作并把结果反馈给我。</p>
<h3 id="2-1-2-ARQ协议"><a href="#2-1-2-ARQ协议" class="headerlink" title="2.1.2 ARQ协议"></a>2.1.2 ARQ协议</h3><p><strong>自动重传请求（Automatic Repeat-reQuest, ARQ）</strong>是OSI模型中数据链路层和传输层的错误纠 正协议之⼀。它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。 如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停⽌等待ARQ 协议和连续ARQ协议。</p>
<h4 id="（1）停止等待ARQ协议"><a href="#（1）停止等待ARQ协议" class="headerlink" title="（1）停止等待ARQ协议"></a>（1）停止等待ARQ协议</h4><p>停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待 对⽅确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说 明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组； </p>
<p>在停⽌等待协议中，若接收⽅收到重复分组，就丢弃该分组，但同时还要发送确认；</p>
<p>优点：简单</p>
<p>缺点：信道利用率低、等待时间长</p>
<ol>
<li><strong>无差错情形：</strong></li>
</ol>
<p>发送方发送分组,接收⽅在规定时间内收到,并且回复确认.发送⽅再次发送。</p>
<ol start="2">
<li><strong>出现差错情形（超时重传）：</strong></li>
</ol>
<p>停⽌等待协议中超时重传是指只要超过⼀段时间仍然没有收到确认，就重传前⾯发送过的分组 （认为刚才发送过的分组丢失了）。因此每发送完⼀个分组需要设置⼀个超时计时器，其重传时 间应⽐数据在分组传输的平均往返时间更⻓⼀些。这种⾃动重传⽅式常称为 ⾃动重传请求 ARQ 。另外在停⽌等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协 议 可提⾼信道利⽤率。发送维持⼀个发送窗⼝，凡位于发送窗⼝内的分组可连续发送出去，⽽不 需要等待对⽅确认。接收⽅⼀般采⽤累积确认，对按序到达的最后⼀个分组发送确认，表明到这 个分组位置的所有分组都已经正确收到了。</p>
<ol start="3">
<li><strong>确认丢失和确认迟到：</strong></li>
</ol>
<ul>
<li>确认丢失：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li>确认迟到：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h4 id="（2）连续ARQ协议"><a href="#（2）连续ARQ协议" class="headerlink" title="（2）连续ARQ协议"></a>（2）连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p>优点：信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="2-1-3-网络算法"><a href="#2-1-3-网络算法" class="headerlink" title="2.1.3 网络算法"></a>2.1.3 网络算法</h3><h4 id="（1）拥塞控制"><a href="#（1）拥塞控制" class="headerlink" title="（1）拥塞控制"></a>（1）拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h4 id="（2）滑动窗口和流量控制"><a href="#（2）滑动窗口和流量控制" class="headerlink" title="（2）滑动窗口和流量控制"></a>（2）滑动窗口和流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="2-1-4-综合应用"><a href="#2-1-4-综合应用" class="headerlink" title="2.1.4 综合应用"></a>2.1.4 综合应用</h3><h4 id="（1）浏览器中键入www-google-com发生了什么"><a href="#（1）浏览器中键入www-google-com发生了什么" class="headerlink" title="（1）浏览器中键入www.google.com发生了什么"></a>（1）浏览器中键入<a href="http://www.google.com发生了什么/">www.google.com发生了什么</a></h4><img src="/2021/08/12/java-all-in-one/url输入到展示出来的过程.jpg" alt="img" style="zoom:50%;">

<p>DHCP 配置主机信息：</p>
<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FFFFFF，将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段又被放入 IP 数据报中，最后放入 MAC 帧中。</li>
<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>
<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>
</ul>
<p>ARP 解析 MAC 地址</p>
<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址FFFFFF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>
</ul>
<p>DNS 解析域名</p>
<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>
</ul>
<p>HTTP 请求页面</p>
<ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
<hr>
<p>总结一下就是：</p>
<p>首先如果没有IP配置，并且采用的自动IP配置，这个时候则会使用到DHCP协议获取主机IP地址，描述一下DHCP协议。在域名解析的过程中，发现首先需要找到网关路由器（DHCP过程中并没有学习网关路由器的MAC地址的过程），这个时候则需要借助ARP协议，描述一下ARP协议。获得了网关路由器的MAC地址，于是DNS请求报文继续发送，通过网络传输，这个过程涉及的协议包括：RIP，OSPF，BGP等一下。最终DNS服务器收到DNS请求报文并解析回复。当主机获得目的IP地址之后，便可以进行HTTP连接了，包括熟悉的三次握手机制等。最后通过四次挥手结束连接。</p>
<h4 id="（2）ping的过程"><a href="#（2）ping的过程" class="headerlink" title="（2）ping的过程"></a>（2）ping的过程</h4><p>ping的过程主要分为3个过程：DNS解析、ARP查找MAC地址、ICMP发送ping命令</p>
<p>ping是基于运行在网络层的ICMP协议传输的，如果ping的地址是域名，则首先要通过DNS查找域名所对应的ip，在查找域名的过程中涉及到利用ARP协议查找下一跳的MAC地址，获取到ip地址后，就使用ICMP协议向目标发送ping，发送的过程也涉及到通过ARP协议查找下一跳的mac地址这一过程。</p>
<h4 id="（3）TCP异常断开连接会发生什么？"><a href="#（3）TCP异常断开连接会发生什么？" class="headerlink" title="（3）TCP异常断开连接会发生什么？"></a>（3）TCP异常断开连接会发生什么？</h4><p>进程A和进程B建立了TCP连接，有一下四种异常断开场景</p>
<p><strong>一：进程B Crash，但进程B所在的宿主机仍然正常工作。</strong></p>
<p>这种情况我们通过 kill 命令直接杀进程就会出现，它的表现和进程调用Close类似，进程终止后，Socket会变成 Orphan Socket，会一个优雅的方式结束连接，即会向对端发送Fin报文，走正常关闭连接的那一套逻辑。</p>
<p><strong>二：进程B所在的宿主机宕机，又迅速重启。</strong></p>
<p>这种情况下，如果A进程恰好有发往B进程的Tcp报文，B重启前都会被丢弃，此时A可能会进入Rto状态，不断重发重传队列内的报文，在B主机被拉起后，重发的报文会被Linux协议栈接收，经过ip层处理，函数 tcp_v4_rcv 会在全局Socket哈希表中找处理该报文的Socket（监听目标端口的Socket，或者已建立连接的Socket），找到则交由该Socket处理，找不到则会向发送端回复Rst报文。</p>
<p>假设 B 主机启动后没有监听相关端口，则A的报文便会被 tcp_v4_rcv 函数判定为无效报文，回复 Rst 了事。</p>
<p><strong>三：进程B所在的宿主机宕机，短时间内没有重启，从A出发的所有报文都被网络丢弃。</strong></p>
<p>这种情况下，A与B的连接处于黑洞状态，A发送向B的所有报文都被丢弃，且没有任何回复，一定时长后便会触发RTO定时器，定时器处理函数会重发丢失的报文，重发的报文由于对端宕机也会被丢弃，就这样一直重传一直被丢弃，直到达到一定阈值，协议栈便会判定链路出现了故障，并通过Socket接口告诉应用程序链路故障，一般就是ETIMEOUT状态码。</p>
<p><strong>四：B已经断网/宕机/进程Crash，但此时A主机也没有需要向B发送的数据。</strong></p>
<p>如果恰巧A 进程没有任何要发往B的数据， A 进程就没有任何途径感知到进程B已经断开了连接了，这种状态也就是我们熟悉的Tcp半打开状态，也就是冷战状态，双方都不知道对方状态，也无探测报文去触发对方Rst或者Ack。这种情况下，就要有一方主动一点，抛出个橄榄枝，看看对方是要回个Rst拒绝你，还是要回个Ack接受你，还是啥也不回继续冷战，但至少通过这次探测，我们就可以知道对方的状态。这就是Tcp的KeepAlive 机制，Tcp KeepAlive 是协议栈里用来检测半打开状态的机制，在上面介绍的 tcp_init_xmit_timers 函数内，Tcp 启动了一个 keepAlive 定时器（默认时长是2个小时），2个小时后链路处于空闲状态，便会触发这个定时器，定时器的主要工作就是向对方发送探测报文。</p>
<h4 id="（4）TCP粘包与拆包"><a href="#（4）TCP粘包与拆包" class="headerlink" title="（4）TCP粘包与拆包"></a>（4）TCP粘包与拆包</h4><p><strong>什么是粘包与拆包</strong></p>
<p>TCP协议会将多个数据包打包成一个TCP报文发送出去，这就是所谓的<strong>粘包</strong>。而如果通讯的一端发送的数据包超过一次TCP报文所能传输的最大值时，就会将一个数据包拆成多个最大TCP长度的TCP报文分开传输，这就叫做<strong>拆包</strong>。</p>
<p>MTU(链路层的最大传输单元)=TCP（Header）+IP（header）+MSS(最大报文长度)</p>
<p>粘包发生的情况：</p>
<ul>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li>
</ul>
<p>拆包发生的情况：</p>
<ul>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li>
</ul>
<p><strong>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</strong></p>
<p>基于UDP与TCP头部的字段的差别，UDP通过报文长度字段指定报文的长度，在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p>
<p><strong>TCP粘包与拆包的解决方案：</strong></p>
<ul>
<li>消息定长，每个数据包封装为固定的长度。接收端读取固定长度即可。</li>
<li>消息边界，通过特殊边界确定不同消息之间的分段。</li>
<li>消息头部指定消息长度。</li>
</ul>
<h4 id="（5）窗口是什么？"><a href="#（5）窗口是什么？" class="headerlink" title="（5）窗口是什么？"></a>（5）窗口是什么？</h4><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。主要用于流量控制。</p>
<p><strong>什么是流量控制？</strong></p>
<p>流量控制就是通过控制发送方的窗口大小来控制发送速率，保证接收方能正确的接受数据。</p>
<p><strong>什么是拥塞控制？</strong></p>
<p>网络中出现拥塞，则会丢包，丢包则出发重传，从而进一步导致拥塞。拥塞情况出现需要控制发送发的发送速率，像流量控制一样，但是与流量控制是为了让接收方正确接受数据，而拥塞控制是要解决整个网络的拥塞情况。</p>
<p><strong>拥塞控制的四个算法是什么？</strong></p>
<ul>
<li>慢启动</li>
<li>快恢复</li>
<li>快速重传</li>
<li>拥塞避免</li>
</ul>
<p><img src="/2021/08/12/java-all-in-one/web.png" alt="在这里插入图片描述"></p>
<p>基本原则：超时很严重，3个ACK代表网络情况还好。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值.</p>
<p>出现超时情况，网络情况很糟糕，进入慢启动阶段。</p>
<p>但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫 做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p>
<p><strong>什么是Nagle算法</strong></p>
<p>Nagle算法是为了减少广域网的小分组数目，从而减小网络拥塞的出现，从而提高网络的利用率。该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组。</p>
<h4 id="（6）什么是ICMP协议？"><a href="#（6）什么是ICMP协议？" class="headerlink" title="（6）什么是ICMP协议？"></a>（6）什么是ICMP协议？</h4><p>ICMP协议：</p>
<p>由于互联网之间通讯会涉及很多网关和主机，为了能够报告数据错误，所以产生了 <code>ICMP</code>协议。也就是说 <code>ICMP</code> 协议就是为了更高效的转发 IP数据报和提高交付成功的机会。</p>
<p>ARP协议：</p>
<p>在一个局域网中，计算机通信实际上是依赖于 <code>MAC</code>地址进行通信的，那么 <code>ARP</code>（ <code>AddressResolutionProtocol</code>）的作用就是根据 IP地址查找出对应的 MAC地址。</p>
<p>ping的基本过程：</p>
<p>前提设定：ping <a href="http://www.abc.com/">www.abc.com</a></p>
<p>首先通过DNS协议解析出<a href="http://www.abc.com的ip地址,然后发起广播的arp请求,通过arp请求找到www.abc.com的mac地址进行通信./">www.abc.com的IP地址，然后发起广播的ARP请求，通过ARP请求找到www.abc.com的MAC地址进行通信。</a></p>
<h4 id="（7）什么是HTTP协议"><a href="#（7）什么是HTTP协议" class="headerlink" title="（7）什么是HTTP协议"></a>（7）什么是HTTP协议</h4><p><strong>HTTP与HTTPS的区别是什么</strong></p>
<ul>
<li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</li>
<li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li>
<li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而</li>
<li>HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</li>
</ul>
<p><strong>HTTPS加密方式：</strong></p>
<p>对称加密：双方拥有同一个一个密钥，进行加密与解密。</p>
<p>公开密钥：分为私钥与公钥，公钥可以解密私钥加密的数据，私钥可以解密公钥加密的数据。</p>
<p>加密通信：公钥加密，私钥解密。</p>
<p>数字签名：使用私钥加密形成的签名。验证发送方的身份的合法性。</p>
<p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p>
<p><strong>HTTP 是不保存状态的协议,如何保存用户状态</strong></p>
<p>① 基于 Session 实现的会话保持</p>
<p>在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p>
<p>优点：安全性高，因为状态信息保存在服务器端。</p>
<p>缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p>
<p>【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】</p>
<p>② 基于 Cookie 实现的会话保持</p>
<p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</p>
<p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。</p>
<p>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p>
<p><strong>DNS工作方式</strong></p>
<ul>
<li>递归查询：本地DNS服务器如果没有IP地址，则向根DNS服务器发送请求，依次进行。</li>
<li>迭代查询：本地DNS服务器如果没有IP地址，则根服务器发送请求，如果根没有，回复下一个需要查询的DNS服务器。</li>
</ul>
<p><strong>DNS为啥采用UDP协议：</strong></p>
<p>快！</p>
<h4 id="（8）什么是ARP协议？"><a href="#（8）什么是ARP协议？" class="headerlink" title="（8）什么是ARP协议？"></a>（8）什么是ARP协议？</h4><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
<h4 id="（9）SYN-FLOOD-是什么"><a href="#（9）SYN-FLOOD-是什么" class="headerlink" title="（9）SYN FLOOD 是什么"></a>（9）SYN FLOOD 是什么</h4><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>
<h3 id="2-1-5-Web"><a href="#2-1-5-Web" class="headerlink" title="2.1.5 Web"></a>2.1.5 Web</h3><h4 id="（1）状态码"><a href="#（1）状态码" class="headerlink" title="（1）状态码"></a>（1）状态码</h4><p><img src="/2021/08/12/java-all-in-one/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<h4 id="（2）HTTP如何保存用户状态？"><a href="#（2）HTTP如何保存用户状态？" class="headerlink" title="（2）HTTP如何保存用户状态？"></a>（2）HTTP如何保存用户状态？</h4><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h4 id="（3）Cookie和Session的区别？"><a href="#（3）Cookie和Session的区别？" class="headerlink" title="（3）Cookie和Session的区别？"></a>（3）Cookie和Session的区别？</h4><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。</p>
<p><strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h4 id="（4）URI和URL的区别？"><a href="#（4）URI和URL的区别？" class="headerlink" title="（4）URI和URL的区别？"></a>（4）URI和URL的区别？</h4><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h4 id="（5）HTTP和HTTPS的区别？"><a href="#（5）HTTP和HTTPS的区别？" class="headerlink" title="（5）HTTP和HTTPS的区别？"></a>（5）HTTP和HTTPS的区别？</h4><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
<p>安全性和资源消耗：</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
<h4 id="（6）Https的CA证书放了什么，公钥放在CA里吗？证书中包含公钥"><a href="#（6）Https的CA证书放了什么，公钥放在CA里吗？证书中包含公钥" class="headerlink" title="（6）Https的CA证书放了什么，公钥放在CA里吗？证书中包含公钥"></a>（6）Https的CA证书放了什么，公钥放在CA里吗？证书中包含公钥</h4><p><a href="https://www.cnblogs.com/xdyixia/p/11610102.html">HTTPS中CA证书的签发及使用过程 - xdyixia - 博客园 (cnblogs.com)</a></p>
<h2 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h2><h3 id="2-2-1-解决哈希冲突的方法"><a href="#2-2-1-解决哈希冲突的方法" class="headerlink" title="2.2.1 解决哈希冲突的方法"></a>2.2.1 解决哈希冲突的方法</h3><p>1， 开放定址法：<br>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入<br>公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1)<br>※ 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者<br>碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表<br>中无待查的关键字，即查找失败。<br>比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},表长为12。 我们用散列函数f(key) = key mod l2<br>当计算前S个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入： </p>
<p><img src="/2021/08/12/java-all-in-one/20170210213355178" alt="这里写图片描述"><br>计算key = 37时，发现f(37) = 1，此时就与25所在的位置冲突。<br>于是我们应用上面的公式f(37) = (f(37)+1) mod 12 = 2。于是将37存入下标为2的位置：<br><img src="/2021/08/12/java-all-in-one/20170210213443522" alt="这里写图片描述"></p>
<p>2， 再哈希法：<br>再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数<br>计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</p>
<p>3， 链地址法：<br>链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向<br>链表连接起来，如：<br>键值对k2, v2与键值对k1, v1通过计算后的索引值都为2，这时及产生冲突，但是可以通道next指针将k2, k1所在的节点连接起来，这样就解决了哈希的冲突问题<br><img src="/2021/08/12/java-all-in-one/20170210213528336" alt="这里写图片描述"><br>4， 建立公共溢出区：<br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
<h2 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a>2.3 算法</h2><h3 id="2-3-1-排序算法"><a href="#2-3-1-排序算法" class="headerlink" title="2.3.1 排序算法"></a>2.3.1 排序算法</h3><p><img src="/2021/08/12/java-all-in-one/image-20210727203221137.png" alt="image-20210727203221137"></p>
<p><a href="https://blog.csdn.net/hiudawn/article/details/80380572">排序算法之（9）–八种常用排序算法效率对比_hiudawn-CSDN博客_排序算法比较</a></p>
<h2 id="2-4-操作系统"><a href="#2-4-操作系统" class="headerlink" title="2.4 操作系统"></a>2.4 操作系统</h2><h3 id="2-4-1-基础知识"><a href="#2-4-1-基础知识" class="headerlink" title="2.4.1 基础知识"></a>2.4.1 基础知识</h3><h4 id="（1）什么是操作系统？"><a href="#（1）什么是操作系统？" class="headerlink" title="（1）什么是操作系统？"></a>（1）什么是操作系统？</h4><p><strong>操作系统是管理硬件和软件的一种应用程序</strong>。操作系统是运行在计算机上最重要的一种<code>软件</code>，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统的目的就是为了保证这些访问和交互能够准确无误的进行。</p>
<p><img src="/2021/08/12/java-all-in-one/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210728163635.png" alt="微信图片_20210728163635"></p>
<h4 id="（2）操作系统的主要功能"><a href="#（2）操作系统的主要功能" class="headerlink" title="（2）操作系统的主要功能"></a>（2）操作系统的主要功能</h4><ul>
<li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题</li>
<li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li>
<li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li>
<li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li>
<li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能</li>
</ul>
<h4 id="（3）操作系统的作用"><a href="#（3）操作系统的作用" class="headerlink" title="（3）操作系统的作用"></a>（3）操作系统的作用</h4><p>操作系统是一种软件，它的主要目的有三种</p>
<ul>
<li>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。</li>
<li>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。</li>
<li>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li>
</ul>
<h4 id="（4）为什么Linux下的程序不能再Windows下运行？"><a href="#（4）为什么Linux下的程序不能再Windows下运行？" class="headerlink" title="（4）为什么Linux下的程序不能再Windows下运行？"></a>（4）为什么Linux下的程序不能再Windows下运行？</h4><p>主要包括两点：可执行程序文件格式不同；系统的API不同</p>
<h4 id="（5）用户态和内核态"><a href="#（5）用户态和内核态" class="headerlink" title="（5）用户态和内核态"></a>（5）用户态和内核态</h4><p>用户态和内核态是操作系统的两种运行状态。</p>
<ul>
<li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li>
<li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li>
</ul>
<h4 id="（6）为什么要区分用户态和内核态？"><a href="#（6）为什么要区分用户态和内核态？" class="headerlink" title="（6）为什么要区分用户态和内核态？"></a>（6）为什么要区分用户态和内核态？</h4><p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>
<h4 id="（7）用户态和内核态如何切换？"><a href="#（7）用户态和内核态如何切换？" class="headerlink" title="（7）用户态和内核态如何切换？"></a>（7）用户态和内核态如何切换？</h4><p>通过系统调用进行切换</p>
<h4 id="（8）什么是boot-loader？"><a href="#（8）什么是boot-loader？" class="headerlink" title="（8）什么是boot loader？"></a>（8）什么是boot loader？</h4><p>boot loader 又被称为引导加载程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS 会执行一些初始测试，然后将控制权转移到引导加载程序所在的<code>主引导记录(MBR)</code> </p>
<h4 id="（9）Linux系统的启动过程"><a href="#（9）Linux系统的启动过程" class="headerlink" title="（9）Linux系统的启动过程"></a>（9）Linux系统的启动过程</h4><p>BIOS开机自检、导入MBR分区、调入内核、</p>
<p>BIOS开机自检：计算机通电后，会进入BIOS开机自检阶段，对硬件进行检测和初始化，并按照BIOS设置的启动顺序来启动</p>
<p>导入MBR分区：BIOS默认启动设备的第一个分区，即MBR分区会被读取到内存的固定位置执行</p>
<p>调入内核：MBR分区包含一个512字节的程序，负责从磁盘中调入boot程序，boot程序负责读取磁盘文件根目录，调入操作系统内核，并转交控制权。</p>
<p>内核启动：由汇编语言编写，主要包括创建内核堆栈、识别CPU类型、计算内存、禁用中断、启动内存管理单元等，然后调用C语言的main函数执行操作系统部分</p>
<p>操作系统初始化：初始化系统中各设备并做相关配置工作</p>
<p>运行init：启动进程0，执行初始化、配置时钟、挂载文件系统等操作，并创建init进程（1号进程）和守护进程（2号进程），然后init进程会fork一个shell进程，运行系统初始化脚本来执行系统初始化工作</p>
<p>运行终端：最后，init会启动终端供用户登录</p>
<h4 id="（10）什么是系统调用"><a href="#（10）什么是系统调用" class="headerlink" title="（10）什么是系统调用"></a>（10）什么是系统调用</h4><p>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<h3 id="2-4-2-进程和线程"><a href="#2-4-2-进程和线程" class="headerlink" title="2.4.2 进程和线程"></a>2.4.2 进程和线程</h3><h4 id="（1）时分共享技术和空分共享技术"><a href="#（1）时分共享技术和空分共享技术" class="headerlink" title="（1）时分共享技术和空分共享技术"></a>（1）时分共享技术和空分共享技术</h4><p>时分共享（time sharing）是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源（例如，CPU 或网络链接）可以被许多人共享。时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。</p>
<h4 id="（2）进程状态"><a href="#（2）进程状态" class="headerlink" title="（2）进程状态"></a>（2）进程状态</h4><p>一个进程的生命周期可以划分为一组状态，这些状态刻画了整个进程。进程状态即体现一个进程的生命状态</p>
<p>一般来说，进程有五种状态：</p>
<ul>
<li>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li>就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</li>
<li>执行状态：进程处于就绪状态被调度后，进程进入执行状态</li>
<li>阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</li>
<li>终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</li>
</ul>
<img src="/2021/08/12/java-all-in-one/v2-0ffc5a935616b8df3eb9ea949234f583_720w.jpg" alt="img" style="zoom:67%;">

<h4 id="（3）父子进程、僵尸进程、孤儿进程"><a href="#（3）父子进程、僵尸进程、孤儿进程" class="headerlink" title="（3）父子进程、僵尸进程、孤儿进程"></a>（3）父子进程、僵尸进程、孤儿进程</h4><p><strong>父子进程：</strong>在Linux里，除了进程0（即PID=0的进程）以外的所有进程都是由其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。</p>
<p><strong>僵尸进程：</strong>当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程。僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生。</p>
<p><strong>孤儿进程：</strong>孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害。</p>
<h4 id="（4）什么是进程、线程、协程？"><a href="#（4）什么是进程、线程、协程？" class="headerlink" title="（4）什么是进程、线程、协程？"></a>（4）什么是进程、线程、协程？</h4><ul>
<li>进程：运行中的程序</li>
<li>线程：线程是程序的一条执行路径，又被称作轻量级的进程</li>
<li>协程：是一种比线程更加轻量级的存在，可以看作轻量级的线程。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</li>
</ul>
<h4 id="（5）进程间的通信方式（Inter-Process-Communication，IPC）"><a href="#（5）进程间的通信方式（Inter-Process-Communication，IPC）" class="headerlink" title="（5）进程间的通信方式（Inter Process Communication，IPC）"></a>（5）进程间的通信方式（Inter Process Communication，IPC）</h4><p>竞态条件：即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为<code>竞态条件(race condition)</code>。</p>
<p>临界区：不仅<code>共享资源</code>会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。</p>
<p>忙等互斥：当一个进程在对资源进行修改时，其他进程必须进行等待，进程之间要具有互斥性，我们讨论的解决方案其实都是基于忙等互斥提出的。</p>
<p>主要包括7种方式：</p>
<ul>
<li><code>消息传递</code>：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方</li>
<li><code>先进先出队列</code>：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式</li>
<li><code>管道</code>：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。</li>
<li><code>直接通信</code>：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。</li>
<li><code>间接通信</code>：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。</li>
<li><code>消息队列</code>：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。</li>
<li><code>共享内存</code>：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。</li>
</ul>
<h4 id="（6）进程的状态"><a href="#（6）进程的状态" class="headerlink" title="（6）进程的状态"></a>（6）进程的状态</h4><p><img src="/2021/08/12/java-all-in-one/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210728172410.png" alt="微信图片_20210728172410"></p>
<ul>
<li><code>新建态</code>：进程的新建态就是进程刚创建出来的时候</li>
<li><code>运行态</code>：运行态指的就是进程实际占用 CPU 时间片运行时</li>
<li><code>就绪态</code>：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><code>阻塞态</code>：阻塞态又被称为睡眠态，它指的是进程不具备运行条件，正在等待被 CPU 调度。</li>
<li><code>终止态</code>：进程的终止态就是指进程执行完毕，到达结束点，或者因为错误而不得不中止进程。</li>
</ul>
<h4 id="（7）进程的调度算法"><a href="#（7）进程的调度算法" class="headerlink" title="（7）进程的调度算法"></a>（7）进程的调度算法</h4><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="2-4-3-内存管理"><a href="#2-4-3-内存管理" class="headerlink" title="2.4.3 内存管理"></a>2.4.3 内存管理</h3><h4 id="（1）内存管理机制"><a href="#（1）内存管理机制" class="headerlink" title="（1）内存管理机制"></a>（1）内存管理机制</h4><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li><strong>段页式管理机制</strong>：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</li>
</ol>
<h4 id="（2）TLB和多级页表"><a href="#（2）TLB和多级页表" class="headerlink" title="（2）TLB和多级页表"></a>（2）TLB和多级页表</h4><p><strong>快表</strong></p>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<p><strong>多级页表</strong></p>
<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景</p>
<h4 id="（3）页面置换算法"><a href="#（3）页面置换算法" class="headerlink" title="（3）页面置换算法"></a>（3）页面置换算法</h4><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h4 id="（4）空闲内存管理方式"><a href="#（4）空闲内存管理方式" class="headerlink" title="（4）空闲内存管理方式"></a>（4）空闲内存管理方式</h4><ul>
<li>使用位图管理</li>
<li>使用空闲列表</li>
</ul>
<h3 id="2-4-4-并发"><a href="#2-4-4-并发" class="headerlink" title="2.4.4 并发"></a>2.4.4 并发</h3><h4 id="（1）进程间的通信方式"><a href="#（1）进程间的通信方式" class="headerlink" title="（1）进程间的通信方式"></a>（1）进程间的通信方式</h4><ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h4 id="（2）进程间的同步方式"><a href="#（2）进程间的同步方式" class="headerlink" title="（2）进程间的同步方式"></a>（2）进程间的同步方式</h4><ol>
<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
<h3 id="2-4-5-死锁"><a href="#2-4-5-死锁" class="headerlink" title="2.4.5 死锁"></a>2.4.5 死锁</h3><h4 id="（1）死锁的定义"><a href="#（1）死锁的定义" class="headerlink" title="（1）死锁的定义"></a>（1）死锁的定义</h4><p>定义：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁</p>
<h4 id="（2）产生死锁的必要条件"><a href="#（2）产生死锁的必要条件" class="headerlink" title="（2）产生死锁的必要条件"></a>（2）产生死锁的必要条件</h4><ol>
<li>互斥条件：在一段时间内某资源仅为一个进程所占有。</li>
<li>不可剥夺条件：该资源只能由获得该资源的进程自己来释放。</li>
<li>占有并等待条件：进程在等待新资源的同时，继续占用已分配到的资源。</li>
<li>循环等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
<h4 id="（3）死锁的处理"><a href="#（3）死锁的处理" class="headerlink" title="（3）死锁的处理"></a>（3）死锁的处理</h4><ul>
<li>预防死锁：通过设置某些限制条件，去破坏死锁四个必要条件中的一个或多个</li>
<li>避免死锁：在资源动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁的产生</li>
<li>检测死锁：允许系统在运行过程中发生死锁，但可检测死锁的发生，并采取适当措施加以清除</li>
<li>解除死锁：当检测出死锁后，采取措施将进程从死锁状态中解脱出来</li>
</ul>
<h4 id="（4）预防死锁"><a href="#（4）预防死锁" class="headerlink" title="（4）预防死锁"></a>（4）预防死锁</h4><ul>
<li><p>破坏互斥条件：采用虚拟分配技术排除非共享设备死锁的可能性。</p>
</li>
<li><p>破坏不可剥夺条件：</p>
<ul>
<li>允许资源抢占</li>
</ul>
</li>
<li><p>破坏占有并等待：</p>
<ul>
<li>一次性资源分配方案</li>
<li>每个进程申请资源前，释放它所占有的资源</li>
</ul>
</li>
<li><p>破坏循环等待条：静态资源分配、有序资源分配、修复死锁、重启系统。</p>
</li>
</ul>
<h4 id="（5）避免死锁"><a href="#（5）避免死锁" class="headerlink" title="（5）避免死锁"></a>（5）避免死锁</h4><p><strong>方法：</strong></p>
<ul>
<li><p>有序资源分配法：资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），必须以上升的次序申请资源。</p>
</li>
<li><p>银行家算法：系统给当前进程分配资源时，先检查是否安全，如果安全，允许分配资源，否则让进程进入等待状态。</p>
<ul>
<li><a href="https://blog.csdn.net/wljliujuan/article/details/79651932/">https://blog.csdn.net/wljliujuan/article/details/79651932/</a></li>
</ul>
</li>
</ul>
<p><strong>技术：</strong></p>
<ul>
<li>加锁顺序：线程按照一定的顺序加锁，要求事先知道所有可能会用到的锁，并对这些锁做适当的排序，但总有些时候是无法预知的。</li>
<li>加锁时限：线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁。如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。</li>
<li>死锁检测：死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</li>
</ul>
<h4 id="（6）检测死锁"><a href="#（6）检测死锁" class="headerlink" title="（6）检测死锁"></a>（6）检测死锁</h4><h4 id="（7）解除死锁"><a href="#（7）解除死锁" class="headerlink" title="（7）解除死锁"></a>（7）解除死锁</h4><ul>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ul>
<h1 id="三-数据库"><a href="#三-数据库" class="headerlink" title="三 数据库"></a>三 数据库</h1><h2 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h2><h3 id="3-1-1-数据库架构"><a href="#3-1-1-数据库架构" class="headerlink" title="3.1.1 数据库架构"></a>3.1.1 数据库架构</h3><h4 id="（1）说说MySQL的基础架构"><a href="#（1）说说MySQL的基础架构" class="headerlink" title="（1）说说MySQL的基础架构"></a>（1）说说MySQL的基础架构</h4><p><img src="/2021/08/12/java-all-in-one/640" alt="图片"></p>
<p>Mysql逻辑架构图主要分三层：</p>
<p>（1）第一层负责连接处理，授权认证，安全等等 </p>
<p>（2）第二层负责编译并优化SQL </p>
<p>（3）第三层是存储引擎。</p>
<h4 id="（2）一条SQL查询语句在MySQL中如何执行的？"><a href="#（2）一条SQL查询语句在MySQL中如何执行的？" class="headerlink" title="（2）一条SQL查询语句在MySQL中如何执行的？"></a>（2）一条SQL查询语句在MySQL中如何执行的？</h4><ul>
<li>先检查该语句<code>是否有权限</code>，如果没有权限，直接返回错误信息，如果有权限会先查询缓存(MySQL8.0 版本以前)。</li>
<li>如果没有缓存，分析器进行<code>词法分析</code>，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</li>
<li>最后优化器确定执行方案进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会<code>调用数据库引擎接口</code>，返回执行结果。</li>
</ul>
<h3 id="3-1-2-索引"><a href="#3-1-2-索引" class="headerlink" title="3.1.2 索引"></a>3.1.2 索引</h3><h4 id="（1）聚集索引与非聚集索引的区别"><a href="#（1）聚集索引与非聚集索引的区别" class="headerlink" title="（1）聚集索引与非聚集索引的区别"></a>（1）聚集索引与非聚集索引的区别</h4><p>可以按以下四个维度回答：</p>
<ul>
<li><p>一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</p>
</li>
<li><p>聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p>
</li>
<li><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>
</li>
<li><p>聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</p>
</li>
</ul>
<h4 id="（2）为什么用B-树而不用二叉搜索树"><a href="#（2）为什么用B-树而不用二叉搜索树" class="headerlink" title="（2）为什么用B+树而不用二叉搜索树"></a>（2）为什么用B+树而不用二叉搜索树</h4><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是普通二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是 B+ 树呢？</p>
<ol>
<li>为什么不是普通二叉树？</li>
</ol>
<p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<ol start="2">
<li>为什么不是平衡二叉树呢？</li>
</ol>
<p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p>
<ol start="3">
<li>为什么不是 B 树而是 B+ 树呢？</li>
</ol>
<p>B+ 树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p>
<p>B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p>
<h4 id="（3）Hash-索引和-B-树索引区别是什么？你在设计索引是怎么抉择的？"><a href="#（3）Hash-索引和-B-树索引区别是什么？你在设计索引是怎么抉择的？" class="headerlink" title="（3）Hash 索引和 B+ 树索引区别是什么？你在设计索引是怎么抉择的？"></a>（3）Hash 索引和 B+ 树索引区别是什么？你在设计索引是怎么抉择的？</h4><ul>
<li>B+ 树可以进行范围查询，Hash 索引不能。</li>
<li>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。</li>
<li>B+ 树支持 order by 排序，Hash 索引不支持。</li>
<li>Hash 索引在等值查询上比 B+ 树效率更高。</li>
<li>B+ 树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li>
</ul>
<h4 id="（4）什么是最左前缀原则？什么是最左匹配原则？"><a href="#（4）什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="（4）什么是最左前缀原则？什么是最左匹配原则？"></a>（4）什么是最左前缀原则？什么是最左匹配原则？</h4><p>最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边。</p>
<p>当我们创建一个组合索引的时候，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和(a1,a2,a3)三个索引，这就是最左匹配原则。</p>
<h4 id="（5）索引不适合哪些场景"><a href="#（5）索引不适合哪些场景" class="headerlink" title="（5）索引不适合哪些场景?"></a>（5）索引不适合哪些场景?</h4><ul>
<li>数据量少的不适合加索引</li>
<li>更新比较频繁的也不适合加索引 = 区分度低的字段不适合加索引（如性别）</li>
</ul>
<h4 id="（6）索引有哪些优缺点？"><a href="#（6）索引有哪些优缺点？" class="headerlink" title="（6）索引有哪些优缺点？"></a>（6）索引有哪些优缺点？</h4><p>(1) 优点：</p>
<ul>
<li>唯一索引可以保证数据库表中每一行的数据的唯一性</li>
<li>索引可以加快数据查询速度，减少查询时间</li>
</ul>
<p>(2)缺点：</p>
<ul>
<li>创建索引和维护索引要耗费时间</li>
<li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</li>
<li>以表中的数据进行增、删、改的时候，索引也要动态的维护。</li>
</ul>
<h3 id="3-1-3-锁"><a href="#3-1-3-锁" class="headerlink" title="3.1.3 锁"></a>3.1.3 锁</h3><h4 id="（1）悲观锁、乐观锁的区别？"><a href="#（1）悲观锁、乐观锁的区别？" class="headerlink" title="（1）悲观锁、乐观锁的区别？"></a>（1）悲观锁、乐观锁的区别？</h4><ol>
<li>悲观锁：</li>
</ol>
<p>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p>
<ol start="2">
<li>乐观锁：</li>
</ol>
<p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。</p>
<p>实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p>
<h4 id="（2）什么是MVCC？它的底层原理是什么？"><a href="#（2）什么是MVCC？它的底层原理是什么？" class="headerlink" title="（2）什么是MVCC？它的底层原理是什么？"></a>（2）什么是MVCC？它的底层原理是什么？</h4><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术。</p>
<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</p>
<h3 id="3-1-4-查询优化"><a href="#3-1-4-查询优化" class="headerlink" title="3.1.4 查询优化"></a>3.1.4 查询优化</h3><h4 id="（1）怎么优化SQL"><a href="#（1）怎么优化SQL" class="headerlink" title="（1）怎么优化SQL"></a>（1）怎么优化SQL</h4><p><strong>优化表结构</strong></p>
<ul>
<li>尽量使用数字型字段</li>
</ul>
<p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<ul>
<li>尽可能的使用 varchar 代替 char</li>
</ul>
<p>变长字段存储空间小，可以节省存储空间。</p>
<ul>
<li>当索引列大量重复数据时，可以把索引删除掉</li>
</ul>
<p>比如有一列是性别，几乎只有男、女、未知，这样的索引是无效的。</p>
<p><strong>优化查询</strong></p>
<ul>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件</li>
<li>任何查询也不要出现select *</li>
<li>避免在 where 子句中对字段进行 null 值判断</li>
</ul>
<p><strong>索引优化</strong></p>
<ul>
<li>对作为查询条件和 order by的字段建立索引</li>
<li>避免建立过多的索引，多使用组合索引</li>
</ul>
<h4 id="（2）关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#（2）关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="（2）关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>（2）关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h4><p>我们平时写Sql时，都要养成用explain分析的习惯。慢查询的统计，运维会定期统计给我们</p>
<p>优化慢查询思路：</p>
<ul>
<li>分析语句，是否加载了不必要的字段/数据</li>
<li>分析 SQL 执行句话，是否命中索引等</li>
<li>如果 SQL 很复杂，优化 SQL 结构</li>
<li>如果表数据量太大，考虑分表</li>
</ul>
<h3 id="3-1-5-事务"><a href="#3-1-5-事务" class="headerlink" title="3.1.5 事务"></a>3.1.5 事务</h3><h4 id="（1）MySQL事务的四大特性以及实现原理"><a href="#（1）MySQL事务的四大特性以及实现原理" class="headerlink" title="（1）MySQL事务的四大特性以及实现原理"></a>（1）MySQL事务的四大特性以及实现原理</h4><ul>
<li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li>
<li>隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</li>
<li>持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li>
</ul>
<h4 id="（2）事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"><a href="#（2）事务的隔离级别有哪些？MySQL的默认隔离级别是什么？" class="headerlink" title="（2）事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"></a>（2）事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</h4><ul>
<li>读未提交（Read Uncommitted）</li>
<li>读已提交（Read Committed）</li>
<li>可重复读（Repeatable Read）</li>
<li>串行化（Serializable）</li>
</ul>
<p>Mysql默认的事务隔离级别是可重复读(Repeatable Read)</p>
<h4 id="（3）什么是幻读，脏读，不可重复读呢？"><a href="#（3）什么是幻读，脏读，不可重复读呢？" class="headerlink" title="（3）什么是幻读，脏读，不可重复读呢？"></a>（3）什么是幻读，脏读，不可重复读呢？</h4><p>事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据，这就是脏读。</p>
<p>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。</p>
<p>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</p>
<h2 id="3-2-MYSQL"><a href="#3-2-MYSQL" class="headerlink" title="3.2 MYSQL"></a>3.2 MYSQL</h2><h3 id="3-2-1-数据引擎"><a href="#3-2-1-数据引擎" class="headerlink" title="3.2.1 数据引擎"></a>3.2.1 数据引擎</h3><h4 id="（1）MyISAM和InnoDB区别"><a href="#（1）MyISAM和InnoDB区别" class="headerlink" title="（1）MyISAM和InnoDB区别"></a>（1）MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，⽽且提供了⼤量的特性， 包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和⾏级锁，⽽且最⼤的缺陷就是崩溃 后⽆法安全恢复。不过，5.5版本之后，MySQL引⼊了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>🌈 拓展一下：</p>
<p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p>🌈 拓展一下：</p>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p>
<p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p>
<h3 id="3-2-2-锁"><a href="#3-2-2-锁" class="headerlink" title="3.2.2 锁"></a>3.2.2 锁</h3><ul>
<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h3 id="3-2-3-实战应用"><a href="#3-2-3-实战应用" class="headerlink" title="3.2.3 实战应用"></a>3.2.3 实战应用</h3><h4 id="（1）MySQL数据库cpu飙升的话，要怎么处理呢？"><a href="#（1）MySQL数据库cpu飙升的话，要怎么处理呢？" class="headerlink" title="（1）MySQL数据库cpu飙升的话，要怎么处理呢？"></a>（1）MySQL数据库cpu飙升的话，要怎么处理呢？</h4><p>排查过程：</p>
<p>（1）使用top 命令观察，确定是mysqld导致还是其他原因。（2）如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。（3）找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</p>
<p>处理：</p>
<p>（1）kill 掉这些线程(同时观察 cpu 使用率是否下降)， （2）进行相应的调整(比如说加索引、改 sql、改内存参数) （3）重新跑这些 SQL。</p>
<p>其他情况：</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>
<h4 id="（2）MySQL的主从延迟，你怎么解决？"><a href="#（2）MySQL的主从延迟，你怎么解决？" class="headerlink" title="（2）MySQL的主从延迟，你怎么解决？"></a>（2）MySQL的主从延迟，你怎么解决？</h4><p><img src="/2021/08/12/java-all-in-one/640-16287371379022" alt="图片"></p>
<ul>
<li>步骤一：主库的更新事件(update、insert、delete)被写到binlog</li>
<li>步骤二：从库发起连接，连接到主库。</li>
<li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。</li>
<li>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li>
<li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li>
</ul>
<p><strong>主从同步延迟的原因</strong></p>
<p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p>
<p><strong>主从同步延迟的解决办法</strong></p>
<ul>
<li>主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置等。</li>
<li>选择更好的硬件设备作为slave。</li>
<li>把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。</li>
<li>增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。</li>
</ul>
<h4 id="（3）如果让你做分库与分表的设计，简单说说你会怎么做？"><a href="#（3）如果让你做分库与分表的设计，简单说说你会怎么做？" class="headerlink" title="（3）如果让你做分库与分表的设计，简单说说你会怎么做？"></a>（3）如果让你做分库与分表的设计，简单说说你会怎么做？</h4><p><strong>分库分表方案:</strong></p>
<ul>
<li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li>
<li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li>
<li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li>
<li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li>
</ul>
<p><strong>常用的分库分表中间件：</strong></p>
<ul>
<li>sharding-jdbc</li>
<li>Mycat</li>
</ul>
<p><strong>分库分表可能遇到的问题</strong></p>
<ul>
<li>事务问题：需要用分布式事务啦</li>
<li>跨节点Join的问题：解决这一问题可以分两次查询实现</li>
<li>跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li>
<li>数据迁移，容量规划，扩容等问题</li>
<li>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID</li>
<li>跨分片的排序分页问题</li>
</ul>
<h2 id="3-3-Redis"><a href="#3-3-Redis" class="headerlink" title="3.3 Redis"></a>3.3 Redis</h2><h3 id="3-3-1-Redis内存淘汰策略"><a href="#3-3-1-Redis内存淘汰策略" class="headerlink" title="3.3.1 Redis内存淘汰策略"></a>3.3.1 Redis内存淘汰策略</h3><p><a href="https://zhuanlan.zhihu.com/p/105587132">彻底弄懂Redis的内存淘汰策略 - 知乎 (zhihu.com)</a></p>
<h3 id="3-3-2-Redis的pipeline"><a href="#3-3-2-Redis的pipeline" class="headerlink" title="3.3.2 Redis的pipeline"></a>3.3.2 Redis的pipeline</h3><p><a href="https://blog.csdn.net/u011489043/article/details/78769428">(14条消息) 分布式缓存Redis之Pipeline（管道）_ZhangRui的博客-CSDN博客</a></p>
<h1 id="四-常用框架"><a href="#四-常用框架" class="headerlink" title="四 常用框架"></a>四 常用框架</h1><h2 id="4-1-Spring"><a href="#4-1-Spring" class="headerlink" title="4.1 Spring"></a>4.1 Spring</h2><h3 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h3><h4 id="（1）什么是Spring"><a href="#（1）什么是Spring" class="headerlink" title="（1）什么是Spring"></a>（1）什么是Spring</h4><p>轻量级的JavaEE开发框架</p>
<p>Spring的两个重要特性</p>
<ul>
<li>IOC：控制反转，将创建对象的过程交给Spring进行管理</li>
<li>AOP：面向切面，不修改源代码的情况加进行功能增强</li>
</ul>
<h3 id="4-1-2-控制反转（IOC）"><a href="#4-1-2-控制反转（IOC）" class="headerlink" title="4.1.2 控制反转（IOC）"></a>4.1.2 控制反转（IOC）</h3><p><a href="https://mp.weixin.qq.com/s/0zRks2Cz36S8N70Uonb0OA">https://mp.weixin.qq.com/s/0zRks2Cz36S8N70Uonb0OA</a></p>
<h4 id="（1）什么是Spring-IOC容器？"><a href="#（1）什么是Spring-IOC容器？" class="headerlink" title="（1）什么是Spring IOC容器？"></a>（1）什么是Spring IOC容器？</h4><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI）实现），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h4 id="（2）什么是IOC？"><a href="#（2）什么是IOC？" class="headerlink" title="（2）什么是IOC？"></a>（2）什么是IOC？</h4><p>控制反转：从主动创建对象变为被动接受对象（例如使用setter方式创建）</p>
<h4 id="（3）-使用IOC的好处"><a href="#（3）-使用IOC的好处" class="headerlink" title="（3） 使用IOC的好处"></a>（3） 使用IOC的好处</h4><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h4 id="（4）关键概念"><a href="#（4）关键概念" class="headerlink" title="（4）关键概念"></a>（4）关键概念</h4><ul>
<li>控制：资源的获取方式<ul>
<li>主动式：使用new方式创建资源，复杂对象的创建过于繁琐、麻烦。</li>
<li>被动式：资源的创建过程由容器来创建和设置，我们直接使用资源即可。</li>
</ul>
</li>
<li>容器：管理所有的组件（有功能的类）。</li>
<li>反转：将资源创建的过程交给Spring来做。</li>
<li>DI，Denpendency Injection：依赖注入，通过反射创建组件。</li>
</ul>
<h4 id="（5）Spring中有几种IOC容器？"><a href="#（5）Spring中有几种IOC容器？" class="headerlink" title="（5）Spring中有几种IOC容器？"></a>（5）Spring中有几种IOC容器？</h4><ul>
<li>BeanFactory ：粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “<strong>低级容器</strong>”。</li>
<li>ApplicationContext：可以称之为 “<strong>高级容器</strong>”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">BeanFactory</th>
<th align="left">ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td align="left">它使用懒加载</td>
<td align="left">它使用即时加载</td>
</tr>
<tr>
<td align="left">它使用语法显式提供资源对象</td>
<td align="left">它自己创建和管理资源对象</td>
</tr>
<tr>
<td align="left">不支持国际化</td>
<td align="left">支持国际化</td>
</tr>
<tr>
<td align="left">不支持基于依赖的注解</td>
<td align="left">支持基于依赖的注解</td>
</tr>
</tbody></table>
<h3 id="4-1-3-面向切面（AOP）"><a href="#4-1-3-面向切面（AOP）" class="headerlink" title="4.1.3 面向切面（AOP）"></a>4.1.3 面向切面（AOP）</h3><h4 id="（1）什么是AOP？"><a href="#（1）什么是AOP？" class="headerlink" title="（1）什么是AOP？"></a>（1）什么是AOP？</h4><p>AOP（Aspect Oriented Programming）：面向切面编程，指在<strong>程序运行期间</strong>，将<font color="red"><strong>某段代码</strong></font><font color="blue"><strong>动态的切入</strong></font>到**<font color="green">指定方法的指定位置</font>**进行运行的编程方式。</p>
<h4 id="（2）哪些场景下会使用到AOP？"><a href="#（2）哪些场景下会使用到AOP？" class="headerlink" title="（2）哪些场景下会使用到AOP？"></a>（2）哪些场景下会使用到AOP？</h4><ul>
<li>场景：计算器运行计算方法的时候进行日志记录<ul>
<li>直接编写在方法内部：耦合度太高，修改维护麻烦，不推荐</li>
<li>使用动态代理加入日志</li>
</ul>
</li>
</ul>
<h4 id="（3）AOP的好处？"><a href="#（3）AOP的好处？" class="headerlink" title="（3）AOP的好处？"></a>（3）AOP的好处？</h4><p>降低模块的耦合度、添加新的功能而不修改源代码</p>
<h4 id="（4）AOP底层原理"><a href="#（4）AOP底层原理" class="headerlink" title="（4）AOP底层原理"></a>（4）AOP底层原理</h4><p>使用动态代理：</p>
<ul>
<li>有接口：使用JDK动态代理</li>
<li>无接口：使用CGLIB动态代理 </li>
</ul>
<h3 id="4-1-4-进阶知识"><a href="#4-1-4-进阶知识" class="headerlink" title="4.1.4 进阶知识"></a>4.1.4 进阶知识</h3><h4 id="（1）Spring用到了哪些设计模式？"><a href="#（1）Spring用到了哪些设计模式？" class="headerlink" title="（1）Spring用到了哪些设计模式？"></a>（1）Spring用到了哪些设计模式？</h4><p>工厂模式：Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p>单例模式：Spring 中 bean 的默认作用域就是 singleton(单例)的</p>
<p>代理模式：AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p>
<p>观察者模式：观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用</p>
<p>适配器模式：</p>
<p>装饰者模式：</p>
<h1 id="六-微服务、分布式"><a href="#六-微服务、分布式" class="headerlink" title="六 微服务、分布式"></a>六 微服务、分布式</h1><p>高并发、高可用</p>
<blockquote>
<p>Reference:</p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机环境的Ubuntu Server20.04根空间满了(使用LVM分区)，使用命令行操作对其扩充</title>
    <url>/2021/12/31/lvm-extend/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>磁盘扩充可以分为三步：</p>
<ul>
<li>使用虚拟机分配新的磁盘空间</li>
<li>使用fdisk创建新的磁盘分区</li>
<li>将新建的磁盘分区加入到lv组（LV，Logic Volume）</li>
<li>扩充lv组</li>
</ul>
<h2 id="分配新的磁盘空间"><a href="#分配新的磁盘空间" class="headerlink" title="分配新的磁盘空间"></a>分配新的磁盘空间</h2><p>扩充磁盘空间时虚拟机要处于关机状态，而且要删除所有的快照.</p>
<img src="/2021/12/31/lvm-extend/image-20211231174641376.png" alt="image-20211231174641376" style="zoom: 67%;">

<h2 id="创建磁盘分区"><a href="#创建磁盘分区" class="headerlink" title="创建磁盘分区"></a>创建磁盘分区</h2><p>（1）查看磁盘分区</p>
<p>通过lsblk命令查看磁盘空间，可以看到磁盘sda从20G增长为了40G，但是新增的空间还没有被分配，因此我们接下来要使用fdisk命令创建新的磁盘分区。</p>
<p><img src="/2021/12/31/lvm-extend/image-20211231174904839.png" alt="image-20211231174904839"></p>
<p>（2）创建磁盘分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用命令n创建一个新的分区，并将剩余磁盘空间分配给该分区，我这里是sda4</span></span><br><span class="line">sudo fdisk /dev/sda</span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">GPT PMBR size mismatch (41943039 != 83886079) will be corrected by write.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (4-128, default 4): 4</span><br><span class="line">First sector (41940992-83886046, default 41940992):</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (41940992-83886046, default 83886046):</span><br><span class="line"></span><br><span class="line">Created a new partition 4 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 20 GiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/lvm-extend/image-20211231175408914.png" alt="image-20211231175408914"></p>
<h2 id="将新创建的磁盘加入到lv组"><a href="#将新创建的磁盘加入到lv组" class="headerlink" title="将新创建的磁盘加入到lv组"></a>将新创建的磁盘加入到lv组</h2><p>（1）把/dev/sda4添加到vg中</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pancras @ host in ~ [9:56:18] $ sudo vgs</span></span><br><span class="line">  VG        <span class="comment">#PV #LV #SN Attr   VSize   VFree</span></span><br><span class="line">  ubuntu<span class="literal">-vg</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span> wz-<span class="literal">-n</span>- &lt;<span class="number">19.00</span>g    <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pancras @ host in ~ [9:56:20] $ sudo vgextend ubuntu-vg /dev/sda4</span></span><br><span class="line">  Physical volume <span class="string">&quot;/dev/sda4&quot;</span> successfully created.</span><br><span class="line">  Volume <span class="built_in">group</span> <span class="string">&quot;ubuntu-vg&quot;</span> successfully extended</span><br><span class="line"></span><br><span class="line"><span class="comment"># pancras @ host in ~ [9:56:38] $ sudo vgs</span></span><br><span class="line">  VG        <span class="comment">#PV #LV #SN Attr   VSize  VFree</span></span><br><span class="line">  ubuntu<span class="literal">-vg</span>   <span class="number">2</span>   <span class="number">1</span>   <span class="number">0</span> wz-<span class="literal">-n</span>- <span class="number">38.99</span>g &lt;<span class="number">20.00</span>g</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/lvm-extend/image-20211231175820636.png" alt="image-20211231175820636"></p>
<h2 id="扩充lv组"><a href="#扩充lv组" class="headerlink" title="扩充lv组"></a>扩充lv组</h2><p>（1）将vg中空闲的空间加入lv中</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># pancras @ host in ~ [10:00:11] $ sudo lvs</span></span><br><span class="line">  LV        VG        Attr       LSize   Pool Origin <span class="keyword">Data</span>%  Meta%  <span class="built_in">Move</span> Log Cpy%Sync Convert</span><br><span class="line">  ubuntu<span class="literal">-lv</span> ubuntu<span class="literal">-vg</span> <span class="literal">-wi</span><span class="literal">-ao</span>---- &lt;<span class="number">19.00</span>g</span><br><span class="line"></span><br><span class="line"><span class="comment"># pancras @ host in ~ [10:00:13] $ sudo lvextend -l +100%free /dev/ubuntu-vg/ubuntu-lv</span></span><br><span class="line">  Size of logical volume ubuntu<span class="literal">-vg</span>/ubuntu<span class="literal">-lv</span> changed from &lt;<span class="number">19.00</span> GiB (<span class="number">4863</span> extents) to <span class="number">38.99</span> GiB (<span class="number">9982</span> exte                                   nts).</span><br><span class="line">  Logical volume ubuntu<span class="literal">-vg</span>/ubuntu<span class="literal">-lv</span> successfully resized.</span><br><span class="line"></span><br><span class="line"><span class="comment"># pancras @ host in ~ [10:00:36] $ sudo lvs</span></span><br><span class="line">  LV        VG        Attr       LSize  Pool Origin <span class="keyword">Data</span>%  Meta%  <span class="built_in">Move</span> Log Cpy%Sync Convert</span><br><span class="line">  ubuntu<span class="literal">-lv</span> ubuntu<span class="literal">-vg</span> <span class="literal">-wi</span><span class="literal">-ao</span>---- <span class="number">38.99</span>g</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/lvm-extend/image-20211231180112821.png" alt="image-20211231180112821"></p>
<p>（2）根分区识别空闲的磁盘空间</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pancras @ host in ~ [10:01:44] C:130 $ sudo resize2fs /dev/ubuntu-vg/ubuntu-lv</span></span><br><span class="line">resize2fs <span class="number">1.45</span>.<span class="number">5</span> (<span class="number">07</span><span class="literal">-Jan</span><span class="literal">-2020</span>)</span><br><span class="line">Filesystem at /dev/ubuntu<span class="literal">-vg</span>/ubuntu<span class="literal">-lv</span> is mounted on /; on<span class="literal">-line</span> resizing required</span><br><span class="line">old_desc_blocks = <span class="number">3</span>, new_desc_blocks = <span class="number">5</span></span><br><span class="line">The filesystem on /dev/ubuntu<span class="literal">-vg</span>/ubuntu<span class="literal">-lv</span> is now <span class="number">10221568</span> (<span class="number">4</span>k) blocks long.</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/lvm-extend/image-20211231180158274.png" alt="image-20211231180158274"></p>
<blockquote>
<p>Reference</p>
<p><a href="https://www.cnblogs.com/zhangshengdong/p/11724833.html#autoid-1-2-1">【linux】lvm扩展根分区 - 东瑜 - 博客园 (cnblogs.com)</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>all</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
