<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="PancrasL&#39;s blog">
  <meta name="keyword" content="blog">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Java 基础知识 | PancrasL的博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.1.1"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>PancrasL的博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Java 基础知识</h2>
  <p class="post-date">2021-04-21</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><img src="/2021/04/21/java-guide/java.jpg" alt="General 2560x1440 digitalocean Java coffee cup food artwork machine" style="zoom: 20%;">

<a id="more"></a>



<h1 id="1-Java特性"><a href="#1-Java特性" class="headerlink" title="1 Java特性"></a>1 Java特性</h1><h2 id="1-1-Java的特点？"><a href="#1-1-Java的特点？" class="headerlink" title="1.1 Java的特点？"></a>1.1 Java的特点？</h2><ul>
<li>面向对象（封装、继承、多态）</li>
<li>由于jvm的存在，Java和平台无关，一次编译，多地运行</li>
<li>编译和解释并存：Java源码→（javac编译）→.class字节码→（JVM解释）→机器码<ul>
<li>为了加速解释过程，引入运行时编译，即JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</li>
</ul>
</li>
<li>支持网络编程和多线程，能很方便地编写出多线程程序和网络程序。</li>
<li>自动内存管理，无需像C++一样要手动管理内存。</li>
</ul>
<h2 id="1-2-JVM、JDK、JRE的区别和联系？"><a href="#1-2-JVM、JDK、JRE的区别和联系？" class="headerlink" title="1.2 JVM、JDK、JRE的区别和联系？"></a>1.2 JVM、JDK、JRE的区别和联系？</h2><ul>
<li>JVM，Java Virtual Machine：运行Java字节码的虚拟机，在不同平台上有不同的实现（win、linux、macos），是Java语言跨平台的基础。</li>
<li>JRE，Java Runtime Environment：Java运行时环境，是运行已编译Java程序所需要内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他一些基础组件，但是它不能创建新程序。</li>
<li>JDK，Java Development Kit：它是JRE的超集，还包括编译器javac、工具如javadoc、jdb等，能够创建、编译和调试Java程序。</li>
</ul>
<h2 id="1-3-Java和C-的区别和联系"><a href="#1-3-Java和C-的区别和联系" class="headerlink" title="1.3 Java和C++的区别和联系"></a>1.3 Java和C++的区别和联系</h2><ul>
<li>Java是面向对象的语言，C++既可以面向对象，也可以面向过程。</li>
<li>Java不能操作指针，更加安全，C++可以操作指针，更加灵活。</li>
<li>Java有自动内存管理机制，无需程序员手动释放内存，而C++需要。</li>
<li>Java的类只支持单继承，C++类支持多继承，Java接口可以多继承。</li>
<li>C/C++的字符串以’\0’表示结束，但Java中没有这一概念。原因：Java中一切都是对象，字符串对象本身会记录自己的长度，无需浪费额外的空间存储’\0’。</li>
</ul>
<h2 id="1-4-面向过程和面向对象？"><a href="#1-4-面向过程和面向对象？" class="headerlink" title="1.4 面向过程和面向对象？"></a>1.4 面向过程和面向对象？</h2><p><strong>面向过程：</strong>分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展。</p>
<p><strong>面向对象：</strong>把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。<br>缺点：性能比面向过程低。</p>
<h2 id="1-5-为什么说Java编译和解释并存？"><a href="#1-5-为什么说Java编译和解释并存？" class="headerlink" title="1.5 为什么说Java编译和解释并存？"></a>1.5 为什么说Java编译和解释并存？</h2><p>Java编写的程序首先需要进行编译，生成字节码文件*.class，这种文件必须由Java解释器来解释执行，同时为了加快解释速度，引入运行时编译JIT，当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<p>![Java程序运行过程](java-guide/Java 程序运行过程.png)</p>
<h1 id="2-Java语法"><a href="#2-Java语法" class="headerlink" title="2 Java语法"></a>2 Java语法</h1><h2 id="2-1-字符型常量和字符串常量的区别？"><a href="#2-1-字符型常量和字符串常量的区别？" class="headerlink" title="2.1 字符型常量和字符串常量的区别？"></a>2.1 字符型常量和字符串常量的区别？</h2><ul>
<li>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的0个或多个字符。</li>
<li>含义上：字符常量相当于一个整型值（ASCII值），可以参与表达式运算；字符串常量代表字符串在内存中存放的位置。</li>
<li>占内存大小：字符常量占用2字节；字符串常量占用若干字节。</li>
</ul>
<h2 id="2-2-continue、break、return的区别是什么？"><a href="#2-2-continue、break、return的区别是什么？" class="headerlink" title="2.2 continue、break、return的区别是什么？"></a>2.2 continue、break、return的区别是什么？</h2><ul>
<li><code>continue</code>：继续下一次循环。</li>
<li><code>break</code>：跳出循环体，继续执行循环体之后的程序。</li>
<li><code>return</code>：结束方法的执行。</li>
</ul>
<h2 id="2-3-说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？"><a href="#2-3-说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="2.3 说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？"></a>2.3 说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？</h2><p>Java泛型是 JDK 5 引入的一个新特性，提供了编译时类型安全检测机制。</p>
<p>Java的泛型是伪泛型，类型擦除是指在编译期间，所有的泛型信息会被擦除。</p>
<p>常用通配符：</p>
<ul>
<li>? 表示 不确定的Java类型</li>
<li>T（Type）表示具体的一个Java类型</li>
<li>K V（Key Value）分别代表Java键值中的Key Value</li>
<li>E（Element）代表Element</li>
</ul>
<h2 id="2-4-和-equals-的区别？"><a href="#2-4-和-equals-的区别？" class="headerlink" title="2.4 == 和 equals 的区别？"></a>2.4 == 和 equals 的区别？</h2><ul>
<li>== ：如果是基本数据类型，==比较的是值是否相同；如果是引用数据类型，==比较的是内存地址是否相等。</li>
<li>equals()：所有对象的父类<code>Object</code>提供的方法，用于判断两个对象是否相等。分为两种情况：如果子类没有覆盖<code>equals</code>，效果等同于==。如果子类覆盖了equals()方法，通常用来比较两个对象的值是否相同。</li>
<li>String 中的 <code>equals</code> 方法被重写过，判断两个String对象相等的方法：<code>s1.equals(s2) == true或者s1.compareTo(s2) == 0</code></li>
</ul>
<h2 id="2-5-hashCode-与equals"><a href="#2-5-hashCode-与equals" class="headerlink" title="2.5 hashCode()与equals()"></a>2.5 hashCode()与equals()</h2><ul>
<li>说一说<code>hashCode()</code>？</li>
</ul>
<p><code>hashCode()</code> 定义在<code>Object</code>类中，Java1中的任何类都含有<code>hashCode()</code>方法。它的作用是获取哈希码，即一个int整数，用于确定该对象在哈希表中的索引位置。</p>
<ul>
<li>为什么要有<code>hashCode</code>？</li>
</ul>
<p>加快对象比较的速度，在插入Map时有很大的作用。如果两个对象的hashCode不同，则这两个对象一定不等，如果hashCode相等，可以再比较对象的值，大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<ul>
<li>为什么重写<code>equals</code>时必须要重写<code>hashCode</code>？</li>
</ul>
<p>equals方法内部会调用 <code>hashcode</code> 只是用来缩小查找成本，而<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等。</p>
<ul>
<li>为什么两个对象拥有相同的<code>hashcode</code>它们也不一定想等？</li>
</ul>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
<h2 id="2-6-自动装箱和自动拆箱"><a href="#2-6-自动装箱和自动拆箱" class="headerlink" title="2.6 自动装箱和自动拆箱"></a>2.6 自动装箱和自动拆箱</h2><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ul>
<h2 id="2-7-常量池"><a href="#2-7-常量池" class="headerlink" title="2.7 常量池"></a>2.7 常量池</h2><p>Java基本类型的包装类大部分（Byte、Short、Integer、Long、Character、Boolean）都实现了常量池，前面4种包装类创建了数值[-128,127]的缓存数据，Character创建了[0,127]范围内的缓存数据，Boolean直接返回True or False，如果超出范围仍然会创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i0 = <span class="number">127</span>;</span><br><span class="line">    Integer i1 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i0 == i1);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer i2 = <span class="number">128</span>;</span><br><span class="line">    Integer i3 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i2 == i3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer i4 = <span class="number">40</span>;</span><br><span class="line">    Integer i5 = <span class="number">10</span>;</span><br><span class="line">    Integer i6 = <span class="number">30</span>;</span><br><span class="line">    System.out.println(i4 == i5 + i6); <span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="number">40</span> == i5 + i6); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 语句 i4 == i5 + i6</span></span><br><span class="line">    <span class="comment">// 因为+这个操作符不适用于 Integer 对象</span></span><br><span class="line">    <span class="comment">// 首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40</span></span><br><span class="line">    <span class="comment">// 然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40</span></span><br><span class="line">    <span class="comment">// 最终这条语句转为 40 == 40 进行数值比较。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-8-重载和重写的区别？"><a href="#2-8-重载和重写的区别？" class="headerlink" title="2.8 重载和重写的区别？"></a>2.8 重载和重写的区别？</h2><ul>
<li><strong>重载：</strong>同样的一个方法能够根据输入数据的不同，做出不同的处理。</li>
<li><strong>重写：</strong>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要对父类方法进行覆盖，这个过程就叫重写。</li>
</ul>
<blockquote>
<p>以下方法无法被重写：</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="2-9-深拷贝和浅拷贝？"><a href="#2-9-深拷贝和浅拷贝？" class="headerlink" title="2.9 深拷贝和浅拷贝？"></a>2.9 深拷贝和浅拷贝？</h2><ul>
<li><strong>浅拷贝：</strong>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</li>
<li><strong>深拷贝：</strong>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</li>
</ul>
<p><img src="/2021/04/21/java-guide/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h2 id="2-10-构造器能被重写（override）吗？"><a href="#2-10-构造器能被重写（override）吗？" class="headerlink" title="2.10 构造器能被重写（override）吗？"></a>2.10 构造器能被重写（override）吗？</h2><p>构造器不能被重写，但可以被重载。</p>
<h1 id="3-Java面向对象"><a href="#3-Java面向对象" class="headerlink" title="3 Java面向对象"></a>3 Java面向对象</h1><h2 id="3-1-面向过程和面向对象的区别？"><a href="#3-1-面向过程和面向对象的区别？" class="headerlink" title="3.1 面向过程和面向对象的区别？"></a>3.1 面向过程和面向对象的区别？</h2><ul>
<li>面向过程：函数</li>
<li>面向对象：封装、继承、多态</li>
</ul>
<h2 id="3-2-成员变量和局部变量的区别？"><a href="#3-2-成员变量和局部变量的区别？" class="headerlink" title="3.2 成员变量和局部变量的区别？"></a>3.2 成员变量和局部变量的区别？</h2><p>成员变量属于对象，对象存在于堆内存，局部变量则存在于栈内存。特别地，被static修饰的成员变量属于类，位于方法区。</p>
<h2 id="3-3-面向对象的三大特性：封装、继承、多态"><a href="#3-3-面向对象的三大特性：封装、继承、多态" class="headerlink" title="3.3 面向对象的三大特性：封装、继承、多态"></a>3.3 面向对象的三大特性：封装、继承、多态</h2><ul>
<li>封装：将对象的一些属性或方法隐藏在内部，不允许外部对象直接访问对象信息，但可以给外部提供一些方法来操作属性。</li>
<li>继承：<ul>
<li>子类拥有父类的所有属性和方法，包括私有的，但私有的只是拥有，无法访问。</li>
<li>子类可以拓展父类，拥有自己的属性和方法。</li>
<li>子类可以重写父类方法进行覆盖。</li>
</ul>
</li>
<li>多态：父类指向子类的实例<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ul>
<h2 id="3-4-对象相等和它们的引用相等"><a href="#3-4-对象相等和它们的引用相等" class="headerlink" title="3.4 对象相等和它们的引用相等"></a>3.4 对象相等和它们的引用相等</h2><ul>
<li>对象相等：对象保存在内存中的数据相等</li>
<li>引用相等：对象的内存地址相等</li>
</ul>
<h2 id="3-5-StringBuffer和StringBuilder的区别和联系？"><a href="#3-5-StringBuffer和StringBuilder的区别和联系？" class="headerlink" title="3.5 StringBuffer和StringBuilder的区别和联系？"></a>3.5 <code>StringBuffer</code>和<code>StringBuilder</code>的区别和联系？</h2><ul>
<li>StringBuffer：线程安全，效率低</li>
<li>StringBuilder：线程不安全，效率高</li>
</ul>
<h2 id="3-6-类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？"><a href="#3-6-类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？" class="headerlink" title="3.6 类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？"></a>3.6 类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？</h2><ul>
<li>构造方法的作用是完成类对象的初始化工作</li>
<li>如果不显式编写构造方法，编译器会自动生成无参构造方法。</li>
</ul>
<h2 id="3-7-String为什么是不可变的？"><a href="#3-7-String为什么是不可变的？" class="headerlink" title="3.7 String为什么是不可变的？"></a>3.7 <code>String</code>为什么是不可变的？</h2><p><code>String</code>对象用<code>private final char value[]</code>保存字符串，因此不可变（JDK 9 之后采用<code>private final byte value[]</code>保存）</p>
<h2 id="3-8-构造方法的特点"><a href="#3-8-构造方法的特点" class="headerlink" title="3.8 构造方法的特点"></a>3.8 构造方法的特点</h2><ul>
<li>和类名相同</li>
<li>无返回值</li>
<li>可以被重载，不能被重写</li>
</ul>
<h1 id="4-反射"><a href="#4-反射" class="headerlink" title="4 反射"></a>4 反射</h1><h2 id="4-1-谈一谈反射？"><a href="#4-1-谈一谈反射？" class="headerlink" title="4.1 谈一谈反射？"></a>4.1 谈一谈反射？</h2><ul>
<li>反射：允许程序在执行期间借助于Refelction API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法<ul>
<li>正常方式：引入“包类”名称 → 通过new实例化 → 取得实例对象</li>
<li>反射方式：实例化对象 → getClass()方法 → 得到完整的“包类”名称</li>
</ul>
</li>
<li>优点：让代码更加灵活、为各种框架开箱即用的功能提供了便利</li>
<li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。</li>
</ul>
<h2 id="4-2-反射的应用场景"><a href="#4-2-反射的应用场景" class="headerlink" title="4.2 反射的应用场景"></a>4.2 反射的应用场景</h2><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。这些框架中也用到了动态代理，而动态代理的实现也依赖反射。</p>
<ul>
<li>通过反射创建类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    p.showName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射访问类属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Class clazz = Person.class;</span><br><span class="line">       Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">       Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">       System.out.println(p.toString());</span><br><span class="line">       Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">       age.set(p, <span class="number">10</span>);</span><br><span class="line">       System.out.println(p.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射调用类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p = (Person) cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    Method showName = clazz.getDeclaredMethod(<span class="string">&quot;showName&quot;</span>);</span><br><span class="line">    showName.invoke(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过反射访问私有属性、方法、构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 调用私有构造器</span></span><br><span class="line">    Constructor cons = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person p1 = (Person) cons.newInstance(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p1, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有方法</span></span><br><span class="line">    Method showAge = clazz.getDeclaredMethod(<span class="string">&quot;showAge&quot;</span>);</span><br><span class="line">    showAge.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    showAge.invoke(p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-注解和反射"><a href="#4-3-注解和反射" class="headerlink" title="4.3 注解和反射"></a>4.3 注解和反射</h2><p>基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。（基于注解编程的原理）</p>
<h1 id="5-异常"><a href="#5-异常" class="headerlink" title="5 异常"></a>5 异常</h1><img src="/2021/04/21/java-guide/Java异常类层次结构图2.png" alt="img" style="zoom: 40%;">





<h1 id="6-多线程"><a href="#6-多线程" class="headerlink" title="6 多线程"></a>6 多线程</h1><h2 id="6-1-程序、线程、进程？"><a href="#6-1-程序、线程、进程？" class="headerlink" title="6.1 程序、线程、进程？"></a>6.1 程序、线程、进程？</h2><ul>
<li>程序：含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</li>
<li>进程：正在运行的一个程序。是<strong>资源分配的单位</strong>。</li>
<li>线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。是<strong>调度和执行的单位</strong>。</li>
</ul>
<h2 id="6-2-程序的生命周期"><a href="#6-2-程序的生命周期" class="headerlink" title="6.2 程序的生命周期"></a>6.2 程序的生命周期</h2><p><img src="/2021/04/21/java-guide/lifecycle.png"></p>
<h1 id="7-I-O流"><a href="#7-I-O流" class="headerlink" title="7 I/O流"></a>7 I/O流</h1><h2 id="7-1-I-O流的分类？"><a href="#7-1-I-O流的分类？" class="headerlink" title="7.1 I/O流的分类？"></a>7.1 I/O流的分类？</h2><ul>
<li>按数据单位：字节流（8bit）、字符流（16bit）</li>
<li>按数据流向：输入流、输出流</li>
<li>按流的角色：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td align="center">Wrider</td>
</tr>
</tbody></table>
<h2 id="7-2-序列化和反序列化"><a href="#7-2-序列化和反序列化" class="headerlink" title="7.2 序列化和反序列化"></a>7.2 序列化和反序列化</h2><ul>
<li>利用序列化和反序列化机制，可以将Java对象持久化，或者在网络中传输。</li>
<li>序列化：将数据结构或Java对象转换为二进制字节流。</li>
<li>反序列化：将二进制字节流转换为数据结构或Java对象。</li>
</ul>
<p><img src="/2021/04/21/java-guide/se-deserialization.png" alt="img"></p>
<h2 id="7-3-不想序列化某些属性"><a href="#7-3-不想序列化某些属性" class="headerlink" title="7.3 不想序列化某些属性"></a>7.3 不想序列化某些属性</h2><ul>
<li><code>transient</code> : 只用于修饰变量，不用于修饰类和方法，被修饰的变量不会被序列化和反序列化。</li>
</ul>
<h2 id="7-4-获取键盘输入的两种方式"><a href="#7-4-获取键盘输入的两种方式" class="headerlink" title="7.4 获取键盘输入的两种方式"></a>7.4 获取键盘输入的两种方式</h2><ul>
<li>使用 <code>Scanner</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>



<ul>
<li>使用 <code>BufferedReader</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">String s = input.readLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>





<h2 id="7-5-BIO、NIO、AIO的区别？"><a href="#7-5-BIO、NIO、AIO的区别？" class="headerlink" title="7.5 BIO、NIO、AIO的区别？"></a>7.5 BIO、NIO、AIO的区别？</h2><ul>
<li>BIO (Blocking I/O)，即<strong>同步阻塞I/O</strong>，用户发起I/O请求会会一直阻塞，直到内核把数据拷贝到用户空间，不适合高并发场景。</li>
</ul>
<img src="/2021/04/21/java-guide/bio.png" alt="image-20210531214925715" style="zoom:50%;">



<ul>
<li><p>NIO (Non-blocking/New I/O)，即<strong>同步非阻塞 IO</strong></p>
<ul>
<li>应用程序会一直发起 read 调用，等待数据内核把数据拷贝到用户空间。</li>
<li>优点：相比于BIO，同步非阻塞 IO 通过轮询操作，<strong>避免了一直阻塞</strong>。</li>
</ul>
<ul>
<li>缺点：<strong>轮询过程消耗 CPU 资源</strong>。</li>
</ul>
</li>
</ul>
<img src="/2021/04/21/java-guide/nio.png" alt="image-20210531215133678" style="zoom:50%;">

<ul>
<li>NIO的<strong>I/O 多路复用模型</strong> <ul>
<li>线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。</li>
<li>优点：通过减少无效的系统调用，减少了对 CPU 资源的消耗。</li>
</ul>
</li>
</ul>
<img src="/2021/04/21/java-guide/nio1.png" alt="image-20210531215430672" style="zoom:50%;">

<ul>
<li>AIO (Asynchronous I/O)<ul>
<li>AIO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</li>
</ul>
<img src="/2021/04/21/java-guide/aio.png" alt="img" style="zoom: 67%;">

<ul>
<li>Summary</li>
</ul>
<img src="/2021/04/21/java-guide/iosummary.png" alt="img" style="zoom:50%;"></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#all" >
    <span class="tag-code">all</span>
  </a>

  <a href="/tags#java" >
    <span class="tag-code">java</span>
  </a>

  <a href="/tags#learn" >
    <span class="tag-code">learn</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/04/16/java-virtual-machine/">
        <span class="nav-arrow">← </span>
        
          搞懂 Java 虚拟机
        
      </a>
    
    
      <a class="nav-right" href="/2021/05/28/k6-tool-usage/">
        
          k6测试工具的使用
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1-Java%E7%89%B9%E6%80%A7"><span class="toc-nav-text">1 Java特性</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-Java%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-nav-text">1.1 Java的特点？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-JVM%E3%80%81JDK%E3%80%81JRE%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-nav-text">1.2 JVM、JDK、JRE的区别和联系？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-3-Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-nav-text">1.3 Java和C++的区别和联系</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-4-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-nav-text">1.4 面向过程和面向对象？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%EF%BC%9F"><span class="toc-nav-text">1.5 为什么说Java编译和解释并存？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2-Java%E8%AF%AD%E6%B3%95"><span class="toc-nav-text">2 Java语法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">2.1 字符型常量和字符串常量的区别？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-continue%E3%80%81break%E3%80%81return%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">2.2 continue、break、return的区别是什么？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E8%AF%B4%E4%B8%80%E8%AF%B4Java%E6%B3%9B%E5%9E%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F"><span class="toc-nav-text">2.3 说一说Java泛型？什么是类型擦除？介绍一下常用的通配符？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">2.4 &#x3D;&#x3D; 和 equals 的区别？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-5-hashCode-%E4%B8%8Eequals"><span class="toc-nav-text">2.5 hashCode()与equals()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-6-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="toc-nav-text">2.6 自动装箱和自动拆箱</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-7-%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-nav-text">2.7 常量池</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-8-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">2.8 重载和重写的区别？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-9-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-nav-text">2.9 深拷贝和浅拷贝？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-10-%E6%9E%84%E9%80%A0%E5%99%A8%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89%E5%90%97%EF%BC%9F"><span class="toc-nav-text">2.10 构造器能被重写（override）吗？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">3 Java面向对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">3.1 面向过程和面向对象的区别？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">3.2 成员变量和局部变量的区别？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-nav-text">3.3 面向对象的三大特性：封装、继承、多态</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E5%92%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89"><span class="toc-nav-text">3.4 对象相等和它们的引用相等</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-5-StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-nav-text">3.5 StringBuffer和StringBuilder的区别和联系？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-6-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-nav-text">3.6 类的构造方法的作用是什么？如果一个类没有声明构造方法，程序可以执行吗？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-7-String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">3.7 String为什么是不可变的？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-8-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-nav-text">3.8 构造方法的特点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4-%E5%8F%8D%E5%B0%84"><span class="toc-nav-text">4 反射</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-%E8%B0%88%E4%B8%80%E8%B0%88%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-nav-text">4.1 谈一谈反射？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-nav-text">4.2 反射的应用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-3-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-nav-text">4.3 注解和反射</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5-%E5%BC%82%E5%B8%B8"><span class="toc-nav-text">5 异常</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-nav-text">6 多线程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-1-%E7%A8%8B%E5%BA%8F%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">6.1 程序、线程、进程？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-nav-text">6.2 程序的生命周期</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#7-I-O%E6%B5%81"><span class="toc-nav-text">7 I&#x2F;O流</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-1-I-O%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-nav-text">7.1 I&#x2F;O流的分类？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-2-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-nav-text">7.2 序列化和反序列化</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-3-%E4%B8%8D%E6%83%B3%E5%BA%8F%E5%88%97%E5%8C%96%E6%9F%90%E4%BA%9B%E5%B1%9E%E6%80%A7"><span class="toc-nav-text">7.3 不想序列化某些属性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-4-%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">7.4 获取键盘输入的两种方式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-5-BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">7.5 BIO、NIO、AIO的区别？</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://pancrasl.gitee.io/2021/04/21/java-guide/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>